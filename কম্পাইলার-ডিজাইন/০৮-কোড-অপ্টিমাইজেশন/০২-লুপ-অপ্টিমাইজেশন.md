# 🔁 লুপ অপ্টিমাইজেশন

## লুপ অপ্টিমাইজেশন কী?

**Loop Optimization** হলো loops-এর execution time এবং resource usage minimize করার জন্য বিভিন্ন transformations।

```
┌─────────────────────────────────────────────────────────────────┐
│                  Loop Optimization                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  কেন গুরুত্বপূর্ণ?                                                │
│  ━━━━━━━━━━━━━━━━                                                │
│  প্রোগ্রামের ৯০% execution time ১০% code-এ যায়                   │
│  সেই ১০% code বেশিরভাগই loops!                                   │
│                                                                 │
│  ┌────────────────────────────────────────────────────────┐     │
│  │                                                        │     │
│  │      90% time                                          │     │
│  │    ┌─────────┐                                         │     │
│  │    │  Loops  │  ←── এখানে optimize করলে বেশি লাভ       │     │
│  │    └─────────┘                                         │     │
│  │         │                                              │     │
│  │    ─────┴───── 10% code                                │     │
│  │                                                        │     │
│  └────────────────────────────────────────────────────────┘     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 📊 Loop Optimization Techniques

```
┌─────────────────────────────────────────────────────────────────┐
│              Loop Optimization Types                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  1. Code Motion (Loop Invariant)                                │
│     └── Loop-invariant code বাইরে সরানো                         │
│                                                                 │
│  2. Induction Variable                                          │
│     └── Loop counter-এর সাথে সম্পর্কিত variable optimize         │
│                                                                 │
│  3. Strength Reduction                                          │
│     └── Expensive operation → Cheap operation                   │
│                                                                 │
│  4. Loop Unrolling                                              │
│     └── Loop body replicate করে iteration কমানো                 │
│                                                                 │
│  5. Loop Fusion                                                 │
│     └── Multiple loops একত্রিত করা                              │
│                                                                 │
│  6. Loop Fission                                                │
│     └── একটি loop ভেঙে multiple loops করা                       │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 🚀 Code Motion (Loop Invariant Code Motion)

### ধারণা:
যে code প্রতি iteration-এ same result দেয়, তাকে loop-এর বাইরে নেওয়া।

```
┌─────────────────────────────────────────────────────────────────┐
│                  Code Motion                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Before:                          After:                        │
│  ───────                          ──────                        │
│  for (i = 0; i < n; i++) {        t = x * y;     // Moved out!  │
│      a[i] = x * y + i;            for (i = 0; i < n; i++) {     │
│  }                                    a[i] = t + i;             │
│                                   }                             │
│                                                                 │
│  x * y: n বার compute            x * y: ১ বার compute           │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Before:                          After:                        │
│  ───────                          ──────                        │
│  for (i = 0; i < n; i++) {        len = strlen(s);              │
│      if (i < strlen(s)) {         for (i = 0; i < n; i++) {     │
│          ...                          if (i < len) {            │
│      }                                    ...                   │
│  }                                    }                         │
│                                   }                             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 📈 Induction Variable Optimization

### ধারণা:
Loop counter-এর সাথে linear relationship আছে এমন variable optimize করা।

```
┌─────────────────────────────────────────────────────────────────┐
│              Induction Variable Analysis                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Before:                          After:                        │
│  ───────                          ──────                        │
│  for (i = 0; i < n; i++) {        j = 0;                        │
│      j = 4 * i;                   for (i = 0; i < n; i++) {     │
│      a[j] = 0;                        a[j] = 0;                 │
│  }                                    j = j + 4;                │
│                                   }                             │
│                                                                 │
│  j = 4 * i                        j += 4 (addition only)        │
│  (multiplication)                                               │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Induction Variables:                                           │
│  ├── Basic: i (loop counter)                                    │
│  └── Derived: j = c * i + d (linear function of i)             │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## ⚡ Strength Reduction

### ধারণা:
Expensive operation-কে cheaper operation দিয়ে replace করা।

```
┌─────────────────────────────────────────────────────────────────┐
│                Strength Reduction                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Expensive → Cheap:                                             │
│  ──────────────────                                             │
│  x * 2      →  x << 1      (shift left)                        │
│  x * 4      →  x << 2                                          │
│  x * 8      →  x << 3                                          │
│  x / 2      →  x >> 1      (shift right)                       │
│  x % 2      →  x & 1       (bitwise AND)                       │
│  x ** 2     →  x * x                                           │
│                                                                 │
│  ─────────────────────────────────────────────────────────────  │
│                                                                 │
│  Before:                          After:                        │
│  ───────                          ──────                        │
│  for (i = 0; i < n; i++) {        t = 0;                        │
│      a[i*4] = 0;                  for (i = 0; i < n; i++) {     │
│  }                                    a[t] = 0;                 │
│                                       t = t + 4;                │
│  Multiplication in loop           }                             │
│                                   Addition only!                │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 🔄 Loop Unrolling

### ধারণা:
Loop body কয়েকবার replicate করে iteration সংখ্যা কমানো।

```
┌─────────────────────────────────────────────────────────────────┐
│                  Loop Unrolling                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Before (100 iterations):          After (25 iterations):       │
│  ─────────────────────────         ───────────────────────      │
│  for (i = 0; i < 100; i++) {      for (i = 0; i < 100; i += 4) {│
│      a[i] = b[i] + c[i];              a[i] = b[i] + c[i];       │
│  }                                    a[i+1] = b[i+1] + c[i+1]; │
│                                       a[i+2] = b[i+2] + c[i+2]; │
│                                       a[i+3] = b[i+3] + c[i+3]; │
│                                   }                             │
│                                                                 │
│  সুবিধা:                                                         │
│  ├── কম loop overhead (comparison, increment)                   │
│  ├── Instruction-level parallelism                              │
│  └── Better pipeline utilization                                │
│                                                                 │
│  অসুবিধা:                                                        │
│  ├── বেশি code size                                              │
│  └── Register pressure বাড়ে                                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

## 💻 Loop Optimizer Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// ═══════════════════════════════════════════════════════════
// TAC Structures for Loop Analysis
// ═══════════════════════════════════════════════════════════

typedef enum {
    OP_ADD, OP_SUB, OP_MUL, OP_DIV,
    OP_COPY, OP_GOTO, OP_IF_LT, OP_LABEL,
    OP_ARRAY_ACCESS, OP_ARRAY_ASSIGN
} OpType;

typedef struct TAC {
    int lineNum;
    OpType op;
    char* result;
    char* arg1;
    char* arg2;
    int isInvariant;   // Loop-invariant flag
    int isInduction;   // Induction variable flag
    struct TAC* next;
} TAC;

typedef struct Loop {
    int headerLine;    // Loop header (condition check)
    int startLine;     // First line of body
    int endLine;       // Last line of body (back edge)
    char* loopVar;     // Loop counter variable
    char** invariants; // Loop-invariant variables
    int invariantCount;
} Loop;

TAC* tacHead = NULL;
TAC* tacTail = NULL;
int lineCount = 0;

// ═══════════════════════════════════════════════════════════
// Helper Functions
// ═══════════════════════════════════════════════════════════

TAC* createTAC(OpType op, char* result, char* arg1, char* arg2) {
    TAC* t = malloc(sizeof(TAC));
    t->lineNum = lineCount++;
    t->op = op;
    t->result = result ? strdup(result) : NULL;
    t->arg1 = arg1 ? strdup(arg1) : NULL;
    t->arg2 = arg2 ? strdup(arg2) : NULL;
    t->isInvariant = 0;
    t->isInduction = 0;
    t->next = NULL;
    return t;
}

void addTAC(TAC* t) {
    if(tacTail == NULL) {
        tacHead = tacTail = t;
    } else {
        tacTail->next = t;
        tacTail = t;
    }
}

char* opToStr(OpType op) {
    switch(op) {
        case OP_ADD: return "+";
        case OP_SUB: return "-";
        case OP_MUL: return "*";
        case OP_DIV: return "/";
        case OP_COPY: return "=";
        case OP_GOTO: return "goto";
        case OP_IF_LT: return "if <";
        case OP_LABEL: return "label";
        case OP_ARRAY_ACCESS: return "[]";
        case OP_ARRAY_ASSIGN: return "[]=";
        default: return "?";
    }
}

// ═══════════════════════════════════════════════════════════
// Loop Analysis
// ═══════════════════════════════════════════════════════════

int isDefinedInLoop(char* var, int startLine, int endLine) {
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->lineNum >= startLine && t->lineNum <= endLine) {
            if(t->result != NULL && strcmp(t->result, var) == 0) {
                return 1;
            }
        }
    }
    return 0;
}

int isLoopInvariant(TAC* instr, int startLine, int endLine, char* loopVar) {
    // An instruction is loop-invariant if:
    // 1. Its operands are constants, OR
    // 2. Its operands are defined outside the loop, OR
    // 3. Its operands are loop-invariant
    
    if(instr->arg1 != NULL) {
        // Check if arg1 is loop variable
        if(strcmp(instr->arg1, loopVar) == 0) return 0;
        
        // Check if arg1 is defined in loop
        if(isDefinedInLoop(instr->arg1, startLine, endLine)) return 0;
    }
    
    if(instr->arg2 != NULL) {
        if(strcmp(instr->arg2, loopVar) == 0) return 0;
        if(isDefinedInLoop(instr->arg2, startLine, endLine)) return 0;
    }
    
    return 1;
}

void findLoopInvariants(Loop* loop) {
    printf("\n[Finding Loop Invariants]\n");
    printf("────────────────────────────────\n");
    printf("Loop: lines %d to %d, counter = %s\n", 
           loop->startLine, loop->endLine, loop->loopVar);
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->lineNum >= loop->startLine && t->lineNum <= loop->endLine) {
            if(t->op >= OP_ADD && t->op <= OP_DIV) {
                if(isLoopInvariant(t, loop->startLine, loop->endLine, loop->loopVar)) {
                    t->isInvariant = 1;
                    printf("  Line %d: %s = %s %s %s  [INVARIANT]\n",
                           t->lineNum, t->result, t->arg1, opToStr(t->op), t->arg2);
                }
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════
// Induction Variable Detection
// ═══════════════════════════════════════════════════════════

void findInductionVariables(Loop* loop) {
    printf("\n[Finding Induction Variables]\n");
    printf("────────────────────────────────\n");
    
    // Basic induction variable: loop counter
    printf("  Basic: %s (loop counter)\n", loop->loopVar);
    
    // Find derived induction variables: j = c * i + d
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->lineNum >= loop->startLine && t->lineNum <= loop->endLine) {
            if(t->op == OP_MUL) {
                // Check if one operand is loop variable
                if((t->arg1 && strcmp(t->arg1, loop->loopVar) == 0) ||
                   (t->arg2 && strcmp(t->arg2, loop->loopVar) == 0)) {
                    t->isInduction = 1;
                    printf("  Derived: %s = %s * %s\n",
                           t->result, t->arg1, t->arg2);
                }
            }
        }
    }
}

// ═══════════════════════════════════════════════════════════
// Strength Reduction
// ═══════════════════════════════════════════════════════════

void applyStrengthReduction(Loop* loop) {
    printf("\n[Applying Strength Reduction]\n");
    printf("────────────────────────────────\n");
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->isInduction) {
            // Replace: j = 4 * i  with  j = j + 4
            printf("  Before: %s = %s * %s\n", t->result, t->arg1, t->arg2);
            
            // Find the multiplier
            char* multiplier = NULL;
            if(strcmp(t->arg1, loop->loopVar) == 0) {
                multiplier = t->arg2;
            } else {
                multiplier = t->arg1;
            }
            
            printf("  After:  Initialize %s = 0 before loop\n", t->result);
            printf("          %s = %s + %s (inside loop)\n", 
                   t->result, t->result, multiplier);
            
            // Convert: MUL -> ADD
            t->op = OP_ADD;
            free(t->arg1);
            t->arg1 = strdup(t->result);
            free(t->arg2);
            t->arg2 = strdup(multiplier);
        }
    }
}

// ═══════════════════════════════════════════════════════════
// Code Motion
// ═══════════════════════════════════════════════════════════

void applyCodeMotion(Loop* loop) {
    printf("\n[Applying Code Motion]\n");
    printf("────────────────────────────────\n");
    
    printf("  Moving invariant code before loop:\n");
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->isInvariant) {
            printf("    %s = %s %s %s  →  move to line %d\n",
                   t->result, t->arg1, opToStr(t->op), t->arg2,
                   loop->startLine - 1);
        }
    }
}

// ═══════════════════════════════════════════════════════════
// Loop Unrolling
// ═══════════════════════════════════════════════════════════

void demonstrateUnrolling() {
    printf("\n[Loop Unrolling Example]\n");
    printf("────────────────────────────────\n");
    
    printf("\nOriginal:\n");
    printf("  for (i = 0; i < 8; i++) {\n");
    printf("      a[i] = b[i] + c[i];\n");
    printf("  }\n");
    
    printf("\nUnrolled (factor = 4):\n");
    printf("  for (i = 0; i < 8; i += 4) {\n");
    printf("      a[i]   = b[i]   + c[i];\n");
    printf("      a[i+1] = b[i+1] + c[i+1];\n");
    printf("      a[i+2] = b[i+2] + c[i+2];\n");
    printf("      a[i+3] = b[i+3] + c[i+3];\n");
    printf("  }\n");
    
    printf("\nBenefits:\n");
    printf("  • Loop overhead: 8 → 2 (75%% reduction)\n");
    printf("  • Better instruction pipelining\n");
    printf("  • Potential for SIMD optimization\n");
}

// ═══════════════════════════════════════════════════════════
// Print TAC
// ═══════════════════════════════════════════════════════════

void printTAC() {
    printf("\nThree-Address Code:\n");
    printf("═══════════════════════════════════════════════════════\n");
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        printf("%2d: ", t->lineNum);
        
        char flags[20] = "";
        if(t->isInvariant) strcat(flags, " [INV]");
        if(t->isInduction) strcat(flags, " [IND]");
        
        switch(t->op) {
            case OP_LABEL:
                printf("%s:%s\n", t->result, flags);
                break;
            case OP_GOTO:
                printf("goto %s%s\n", t->result, flags);
                break;
            case OP_IF_LT:
                printf("if %s < %s goto %s%s\n", 
                       t->arg1, t->arg2, t->result, flags);
                break;
            case OP_COPY:
                printf("%s = %s%s\n", t->result, t->arg1, flags);
                break;
            default:
                printf("%s = %s %s %s%s\n",
                       t->result, t->arg1, opToStr(t->op), t->arg2, flags);
        }
    }
}

// ═══════════════════════════════════════════════════════════
// Demo
// ═══════════════════════════════════════════════════════════

int main() {
    printf("╔═══════════════════════════════════════════════════════╗\n");
    printf("║           Loop Optimization Demo                      ║\n");
    printf("╚═══════════════════════════════════════════════════════╝\n");
    
    /*
     * Original loop:
     * for (i = 0; i < n; i++) {
     *     t = x * y;           // Loop invariant
     *     j = i * 4;           // Induction variable
     *     a[j] = t + i;
     * }
     */
    
    printf("\nOriginal Code:\n");
    printf("  for (i = 0; i < n; i++) {\n");
    printf("      t = x * y;        // Loop invariant\n");
    printf("      j = i * 4;        // Induction variable\n");
    printf("      a[j] = t + i;\n");
    printf("  }\n");
    
    // Build TAC
    addTAC(createTAC(OP_COPY, "i", "0", NULL));           // 0: i = 0
    addTAC(createTAC(OP_LABEL, "L1", NULL, NULL));        // 1: L1:
    addTAC(createTAC(OP_IF_LT, "L2", "i", "n"));          // 2: if i < n goto L2
    addTAC(createTAC(OP_GOTO, "L3", NULL, NULL));         // 3: goto L3
    addTAC(createTAC(OP_LABEL, "L2", NULL, NULL));        // 4: L2:
    addTAC(createTAC(OP_MUL, "t", "x", "y"));             // 5: t = x * y
    addTAC(createTAC(OP_MUL, "j", "i", "4"));             // 6: j = i * 4
    addTAC(createTAC(OP_ADD, "t1", "t", "i"));            // 7: t1 = t + i
    addTAC(createTAC(OP_ARRAY_ASSIGN, "a", "j", "t1"));   // 8: a[j] = t1
    addTAC(createTAC(OP_ADD, "i", "i", "1"));             // 9: i = i + 1
    addTAC(createTAC(OP_GOTO, "L1", NULL, NULL));         // 10: goto L1
    addTAC(createTAC(OP_LABEL, "L3", NULL, NULL));        // 11: L3:
    
    printTAC();
    
    // Define loop structure
    Loop loop = {
        .headerLine = 1,
        .startLine = 4,
        .endLine = 10,
        .loopVar = "i"
    };
    
    // Apply optimizations
    findLoopInvariants(&loop);
    findInductionVariables(&loop);
    applyStrengthReduction(&loop);
    applyCodeMotion(&loop);
    
    printTAC();
    
    printf("\n═══════════════════════════════════════════════════════\n");
    printf("Optimized Code:\n");
    printf("  t = x * y;            // Moved out of loop\n");
    printf("  j = 0;                // Initialize before loop\n");
    printf("  for (i = 0; i < n; i++) {\n");
    printf("      a[j] = t + i;\n");
    printf("      j = j + 4;        // Strength reduced\n");
    printf("  }\n");
    printf("═══════════════════════════════════════════════════════\n");
    
    demonstrateUnrolling();
    
    return 0;
}
```

## 📋 Loop Optimization Summary

| Technique | Before | After | Benefit |
|-----------|--------|-------|---------|
| Code Motion | `t = x*y` in loop | `t = x*y` outside | n-1 fewer ops |
| Strength Reduction | `j = i * 4` | `j = j + 4` | MUL → ADD |
| Induction Elimination | Multiple counters | Single counter | Fewer variables |
| Loop Unrolling | n iterations | n/k iterations | Less overhead |

---
**পরবর্তী অধ্যায়**: [কোড জেনারেশন](../০৯-কোড-জেনারেশন/০১-কোড-জেনারেশন-পরিচিতি.md)
