# âš¡ à¦•à§‹à¦¡ à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨ à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿

## à¦•à§‹à¦¡ à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨ à¦•à§€?

**Code Optimization** à¦¹à¦²à§‹ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à§‡à¦° functionality à¦…à¦ªà¦°à¦¿à¦¬à¦°à§à¦¤à¦¿à¦¤ à¦°à§‡à¦–à§‡ execution time à¦•à¦®à¦¾à¦¨à§‹ à¦à¦¬à¦‚ memory usage à¦‰à¦¨à§à¦¨à¦¤ à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Code Optimization                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   Source Code                                                   â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚   Front End                                                     â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚   â”‚    Intermediate Code          â”‚                             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚   â”‚    CODE OPTIMIZER             â”‚                             â”‚
â”‚   â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                             â”‚
â”‚   â”‚  â”‚ Machine-Independent     â”‚  â”‚                             â”‚
â”‚   â”‚  â”‚ â€¢ Constant Folding      â”‚  â”‚                             â”‚
â”‚   â”‚  â”‚ â€¢ Dead Code Elimination â”‚  â”‚                             â”‚
â”‚   â”‚  â”‚ â€¢ Loop Optimization     â”‚  â”‚                             â”‚
â”‚   â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                             â”‚
â”‚   â”‚    Optimized Code             â”‚                             â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                             â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚   Code Generator                                                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Optimization Categories

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Optimization Types                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. Machine-Independent (High-Level):                           â”‚
â”‚     â”œâ”€â”€ Constant Folding                                        â”‚
â”‚     â”œâ”€â”€ Constant Propagation                                    â”‚
â”‚     â”œâ”€â”€ Copy Propagation                                        â”‚
â”‚     â”œâ”€â”€ Dead Code Elimination                                   â”‚
â”‚     â”œâ”€â”€ Common Subexpression Elimination                        â”‚
â”‚     â””â”€â”€ Loop Optimizations                                      â”‚
â”‚                                                                 â”‚
â”‚  2. Machine-Dependent (Low-Level):                              â”‚
â”‚     â”œâ”€â”€ Register Allocation                                     â”‚
â”‚     â”œâ”€â”€ Instruction Scheduling                                  â”‚
â”‚     â”œâ”€â”€ Peephole Optimization                                   â”‚
â”‚     â””â”€â”€ Instruction Selection                                   â”‚
â”‚                                                                 â”‚
â”‚  3. Local vs Global:                                            â”‚
â”‚     â”œâ”€â”€ Local: Within a basic block                             â”‚
â”‚     â””â”€â”€ Global: Across basic blocks                             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”¢ Constant Folding

### à¦§à¦¾à¦°à¦£à¦¾:
Compile time-à¦ constant expressions evaluate à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Constant Folding                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before:                          After:                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€                          â”€â”€â”€â”€â”€â”€                        â”‚
â”‚  x = 3 + 5                        x = 8                         â”‚
â”‚  y = 2 * 3.14                     y = 6.28                      â”‚
â”‚  z = 100 / 4                      z = 25                        â”‚
â”‚  a = 2 * PI * r    (PI=3.14)     a = 6.28 * r                  â”‚
â”‚                                                                 â”‚
â”‚  n = 10                           n = 10                        â”‚
â”‚  size = n * 4                     size = 40                     â”‚
â”‚  arr = malloc(size)               arr = malloc(40)              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ Constant Propagation

### à¦§à¦¾à¦°à¦£à¦¾:
Variable-à¦à¦° constant value à¦ªà¦°à¦¬à¦°à§à¦¤à§€ uses-à¦ propagate à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Constant Propagation                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before:                          After:                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€                          â”€â”€â”€â”€â”€â”€                        â”‚
â”‚  x = 5                            x = 5                         â”‚
â”‚  y = x + 3                        y = 5 + 3  â†’  y = 8           â”‚
â”‚  z = x * 2                        z = 5 * 2  â†’  z = 10          â”‚
â”‚                                                                 â”‚
â”‚  pi = 3.14159                     pi = 3.14159                  â”‚
â”‚  area = pi * r * r                area = 3.14159 * r * r        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ Copy Propagation

### à¦§à¦¾à¦°à¦£à¦¾:
Copy statement-à¦à¦° à¦ªà¦° original variable à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Copy Propagation                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before:                          After:                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€                          â”€â”€â”€â”€â”€â”€                        â”‚
â”‚  x = a                            x = a                         â”‚
â”‚  y = x + b                        y = a + b     (x â†’ a)         â”‚
â”‚  z = x * c                        z = a * c     (x â†’ a)         â”‚
â”‚                                                                 â”‚
â”‚  t1 = b + c                       t1 = b + c                    â”‚
â”‚  t2 = t1                          t2 = t1                       â”‚
â”‚  a = t2 * d                       a = t1 * d    (t2 â†’ t1)       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—‘ï¸ Dead Code Elimination

### à¦§à¦¾à¦°à¦£à¦¾:
à¦¯à§‡ code execute à¦¹à¦¯à¦¼ à¦¨à¦¾ à¦¬à¦¾ result à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦¹à¦¯à¦¼ à¦¨à¦¾, à¦¤à¦¾ remove à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Dead Code Elimination                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Type 1: Unreachable Code                                       â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                       â”‚
â”‚  if (false) {                     (entire block removed)        â”‚
â”‚      x = 10;      â†â”€â”€ Dead                                      â”‚
â”‚      y = 20;      â†â”€â”€ Dead                                      â”‚
â”‚  }                                                              â”‚
â”‚                                                                 â”‚
â”‚  return x;                        return x;                     â”‚
â”‚  y = 10;          â†â”€â”€ Dead        (removed)                     â”‚
â”‚  z = 20;          â†â”€â”€ Dead        (removed)                     â”‚
â”‚                                                                 â”‚
â”‚  Type 2: Useless Code (unused result)                           â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                           â”‚
â”‚  x = a + b;       â†â”€â”€ Dead (x never used)                       â”‚
â”‚  y = c * d;                       y = c * d;                    â”‚
â”‚  return y;                        return y;                     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ” Common Subexpression Elimination (CSE)

### à¦§à¦¾à¦°à¦£à¦¾:
à¦à¦•à¦‡ expression à¦¬à¦¾à¦°à¦¬à¦¾à¦° compute à¦¨à¦¾ à¦•à¦°à§‡ result reuse à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Common Subexpression Elimination                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before:                          After:                        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€                          â”€â”€â”€â”€â”€â”€                        â”‚
â”‚  a = b + c                        t1 = b + c                    â”‚
â”‚  d = b + c                        a = t1                        â”‚
â”‚                                   d = t1                        â”‚
â”‚                                                                 â”‚
â”‚  x = a * b + c                    t1 = a * b                    â”‚
â”‚  y = a * b - d                    x = t1 + c                    â”‚
â”‚  z = a * b * e                    y = t1 - d                    â”‚
â”‚                                   z = t1 * e                    â”‚
â”‚                                                                 â”‚
â”‚  Array access:                                                  â”‚
â”‚  a[i] = a[i] + 1                  t1 = &a[i]                    â”‚
â”‚                                   *t1 = *t1 + 1                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Optimizer Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAC Instruction Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    OP_ADD, OP_SUB, OP_MUL, OP_DIV,
    OP_COPY, OP_GOTO, OP_IF, OP_LABEL,
    OP_RETURN, OP_NOP
} OpType;

typedef struct TAC {
    OpType op;
    char* result;
    char* arg1;
    char* arg2;
    int isDead;      // For dead code elimination
    struct TAC* next;
} TAC;

TAC* tacHead = NULL;
TAC* tacTail = NULL;

// Symbol table for constant propagation
typedef struct Symbol {
    char* name;
    int isConstant;
    int value;
    struct Symbol* next;
} Symbol;

Symbol* symTable = NULL;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Helper Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

TAC* createTAC(OpType op, char* result, char* arg1, char* arg2) {
    TAC* t = malloc(sizeof(TAC));
    t->op = op;
    t->result = result ? strdup(result) : NULL;
    t->arg1 = arg1 ? strdup(arg1) : NULL;
    t->arg2 = arg2 ? strdup(arg2) : NULL;
    t->isDead = 0;
    t->next = NULL;
    return t;
}

void addTAC(TAC* t) {
    if(tacTail == NULL) {
        tacHead = tacTail = t;
    } else {
        tacTail->next = t;
        tacTail = t;
    }
}

Symbol* lookupSymbol(char* name) {
    for(Symbol* s = symTable; s != NULL; s = s->next) {
        if(strcmp(s->name, name) == 0) return s;
    }
    return NULL;
}

void setConstant(char* name, int value) {
    Symbol* s = lookupSymbol(name);
    if(s == NULL) {
        s = malloc(sizeof(Symbol));
        s->name = strdup(name);
        s->next = symTable;
        symTable = s;
    }
    s->isConstant = 1;
    s->value = value;
}

void clearConstant(char* name) {
    Symbol* s = lookupSymbol(name);
    if(s != NULL) {
        s->isConstant = 0;
    }
}

int isNumber(char* str) {
    if(str == NULL) return 0;
    for(int i = 0; str[i]; i++) {
        if(!isdigit(str[i]) && str[i] != '-') return 0;
    }
    return 1;
}

char* opToStr(OpType op) {
    switch(op) {
        case OP_ADD: return "+";
        case OP_SUB: return "-";
        case OP_MUL: return "*";
        case OP_DIV: return "/";
        case OP_COPY: return "=";
        case OP_GOTO: return "goto";
        case OP_IF: return "if";
        case OP_LABEL: return "label";
        case OP_RETURN: return "return";
        case OP_NOP: return "nop";
        default: return "?";
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Constant Folding
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void constantFolding() {
    printf("\n[Constant Folding]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->op >= OP_ADD && t->op <= OP_DIV) {
            if(isNumber(t->arg1) && isNumber(t->arg2)) {
                int v1 = atoi(t->arg1);
                int v2 = atoi(t->arg2);
                int result;
                
                switch(t->op) {
                    case OP_ADD: result = v1 + v2; break;
                    case OP_SUB: result = v1 - v2; break;
                    case OP_MUL: result = v1 * v2; break;
                    case OP_DIV: result = v1 / v2; break;
                    default: continue;
                }
                
                printf("  Folded: %s = %s %s %s  â†’  %s = %d\n",
                       t->result, t->arg1, opToStr(t->op), t->arg2,
                       t->result, result);
                
                char* newVal = malloc(20);
                sprintf(newVal, "%d", result);
                free(t->arg1);
                free(t->arg2);
                t->arg1 = newVal;
                t->arg2 = NULL;
                t->op = OP_COPY;
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Constant Propagation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void constantPropagation() {
    printf("\n[Constant Propagation]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    // Clear symbol table
    symTable = NULL;
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        // Check if assignment of constant
        if(t->op == OP_COPY && isNumber(t->arg1)) {
            setConstant(t->result, atoi(t->arg1));
            printf("  Found constant: %s = %s\n", t->result, t->arg1);
        }
        
        // Propagate constants in operands
        if(t->arg1 != NULL && !isNumber(t->arg1)) {
            Symbol* s = lookupSymbol(t->arg1);
            if(s != NULL && s->isConstant) {
                printf("  Propagated: %s â†’ %d\n", t->arg1, s->value);
                char* newVal = malloc(20);
                sprintf(newVal, "%d", s->value);
                free(t->arg1);
                t->arg1 = newVal;
            }
        }
        
        if(t->arg2 != NULL && !isNumber(t->arg2)) {
            Symbol* s = lookupSymbol(t->arg2);
            if(s != NULL && s->isConstant) {
                printf("  Propagated: %s â†’ %d\n", t->arg2, s->value);
                char* newVal = malloc(20);
                sprintf(newVal, "%d", s->value);
                free(t->arg2);
                t->arg2 = newVal;
            }
        }
        
        // If result is assigned from non-constant, clear its constant status
        if(t->op >= OP_ADD && t->op <= OP_DIV) {
            clearConstant(t->result);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Dead Code Elimination
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void deadCodeElimination() {
    printf("\n[Dead Code Elimination]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    // Mark all variables as potentially dead
    // Then mark as live if used
    
    // Simple approach: check if result is ever used
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->result != NULL && t->op != OP_LABEL) {
            int isUsed = 0;
            
            // Check if result is used in any subsequent instruction
            for(TAC* check = t->next; check != NULL; check = check->next) {
                if((check->arg1 != NULL && strcmp(check->arg1, t->result) == 0) ||
                   (check->arg2 != NULL && strcmp(check->arg2, t->result) == 0)) {
                    isUsed = 1;
                    break;
                }
            }
            
            // Keep if it's a global/output variable (simple heuristic: not temp)
            if(t->result[0] != 't') {
                isUsed = 1;
            }
            
            if(!isUsed) {
                printf("  Dead code: %s = ... (result never used)\n", t->result);
                t->isDead = 1;
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Common Subexpression Elimination
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct {
    OpType op;
    char* arg1;
    char* arg2;
    char* result;
} Expression;

Expression expressions[100];
int exprCount = 0;

char* findCSE(OpType op, char* arg1, char* arg2) {
    for(int i = 0; i < exprCount; i++) {
        if(expressions[i].op == op &&
           strcmp(expressions[i].arg1, arg1) == 0 &&
           strcmp(expressions[i].arg2, arg2) == 0) {
            return expressions[i].result;
        }
        // Check commutative operations
        if((op == OP_ADD || op == OP_MUL) &&
           expressions[i].op == op &&
           strcmp(expressions[i].arg1, arg2) == 0 &&
           strcmp(expressions[i].arg2, arg1) == 0) {
            return expressions[i].result;
        }
    }
    return NULL;
}

void addExpression(OpType op, char* arg1, char* arg2, char* result) {
    expressions[exprCount].op = op;
    expressions[exprCount].arg1 = strdup(arg1);
    expressions[exprCount].arg2 = strdup(arg2);
    expressions[exprCount].result = strdup(result);
    exprCount++;
}

void commonSubexprElim() {
    printf("\n[Common Subexpression Elimination]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    exprCount = 0;
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->op >= OP_ADD && t->op <= OP_DIV && t->arg1 && t->arg2) {
            char* existing = findCSE(t->op, t->arg1, t->arg2);
            
            if(existing != NULL) {
                printf("  CSE found: %s = %s %s %s  â†’  %s = %s\n",
                       t->result, t->arg1, opToStr(t->op), t->arg2,
                       t->result, existing);
                
                free(t->arg1);
                free(t->arg2);
                t->arg1 = strdup(existing);
                t->arg2 = NULL;
                t->op = OP_COPY;
            } else {
                addExpression(t->op, t->arg1, t->arg2, t->result);
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Print TAC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void printTAC(char* title) {
    printf("\n%s\n", title);
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    int line = 0;
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        if(t->isDead) {
            printf("%2d: [DEAD] ", line++);
        } else {
            printf("%2d: ", line++);
        }
        
        switch(t->op) {
            case OP_ADD:
            case OP_SUB:
            case OP_MUL:
            case OP_DIV:
                printf("%s = %s %s %s\n", 
                       t->result, t->arg1, opToStr(t->op), t->arg2);
                break;
            case OP_COPY:
                printf("%s = %s\n", t->result, t->arg1);
                break;
            case OP_NOP:
                printf("nop\n");
                break;
            default:
                printf("?\n");
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘          Code Optimization Demo                       â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    // Create sample TAC:
    // Original:
    //   t1 = 3 + 5
    //   x = t1
    //   t2 = a + b
    //   t3 = a + b
    //   y = t2 * t3
    //   t4 = 10 * 2
    //   unused = t4
    
    addTAC(createTAC(OP_ADD, "t1", "3", "5"));
    addTAC(createTAC(OP_COPY, "x", "t1", NULL));
    addTAC(createTAC(OP_ADD, "t2", "a", "b"));
    addTAC(createTAC(OP_ADD, "t3", "a", "b"));
    addTAC(createTAC(OP_MUL, "y", "t2", "t3"));
    addTAC(createTAC(OP_MUL, "t4", "10", "2"));
    addTAC(createTAC(OP_COPY, "unused", "t4", NULL));
    
    printTAC("Original Code:");
    
    // Apply optimizations
    constantFolding();
    printTAC("After Constant Folding:");
    
    constantPropagation();
    constantFolding();  // Run again after propagation
    printTAC("After Constant Propagation:");
    
    commonSubexprElim();
    printTAC("After CSE:");
    
    deadCodeElimination();
    printTAC("After Dead Code Elimination:");
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("Optimization Complete!\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
```

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦²à§à¦ª à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨](à§¦à§¨-à¦²à§à¦ª-à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨.md)
