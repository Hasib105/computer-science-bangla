# ğŸ“ à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à§‡à¦Ÿ à¦•à§‹à¦¡ à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿

## à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à§‡à¦Ÿ à¦•à§‹à¦¡ à¦•à§€?

**Intermediate Code** à¦¹à¦²à§‹ Source Code à¦à¦¬à¦‚ Target Code-à¦à¦° à¦®à¦¾à¦à¦¾à¦®à¦¾à¦à¦¿ à¦à¦•à¦Ÿà¦¿ representation à¦¯à¦¾ machine-independent à¦à¦¬à¦‚ optimization-à¦à¦° à¦œà¦¨à§à¦¯ à¦¸à¦¹à¦¾à¦¯à¦¼à¦•à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Intermediate Code Generation                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   Source Code                                                   â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚  Front End          â”‚                                        â”‚
â”‚  â”‚  (Lexical, Syntax,  â”‚                                        â”‚
â”‚  â”‚   Semantic)         â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚ INTERMEDIATE CODE   â”‚ â†â”€â”€ Machine Independent                â”‚
â”‚  â”‚ (Three-Address Code,â”‚                                        â”‚
â”‚  â”‚  DAG, Quadruples)   â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚  Back End           â”‚                                        â”‚
â”‚  â”‚  (Optimization,     â”‚                                        â”‚
â”‚  â”‚   Code Generation)  â”‚                                        â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                        â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚   Target Code                                                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ à¦•à§‡à¦¨ Intermediate Code?

### à¦¸à§à¦¬à¦¿à¦§à¦¾à¦¸à¦®à§‚à¦¹:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Benefits of IR                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. Portability:                                                â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”                                                   â”‚
â”‚     â”‚Source â”‚â”€â”€â”€â”€â”                                              â”‚
â”‚     â”‚  1    â”‚    â”‚    â”Œâ”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”˜    â”œâ”€â”€â”€â†’â”‚ IR â”‚â”€â”€â”€â†’â”‚Target 1 â”‚                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”‚    â””â”€â”€â”€â”€â”˜    â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”‚
â”‚     â”‚Source â”‚â”€â”€â”€â”€â”¤      â†“       â”‚Target 2 â”‚                     â”‚
â”‚     â”‚  2    â”‚    â”‚              â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                     â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚              â”‚Target 3 â”‚                     â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”€â”€â”    â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚     â”‚Source â”‚â”€â”€â”€â”€â”˜                                              â”‚
â”‚     â”‚  3    â”‚              n sources, m targets                 â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”˜              Only n+m compilers needed            â”‚
â”‚                            (not nÃ—m)                            â”‚
â”‚                                                                 â”‚
â”‚  2. Optimization:                                               â”‚
â”‚     â€¢ Machine-independent optimizations                         â”‚
â”‚     â€¢ Easier analysis                                           â”‚
â”‚     â€¢ Multiple optimization passes                              â”‚
â”‚                                                                 â”‚
â”‚  3. Retargeting:                                                â”‚
â”‚     â€¢ Change backend for new architecture                       â”‚
â”‚     â€¢ Reuse frontend                                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š IR Types

### 1. High-Level IR (HIR)
```
AST-like structure
Close to source language
Example: GIMPLE (GCC)
```

### 2. Medium-Level IR (MIR)
```
Three-Address Code
Independent of source & target
Example: LLVM IR
```

### 3. Low-Level IR (LIR)
```
Close to target machine
Register-based
Example: RTL (GCC)
```

## ğŸ”¢ Three-Address Code (TAC)

### Format:
```
x = y op z

Where:
- x, y, z are names, constants, or temporaries
- op is an operator
- At most three addresses per instruction
```

### TAC Instruction Types:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Three-Address Instruction Types                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Assignment:                                                    â”‚
â”‚    x = y op z     Binary operation                              â”‚
â”‚    x = op y       Unary operation                               â”‚
â”‚    x = y          Copy                                          â”‚
â”‚                                                                 â”‚
â”‚  Indexed:                                                       â”‚
â”‚    x = y[i]       Array access                                  â”‚
â”‚    x[i] = y       Array assignment                              â”‚
â”‚                                                                 â”‚
â”‚  Pointer:                                                       â”‚
â”‚    x = &y         Address of                                    â”‚
â”‚    x = *y         Dereference                                   â”‚
â”‚    *x = y         Indirect assignment                           â”‚
â”‚                                                                 â”‚
â”‚  Control Flow:                                                  â”‚
â”‚    goto L         Unconditional jump                            â”‚
â”‚    if x goto L    Conditional jump                              â”‚
â”‚    if x relop y goto L                                          â”‚
â”‚                                                                 â”‚
â”‚  Function:                                                      â”‚
â”‚    param x        Parameter                                     â”‚
â”‚    call p, n      Call procedure p with n args                  â”‚
â”‚    return y       Return value                                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£:

```
Source Code:
    a = b * c + b * d

Three-Address Code:
    t1 = b * c
    t2 = b * d  
    t3 = t1 + t2
    a = t3

Source Code:
    if (a < b) {
        x = a + 1;
    } else {
        x = b - 1;
    }

Three-Address Code:
    if a < b goto L1
    goto L2
L1: t1 = a + 1
    x = t1
    goto L3
L2: t2 = b - 1
    x = t2
L3: ...
```

## ğŸ’» TAC Generator Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Three-Address Code Structures
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    TAC_ADD, TAC_SUB, TAC_MUL, TAC_DIV,
    TAC_COPY, TAC_GOTO, TAC_IF_GOTO, TAC_IF_FALSE_GOTO,
    TAC_LABEL, TAC_PARAM, TAC_CALL, TAC_RETURN,
    TAC_LT, TAC_GT, TAC_LE, TAC_GE, TAC_EQ, TAC_NE
} TACOp;

typedef struct TAC {
    TACOp op;
    char* result;
    char* arg1;
    char* arg2;
    struct TAC* next;
} TAC;

TAC* tacHead = NULL;
TAC* tacTail = NULL;
int tempCount = 0;
int labelCount = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Helper Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

char* newTemp() {
    char* temp = malloc(10);
    sprintf(temp, "t%d", tempCount++);
    return temp;
}

char* newLabel() {
    char* label = malloc(10);
    sprintf(label, "L%d", labelCount++);
    return label;
}

void emit(TACOp op, char* result, char* arg1, char* arg2) {
    TAC* instr = malloc(sizeof(TAC));
    instr->op = op;
    instr->result = result ? strdup(result) : NULL;
    instr->arg1 = arg1 ? strdup(arg1) : NULL;
    instr->arg2 = arg2 ? strdup(arg2) : NULL;
    instr->next = NULL;
    
    if(tacTail == NULL) {
        tacHead = tacTail = instr;
    } else {
        tacTail->next = instr;
        tacTail = instr;
    }
}

char* opToString(TACOp op) {
    switch(op) {
        case TAC_ADD: return "+";
        case TAC_SUB: return "-";
        case TAC_MUL: return "*";
        case TAC_DIV: return "/";
        case TAC_LT: return "<";
        case TAC_GT: return ">";
        case TAC_LE: return "<=";
        case TAC_GE: return ">=";
        case TAC_EQ: return "==";
        case TAC_NE: return "!=";
        default: return "?";
    }
}

void printTAC() {
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("         Three-Address Code\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    int line = 0;
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        printf("%3d: ", line++);
        
        switch(t->op) {
            case TAC_ADD:
            case TAC_SUB:
            case TAC_MUL:
            case TAC_DIV:
            case TAC_LT:
            case TAC_GT:
            case TAC_LE:
            case TAC_GE:
            case TAC_EQ:
            case TAC_NE:
                printf("%s = %s %s %s\n", 
                       t->result, t->arg1, opToString(t->op), t->arg2);
                break;
                
            case TAC_COPY:
                printf("%s = %s\n", t->result, t->arg1);
                break;
                
            case TAC_GOTO:
                printf("goto %s\n", t->result);
                break;
                
            case TAC_IF_GOTO:
                printf("if %s goto %s\n", t->arg1, t->result);
                break;
                
            case TAC_IF_FALSE_GOTO:
                printf("ifFalse %s goto %s\n", t->arg1, t->result);
                break;
                
            case TAC_LABEL:
                printf("%s:\n", t->result);
                break;
                
            case TAC_PARAM:
                printf("param %s\n", t->arg1);
                break;
                
            case TAC_CALL:
                printf("%s = call %s, %s\n", t->result, t->arg1, t->arg2);
                break;
                
            case TAC_RETURN:
                printf("return %s\n", t->arg1);
                break;
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AST Node for Code Generation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    NODE_NUM, NODE_ID, NODE_BINOP, NODE_ASSIGN,
    NODE_IF, NODE_WHILE, NODE_CALL, NODE_STMTS
} NodeType;

typedef struct ASTNode {
    NodeType type;
    char* name;              // For ID
    int value;               // For NUM
    char op;                 // For BINOP
    struct ASTNode* left;
    struct ASTNode* right;
    struct ASTNode* cond;    // For IF, WHILE
    struct ASTNode* thenPart;
    struct ASTNode* elsePart;
    struct ASTNode* next;    // For statement list
} ASTNode;

ASTNode* makeNum(int value) {
    ASTNode* n = malloc(sizeof(ASTNode));
    n->type = NODE_NUM;
    n->value = value;
    n->left = n->right = n->next = NULL;
    return n;
}

ASTNode* makeId(char* name) {
    ASTNode* n = malloc(sizeof(ASTNode));
    n->type = NODE_ID;
    n->name = strdup(name);
    n->left = n->right = n->next = NULL;
    return n;
}

ASTNode* makeBinOp(char op, ASTNode* left, ASTNode* right) {
    ASTNode* n = malloc(sizeof(ASTNode));
    n->type = NODE_BINOP;
    n->op = op;
    n->left = left;
    n->right = right;
    n->next = NULL;
    return n;
}

ASTNode* makeAssign(char* name, ASTNode* expr) {
    ASTNode* n = malloc(sizeof(ASTNode));
    n->type = NODE_ASSIGN;
    n->name = strdup(name);
    n->right = expr;
    n->left = n->next = NULL;
    return n;
}

ASTNode* makeIf(ASTNode* cond, ASTNode* thenPart, ASTNode* elsePart) {
    ASTNode* n = malloc(sizeof(ASTNode));
    n->type = NODE_IF;
    n->cond = cond;
    n->thenPart = thenPart;
    n->elsePart = elsePart;
    n->left = n->right = n->next = NULL;
    return n;
}

ASTNode* makeWhile(ASTNode* cond, ASTNode* body) {
    ASTNode* n = malloc(sizeof(ASTNode));
    n->type = NODE_WHILE;
    n->cond = cond;
    n->thenPart = body;  // Reuse thenPart for body
    n->left = n->right = n->next = NULL;
    return n;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Code Generation from AST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

char* generateExpr(ASTNode* node) {
    if(node == NULL) return NULL;
    
    switch(node->type) {
        case NODE_NUM: {
            char* temp = newTemp();
            char* val = malloc(20);
            sprintf(val, "%d", node->value);
            emit(TAC_COPY, temp, val, NULL);
            free(val);
            return temp;
        }
        
        case NODE_ID: {
            return strdup(node->name);
        }
        
        case NODE_BINOP: {
            char* left = generateExpr(node->left);
            char* right = generateExpr(node->right);
            char* temp = newTemp();
            
            TACOp op;
            switch(node->op) {
                case '+': op = TAC_ADD; break;
                case '-': op = TAC_SUB; break;
                case '*': op = TAC_MUL; break;
                case '/': op = TAC_DIV; break;
                case '<': op = TAC_LT; break;
                case '>': op = TAC_GT; break;
                default: op = TAC_ADD;
            }
            
            emit(op, temp, left, right);
            return temp;
        }
        
        default:
            return NULL;
    }
}

void generateStmt(ASTNode* node) {
    if(node == NULL) return;
    
    switch(node->type) {
        case NODE_ASSIGN: {
            char* expr = generateExpr(node->right);
            emit(TAC_COPY, node->name, expr, NULL);
            break;
        }
        
        case NODE_IF: {
            char* cond = generateExpr(node->cond);
            char* labelElse = newLabel();
            char* labelEnd = newLabel();
            
            emit(TAC_IF_FALSE_GOTO, labelElse, cond, NULL);
            
            // Then part
            generateStmt(node->thenPart);
            emit(TAC_GOTO, labelEnd, NULL, NULL);
            
            // Else part
            emit(TAC_LABEL, labelElse, NULL, NULL);
            if(node->elsePart != NULL) {
                generateStmt(node->elsePart);
            }
            
            emit(TAC_LABEL, labelEnd, NULL, NULL);
            break;
        }
        
        case NODE_WHILE: {
            char* labelStart = newLabel();
            char* labelEnd = newLabel();
            
            emit(TAC_LABEL, labelStart, NULL, NULL);
            
            char* cond = generateExpr(node->cond);
            emit(TAC_IF_FALSE_GOTO, labelEnd, cond, NULL);
            
            // Body
            generateStmt(node->thenPart);
            emit(TAC_GOTO, labelStart, NULL, NULL);
            
            emit(TAC_LABEL, labelEnd, NULL, NULL);
            break;
        }
        
        case NODE_STMTS: {
            // Statement list
            for(ASTNode* s = node; s != NULL; s = s->next) {
                generateStmt(s);
            }
            break;
        }
        
        default:
            break;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘     Intermediate Code Generation Demo                 â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    // Example 1: a = b * c + b * d
    printf("\nExample 1: a = b * c + b * d\n");
    
    ASTNode* expr1 = makeBinOp('+',
        makeBinOp('*', makeId("b"), makeId("c")),
        makeBinOp('*', makeId("b"), makeId("d"))
    );
    ASTNode* assign1 = makeAssign("a", expr1);
    generateStmt(assign1);
    
    // Example 2: if (a < b) x = a + 1 else x = b - 1
    printf("\nExample 2: if (a < b) x = a + 1 else x = b - 1\n");
    
    ASTNode* cond = makeBinOp('<', makeId("a"), makeId("b"));
    ASTNode* thenPart = makeAssign("x", 
        makeBinOp('+', makeId("a"), makeNum(1)));
    ASTNode* elsePart = makeAssign("x", 
        makeBinOp('-', makeId("b"), makeNum(1)));
    ASTNode* ifStmt = makeIf(cond, thenPart, elsePart);
    generateStmt(ifStmt);
    
    // Example 3: while (i < n) { sum = sum + i; i = i + 1; }
    printf("\nExample 3: while (i < n) { sum = sum + i; i = i + 1; }\n");
    
    ASTNode* whileCond = makeBinOp('<', makeId("i"), makeId("n"));
    ASTNode* stmt1 = makeAssign("sum",
        makeBinOp('+', makeId("sum"), makeId("i")));
    ASTNode* stmt2 = makeAssign("i",
        makeBinOp('+', makeId("i"), makeNum(1)));
    stmt1->next = stmt2;
    ASTNode* whileStmt = makeWhile(whileCond, stmt1);
    generateStmt(whileStmt);
    
    printTAC();
    
    return 0;
}
```

## ğŸ“‹ TAC Summary

| Representation | Description | Example |
|----------------|-------------|---------|
| Quadruple | (op, arg1, arg2, result) | (+, b, c, t1) |
| Triple | (op, arg1, arg2) with index | (0) (+, b, c) |
| Indirect Triple | Pointer to triple | List of indices |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [DAG à¦à¦¬à¦‚ à¦•à§‹à¦¡ à¦œà§‡à¦¨à¦¾à¦°à§‡à¦¶à¦¨](à§¦à§¨-à¦¡à§à¦¯à¦¾à¦—-à¦à¦¬à¦‚-à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨.md)
