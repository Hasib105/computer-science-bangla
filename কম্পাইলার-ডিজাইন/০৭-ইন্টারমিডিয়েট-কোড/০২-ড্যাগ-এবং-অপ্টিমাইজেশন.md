# ğŸŒ³ DAG à¦à¦¬à¦‚ à¦•à§‹à¦¯à¦¼à¦¾à¦¡à§à¦°à¦¾à¦ªà¦²

## DAG (Directed Acyclic Graph) à¦•à§€?

**DAG** à¦¹à¦²à§‹ expressions-à¦à¦° à¦à¦•à¦Ÿà¦¿ optimized representation à¦¯à§‡à¦–à¦¾à¦¨à§‡ common subexpressions à¦¶à§‡à¦¯à¦¼à¦¾à¦° à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Expression: a + a * (b - c) + (b - c) * d      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Parse Tree (Redundant):          DAG (Optimized):             â”‚
â”‚                                                                 â”‚
â”‚           +                              +                      â”‚
â”‚          / \                            / \                     â”‚
â”‚         +   *                          +   *                    â”‚
â”‚        / \ / \                        / \ / \                   â”‚
â”‚       a  * b-c d                     a  *   d                   â”‚
â”‚         / \                            / \                      â”‚
â”‚        a  b-c                         a  b-c â†â”€â”€ Shared!       â”‚
â”‚          / \                            / \                     â”‚
â”‚         b   c                          b   c                    â”‚
â”‚                                                                 â”‚
â”‚  b-c computed twice              b-c computed once              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ DAG Construction Algorithm

```
Algorithm: Build DAG for expression

Input: Expression tree node
Output: DAG node

function buildDAG(node):
    if node is a leaf:
        if node already exists in DAG:
            return existing node
        else:
            create new leaf node
            return new node
    
    else (node is an operator):
        leftDAG = buildDAG(node.left)
        rightDAG = buildDAG(node.right)
        
        // Check if this operation already exists
        if (node.op, leftDAG, rightDAG) exists in DAG:
            return existing node
        else:
            create new internal node
            return new node
```

## ğŸ’» DAG Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAG Node Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    DAG_LEAF,      // Variable or constant
    DAG_OP         // Operator
} DAGNodeType;

typedef struct DAGNode {
    int id;
    DAGNodeType type;
    char* value;           // For leaves: variable name or constant
    char op;               // For operators: +, -, *, /
    struct DAGNode* left;
    struct DAGNode* right;
    char** labels;         // Variables that have this value
    int labelCount;
} DAGNode;

// DAG node storage
#define MAX_DAG_NODES 100
DAGNode* dagNodes[MAX_DAG_NODES];
int dagNodeCount = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAG Helper Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

DAGNode* createLeafNode(char* value) {
    DAGNode* node = malloc(sizeof(DAGNode));
    node->id = dagNodeCount;
    node->type = DAG_LEAF;
    node->value = strdup(value);
    node->op = '\0';
    node->left = node->right = NULL;
    node->labels = malloc(10 * sizeof(char*));
    node->labelCount = 0;
    
    dagNodes[dagNodeCount++] = node;
    return node;
}

DAGNode* createOpNode(char op, DAGNode* left, DAGNode* right) {
    DAGNode* node = malloc(sizeof(DAGNode));
    node->id = dagNodeCount;
    node->type = DAG_OP;
    node->value = NULL;
    node->op = op;
    node->left = left;
    node->right = right;
    node->labels = malloc(10 * sizeof(char*));
    node->labelCount = 0;
    
    dagNodes[dagNodeCount++] = node;
    return node;
}

void addLabel(DAGNode* node, char* label) {
    node->labels[node->labelCount++] = strdup(label);
}

// Find existing leaf node
DAGNode* findLeaf(char* value) {
    for(int i = 0; i < dagNodeCount; i++) {
        if(dagNodes[i]->type == DAG_LEAF && 
           strcmp(dagNodes[i]->value, value) == 0) {
            return dagNodes[i];
        }
    }
    return NULL;
}

// Find existing operation node
DAGNode* findOp(char op, DAGNode* left, DAGNode* right) {
    for(int i = 0; i < dagNodeCount; i++) {
        if(dagNodes[i]->type == DAG_OP &&
           dagNodes[i]->op == op &&
           dagNodes[i]->left == left &&
           dagNodes[i]->right == right) {
            return dagNodes[i];
        }
    }
    return NULL;
}

// Get or create leaf node
DAGNode* getLeafNode(char* value) {
    DAGNode* existing = findLeaf(value);
    if(existing != NULL) {
        printf("  Reusing leaf node for '%s' (id=%d)\n", value, existing->id);
        return existing;
    }
    
    DAGNode* newNode = createLeafNode(value);
    printf("  Created leaf node for '%s' (id=%d)\n", value, newNode->id);
    return newNode;
}

// Get or create operation node
DAGNode* getOpNode(char op, DAGNode* left, DAGNode* right) {
    DAGNode* existing = findOp(op, left, right);
    if(existing != NULL) {
        printf("  Reusing op node '%c' (id=%d)\n", op, existing->id);
        return existing;
    }
    
    DAGNode* newNode = createOpNode(op, left, right);
    printf("  Created op node '%c' (id=%d)\n", op, newNode->id);
    return newNode;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Expression Parsing and DAG Building
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

char* input;
int pos = 0;

char peek() { return input[pos]; }
char get() { return input[pos++]; }
void skipWhite() { while(input[pos] == ' ') pos++; }

// Forward declarations
DAGNode* parseE();
DAGNode* parseT();
DAGNode* parseF();

// E â†’ E + T | E - T | T
DAGNode* parseE() {
    DAGNode* left = parseT();
    skipWhite();
    
    while(peek() == '+' || peek() == '-') {
        char op = get();
        skipWhite();
        DAGNode* right = parseT();
        left = getOpNode(op, left, right);
        skipWhite();
    }
    
    return left;
}

// T â†’ T * F | T / F | F
DAGNode* parseT() {
    DAGNode* left = parseF();
    skipWhite();
    
    while(peek() == '*' || peek() == '/') {
        char op = get();
        skipWhite();
        DAGNode* right = parseF();
        left = getOpNode(op, left, right);
        skipWhite();
    }
    
    return left;
}

// F â†’ ( E ) | id | num
DAGNode* parseF() {
    skipWhite();
    
    if(peek() == '(') {
        get();  // consume '('
        DAGNode* node = parseE();
        get();  // consume ')'
        return node;
    }
    
    // Identifier or number
    char buffer[50];
    int i = 0;
    while(isalnum(peek())) {
        buffer[i++] = get();
    }
    buffer[i] = '\0';
    
    return getLeafNode(buffer);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// DAG Printing
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void printDAGNode(DAGNode* node, int indent) {
    for(int i = 0; i < indent; i++) printf("  ");
    
    if(node->type == DAG_LEAF) {
        printf("Node %d: LEAF '%s'", node->id, node->value);
    } else {
        printf("Node %d: OP '%c' (left=%d, right=%d)",
               node->id, node->op, node->left->id, node->right->id);
    }
    
    if(node->labelCount > 0) {
        printf(" [labels: ");
        for(int i = 0; i < node->labelCount; i++) {
            printf("%s", node->labels[i]);
            if(i < node->labelCount - 1) printf(", ");
        }
        printf("]");
    }
    
    printf("\n");
}

void printDAG() {
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                    DAG Structure\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    for(int i = 0; i < dagNodeCount; i++) {
        printDAGNode(dagNodes[i], 0);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Generate Code from DAG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int tempCount = 0;
char* generated[MAX_DAG_NODES];  // Store generated temp names

char* generateCode(DAGNode* node) {
    // Check if already generated
    if(generated[node->id] != NULL) {
        return generated[node->id];
    }
    
    if(node->type == DAG_LEAF) {
        generated[node->id] = node->value;
        return node->value;
    }
    
    char* left = generateCode(node->left);
    char* right = generateCode(node->right);
    
    char* temp = malloc(10);
    sprintf(temp, "t%d", tempCount++);
    
    printf("  %s = %s %c %s\n", temp, left, node->op, right);
    
    generated[node->id] = temp;
    
    // Generate assignments for labels
    for(int i = 0; i < node->labelCount; i++) {
        printf("  %s = %s\n", node->labels[i], temp);
    }
    
    return temp;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘           DAG Construction Demo                       â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Example: a + a * (b - c) + (b - c) * d
    // This has common subexpression: (b - c)
    
    input = "a + a * (b - c) + (b - c) * d";
    pos = 0;
    
    printf("Expression: %s\n\n", input);
    printf("Building DAG:\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    DAGNode* root = parseE();
    
    printDAG();
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("           Generated Code from DAG\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    memset(generated, 0, sizeof(generated));
    char* result = generateCode(root);
    printf("\n  Result in: %s\n", result);
    
    // Compare: Without DAG (redundant computation)
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("     Without DAG (Redundant):           With DAG:\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("     t1 = b - c                         t1 = b - c\n");
    printf("     t2 = a * t1                        t2 = a * t1\n");
    printf("     t3 = a + t2                        t3 = a + t2\n");
    printf("     t4 = b - c    â† Redundant!         t4 = t1 * d â† Reuses t1!\n");
    printf("     t5 = t4 * d                        t5 = t3 + t4\n");
    printf("     t6 = t3 + t5\n");
    printf("\n     6 operations                       5 operations\n");
    
    return 0;
}
```

## ğŸ“Š Quadruples, Triples, and Indirect Triples

### Quadruple Representation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Quadruples                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Format: (op, arg1, arg2, result)                              â”‚
â”‚                                                                 â”‚
â”‚  Expression: a = b * c + b * d                                 â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”                          â”‚
â”‚  â”‚  #  â”‚ op  â”‚ arg1 â”‚ arg2 â”‚ result â”‚                          â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤                          â”‚
â”‚  â”‚  0  â”‚  *  â”‚  b   â”‚  c   â”‚   t1   â”‚                          â”‚
â”‚  â”‚  1  â”‚  *  â”‚  b   â”‚  d   â”‚   t2   â”‚                          â”‚
â”‚  â”‚  2  â”‚  +  â”‚  t1  â”‚  t2  â”‚   t3   â”‚                          â”‚
â”‚  â”‚  3  â”‚  =  â”‚  t3  â”‚      â”‚   a    â”‚                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â”‚                                                                 â”‚
â”‚  à¦¸à§à¦¬à¦¿à¦§à¦¾: Result-à¦ à¦¸à¦°à¦¾à¦¸à¦°à¦¿ access                                 â”‚
â”‚  à¦…à¦¸à§à¦¬à¦¿à¦§à¦¾: à¦¬à§‡à¦¶à¦¿ memory (temporary names store à¦•à¦°à¦¤à§‡ à¦¹à¦¯à¦¼)          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Triple Representation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Triples                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Format: (op, arg1, arg2) with index as reference              â”‚
â”‚                                                                 â”‚
â”‚  Expression: a = b * c + b * d                                 â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”                                   â”‚
â”‚  â”‚  #  â”‚ op  â”‚ arg1 â”‚ arg2 â”‚                                   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤                                   â”‚
â”‚  â”‚  0  â”‚  *  â”‚  b   â”‚  c   â”‚                                   â”‚
â”‚  â”‚  1  â”‚  *  â”‚  b   â”‚  d   â”‚                                   â”‚
â”‚  â”‚  2  â”‚  +  â”‚ (0)  â”‚ (1)  â”‚ â† References indices 0 and 1      â”‚
â”‚  â”‚  3  â”‚  =  â”‚  a   â”‚ (2)  â”‚                                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜                                   â”‚
â”‚                                                                 â”‚
â”‚  à¦¸à§à¦¬à¦¿à¦§à¦¾: à¦•à¦® memory (no temp names)                              â”‚
â”‚  à¦…à¦¸à§à¦¬à¦¿à¦§à¦¾: Reordering à¦•à¦ à¦¿à¦¨ (references change)                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Indirect Triple

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Indirect Triples                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Pointer List:          Triple Table:                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  #  â”‚ ptr â”‚          â”‚  #  â”‚ op  â”‚ arg1 â”‚ arg2 â”‚            â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤            â”‚
â”‚  â”‚  0  â”‚ 14  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ 14  â”‚  *  â”‚  b   â”‚  c   â”‚            â”‚
â”‚  â”‚  1  â”‚ 15  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ 15  â”‚  *  â”‚  b   â”‚  d   â”‚            â”‚
â”‚  â”‚  2  â”‚ 16  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ 16  â”‚  +  â”‚(14)  â”‚(15)  â”‚            â”‚
â”‚  â”‚  3  â”‚ 17  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚ 17  â”‚  =  â”‚  a   â”‚(16)  â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                                                                 â”‚
â”‚  à¦¸à§à¦¬à¦¿à¦§à¦¾: Reordering à¦¸à¦¹à¦œ (à¦¶à§à¦§à§ pointer list change)              â”‚
â”‚         Optimization-à¦ triple table intact à¦¥à¦¾à¦•à§‡                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Quadruple Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Quadruple Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct {
    char op[10];
    char arg1[20];
    char arg2[20];
    char result[20];
} Quadruple;

typedef struct {
    int op;      // Index to op
    int arg1;    // Index or value
    int arg2;    // Index or value
} Triple;

#define MAX_QUADS 100
Quadruple quads[MAX_QUADS];
int quadCount = 0;

Triple triples[MAX_QUADS];
int tripleCount = 0;

int indirectList[MAX_QUADS];
int indirectCount = 0;

int tempCount = 0;

char* newTemp() {
    static char temp[10];
    sprintf(temp, "t%d", tempCount++);
    return temp;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Quadruple Generation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void emitQuad(char* op, char* arg1, char* arg2, char* result) {
    strcpy(quads[quadCount].op, op);
    strcpy(quads[quadCount].arg1, arg1 ? arg1 : "");
    strcpy(quads[quadCount].arg2, arg2 ? arg2 : "");
    strcpy(quads[quadCount].result, result ? result : "");
    quadCount++;
}

void printQuadruples() {
    printf("\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("â”‚  #   â”‚  Op  â”‚  Arg1  â”‚  Arg2  â”‚  Result  â”‚\n");
    printf("â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");
    
    for(int i = 0; i < quadCount; i++) {
        printf("â”‚  %2d  â”‚  %-3s â”‚  %-5s â”‚  %-5s â”‚  %-7s â”‚\n",
               i, quads[i].op, quads[i].arg1, 
               quads[i].arg2, quads[i].result);
    }
    
    printf("â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Triple Generation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int emitTriple(char* op, char* arg1, char* arg2) {
    // For simplicity, store strings directly
    // In real implementation, use indices
    printf("  (%d) %s, %s, %s\n", tripleCount, op, arg1, arg2);
    return tripleCount++;
}

void printTriples() {
    printf("\nâ”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("â”‚  #   â”‚  Op  â”‚  Arg1  â”‚  Arg2  â”‚\n");
    printf("â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");
    printf("â”‚  0   â”‚  *   â”‚   b    â”‚   c    â”‚\n");
    printf("â”‚  1   â”‚  *   â”‚   b    â”‚   d    â”‚\n");
    printf("â”‚  2   â”‚  +   â”‚  (0)   â”‚  (1)   â”‚\n");
    printf("â”‚  3   â”‚  =   â”‚   a    â”‚  (2)   â”‚\n");
    printf("â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

void printIndirectTriples() {
    printf("\nPointer List:          Triple Table:\n");
    printf("â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”          â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("â”‚  #   â”‚ ptr  â”‚          â”‚  #   â”‚  Op  â”‚  Arg1  â”‚  Arg2  â”‚\n");
    printf("â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¤          â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");
    printf("â”‚  0   â”‚  14  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  14  â”‚  *   â”‚   b    â”‚   c    â”‚\n");
    printf("â”‚  1   â”‚  15  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  15  â”‚  *   â”‚   b    â”‚   d    â”‚\n");
    printf("â”‚  2   â”‚  16  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  16  â”‚  +   â”‚  (14)  â”‚  (15)  â”‚\n");
    printf("â”‚  3   â”‚  17  â”‚ â”€â”€â”€â”€â”€â”€â”€â†’ â”‚  17  â”‚  =   â”‚   a    â”‚  (16)  â”‚\n");
    printf("â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”˜          â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘    Quadruples, Triples, Indirect Triples Demo         â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    printf("\nExpression: a = b * c + b * d\n");
    
    // Generate Quadruples
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                  QUADRUPLES\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    char* t1 = newTemp();
    char* t2 = newTemp();
    char* t3 = newTemp();
    
    emitQuad("*", "b", "c", t1);
    emitQuad("*", "b", "d", t2);
    emitQuad("+", t1, t2, t3);
    emitQuad("=", t3, NULL, "a");
    
    printQuadruples();
    
    // Show Triples
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                   TRIPLES\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    printTriples();
    
    printf("\nNote: (0), (1), (2) are references to triple indices\n");
    printf("      No temporary names needed!\n");
    
    // Show Indirect Triples
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("              INDIRECT TRIPLES\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    printIndirectTriples();
    
    printf("\nNote: Pointer list can be reordered for optimization\n");
    printf("      without changing the triple table!\n");
    
    // Comparison
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                 COMPARISON\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    printf("â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("â”‚ Representation     â”‚ Characteristics               â”‚\n");
    printf("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤\n");
    printf("â”‚ Quadruple          â”‚ Easy access, more memory      â”‚\n");
    printf("â”‚ Triple             â”‚ Less memory, reorder hard     â”‚\n");
    printf("â”‚ Indirect Triple    â”‚ Easy reorder, medium memory   â”‚\n");
    printf("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
    
    return 0;
}
```

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦•à§‹à¦¡ à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨](../à§¦à§®-à¦•à§‹à¦¡-à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨/à§¦à§§-à¦…à¦ªà§à¦Ÿà¦¿à¦®à¦¾à¦‡à¦œà§‡à¦¶à¦¨-à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿.md)
