# ğŸ”„ à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦¡à¦¿à¦°à§‡à¦•à§à¦Ÿà§‡à¦¡ à¦Ÿà§à¦°à¦¾à¦¨à§à¦¸à¦²à§‡à¦¶à¦¨ (SDT)

## SDT à¦•à§€?

**Syntax Directed Translation (SDT)** à¦¹à¦²à§‹ à¦à¦®à¦¨ à¦ªà¦¦à§à¦§à¦¤à¦¿ à¦¯à§‡à¦–à¦¾à¦¨à§‡ Grammar rules-à¦à¦° à¦¸à¦¾à¦¥à§‡ **semantic actions** à¦¯à§à¦•à§à¦¤ à¦•à¦°à§‡ translation à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Syntax Directed Translation (SDT)                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Production Rule + Semantic Actions                             â”‚
â”‚                                                                 â”‚
â”‚  E â†’ Eâ‚ + T   { E.val = Eâ‚.val + T.val }                       â”‚
â”‚                          â”‚                                      â”‚
â”‚                          â””â”€â”€ Semantic Action                    â”‚
â”‚                                                                 â”‚
â”‚  Parse Tree â†’ Annotated Parse Tree â†’ Output                     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Attribute Types

### Synthesized vs Inherited Attributes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Attribute Types                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Synthesized Attributes:                                        â”‚
â”‚  â”œâ”€â”€ Value flows upward (children â†’ parent)                    â”‚
â”‚  â”œâ”€â”€ Computed from children's attributes                        â”‚
â”‚  â””â”€â”€ Example: Expression value calculation                      â”‚
â”‚                                                                 â”‚
â”‚           E.val = 8                                             â”‚
â”‚          /â”‚\                                                    â”‚
â”‚         E + T                                                   â”‚
â”‚       â†‘     â†‘                                                   â”‚
â”‚    E.val  T.val                                                 â”‚
â”‚      5      3                                                   â”‚
â”‚                                                                 â”‚
â”‚  Inherited Attributes:                                          â”‚
â”‚  â”œâ”€â”€ Value flows downward (parent â†’ children)                  â”‚
â”‚  â”œâ”€â”€ Computed from parent/sibling attributes                   â”‚
â”‚  â””â”€â”€ Example: Type information                                  â”‚
â”‚                                                                 â”‚
â”‚         Decl (type = int)                                       â”‚
â”‚          â”‚â†“                                                     â”‚
â”‚         Var (type = int inherited)                              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”¤ Attribute Grammar

### S-Attributed Grammar

à¦¶à§à¦§à§à¦®à¦¾à¦¤à§à¦° **Synthesized attributes** à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à§‡à¥¤

```
Grammar for Calculator:

E â†’ Eâ‚ + T    { E.val = Eâ‚.val + T.val }
E â†’ Eâ‚ - T    { E.val = Eâ‚.val - T.val }
E â†’ T         { E.val = T.val }
T â†’ Tâ‚ * F    { T.val = Tâ‚.val * F.val }
T â†’ Tâ‚ / F    { T.val = Tâ‚.val / F.val }
T â†’ F         { T.val = F.val }
F â†’ ( E )     { F.val = E.val }
F â†’ num       { F.val = num.lexval }

Parse Tree for "3 + 5 * 2":

                E.val = 13
               /â”‚\
              / + \
    E.val=3  â”‚    T.val=10
       â”‚          /â”‚\
    T.val=3      / * \
       â”‚   T.val=5   F.val=2
    F.val=3     â”‚        â”‚
       â”‚     F.val=5     2
       3        â”‚
                5
```

### L-Attributed Grammar

**Inherited attributes** + left-to-right evaluationà¥¤

```
Grammar with Type Inheritance:

D â†’ T L        { L.in = T.type }
T â†’ int        { T.type = integer }
T â†’ float      { T.type = real }
L â†’ Lâ‚, id     { Lâ‚.in = L.in;
                 addType(id.entry, L.in) }
L â†’ id         { addType(id.entry, L.in) }

Parse Tree for "int a, b, c":

           D
          /â”‚\
         T  L.in = integer
         â”‚   /â”‚\
        int Lâ‚  , id(c)
             /â”‚\    â†“
           Lâ‚ , id(b)
            â”‚    â†“
          id(a)
            â†“
    a: integer
    b: integer  
    c: integer
```

## ğŸ’» SDT Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <string.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Token Definition
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    TOKEN_NUM,
    TOKEN_ID,
    TOKEN_PLUS,
    TOKEN_MINUS,
    TOKEN_MUL,
    TOKEN_DIV,
    TOKEN_LPAREN,
    TOKEN_RPAREN,
    TOKEN_ASSIGN,
    TOKEN_SEMICOLON,
    TOKEN_INT,      // Keyword: int
    TOKEN_FLOAT,    // Keyword: float
    TOKEN_COMMA,
    TOKEN_EOF
} TokenType;

typedef struct {
    TokenType type;
    union {
        int intVal;
        double floatVal;
        char idName[50];
    };
} Token;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Attribute Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_VOID
} DataType;

typedef struct Attribute {
    DataType type;           // Inherited/Synthesized type
    double value;            // Synthesized value
    char* code;              // Generated code (synthesized)
    char* place;             // Temporary variable name
} Attribute;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Symbol Table for SDT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct SymEntry {
    char name[50];
    DataType type;
    double value;
    struct SymEntry* next;
} SymEntry;

SymEntry* symbolTable = NULL;

void addSymbol(char* name, DataType type) {
    SymEntry* entry = malloc(sizeof(SymEntry));
    strcpy(entry->name, name);
    entry->type = type;
    entry->value = 0;
    entry->next = symbolTable;
    symbolTable = entry;
    printf("  [Symbol Table] Added: %s (type: %s)\n", 
           name, type == TYPE_INT ? "int" : "float");
}

SymEntry* lookupSymbol(char* name) {
    for(SymEntry* e = symbolTable; e != NULL; e = e->next) {
        if(strcmp(e->name, name) == 0) return e;
    }
    return NULL;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Lexer
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

char* input;
int pos = 0;
Token currentToken;

void skipWhitespace() {
    while(input[pos] == ' ' || input[pos] == '\t' || input[pos] == '\n') {
        pos++;
    }
}

void getNextToken() {
    skipWhitespace();
    
    if(input[pos] == '\0') {
        currentToken.type = TOKEN_EOF;
        return;
    }
    
    if(isdigit(input[pos])) {
        int val = 0;
        while(isdigit(input[pos])) {
            val = val * 10 + (input[pos] - '0');
            pos++;
        }
        if(input[pos] == '.') {
            pos++;
            double frac = 0.1;
            double fval = val;
            while(isdigit(input[pos])) {
                fval += (input[pos] - '0') * frac;
                frac *= 0.1;
                pos++;
            }
            currentToken.type = TOKEN_NUM;
            currentToken.floatVal = fval;
        } else {
            currentToken.type = TOKEN_NUM;
            currentToken.intVal = val;
        }
        return;
    }
    
    if(isalpha(input[pos])) {
        int i = 0;
        while(isalnum(input[pos])) {
            currentToken.idName[i++] = input[pos++];
        }
        currentToken.idName[i] = '\0';
        
        if(strcmp(currentToken.idName, "int") == 0) {
            currentToken.type = TOKEN_INT;
        } else if(strcmp(currentToken.idName, "float") == 0) {
            currentToken.type = TOKEN_FLOAT;
        } else {
            currentToken.type = TOKEN_ID;
        }
        return;
    }
    
    switch(input[pos]) {
        case '+': currentToken.type = TOKEN_PLUS; break;
        case '-': currentToken.type = TOKEN_MINUS; break;
        case '*': currentToken.type = TOKEN_MUL; break;
        case '/': currentToken.type = TOKEN_DIV; break;
        case '(': currentToken.type = TOKEN_LPAREN; break;
        case ')': currentToken.type = TOKEN_RPAREN; break;
        case '=': currentToken.type = TOKEN_ASSIGN; break;
        case ';': currentToken.type = TOKEN_SEMICOLON; break;
        case ',': currentToken.type = TOKEN_COMMA; break;
        default: currentToken.type = TOKEN_EOF;
    }
    pos++;
}

void match(TokenType expected) {
    if(currentToken.type != expected) {
        printf("Error: Unexpected token\n");
        exit(1);
    }
    getNextToken();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SDT Parser with Semantic Actions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int tempCount = 0;
char* newTemp() {
    char* temp = malloc(10);
    sprintf(temp, "t%d", tempCount++);
    return temp;
}

// Forward declarations
Attribute E();
Attribute T();
Attribute F();
void parseDeclaration();
void parseList(DataType inheritedType);

/*
 * Grammar with Semantic Actions:
 * 
 * E â†’ E + T  { E.val = Eâ‚.val + T.val; E.place = newTemp(); 
 *              emit(E.place, "=", Eâ‚.place, "+", T.place) }
 * E â†’ T      { E.val = T.val; E.place = T.place }
 * 
 * T â†’ T * F  { T.val = Tâ‚.val * F.val; T.place = newTemp();
 *              emit(T.place, "=", Tâ‚.place, "*", F.place) }
 * T â†’ F      { T.val = F.val; T.place = F.place }
 * 
 * F â†’ ( E )  { F.val = E.val; F.place = E.place }
 * F â†’ num    { F.val = num.val; F.place = newTemp();
 *              emit(F.place, "=", num.val) }
 */

// E â†’ T E'
// E' â†’ + T E' | - T E' | Îµ
Attribute E() {
    printf("  Parsing E...\n");
    Attribute result = T();
    
    while(currentToken.type == TOKEN_PLUS || 
          currentToken.type == TOKEN_MINUS) {
        char op = currentToken.type == TOKEN_PLUS ? '+' : '-';
        getNextToken();
        
        Attribute right = T();
        
        // Semantic Action: Compute value
        double newVal;
        if(op == '+') {
            newVal = result.value + right.value;
        } else {
            newVal = result.value - right.value;
        }
        
        // Semantic Action: Generate code
        char* temp = newTemp();
        printf("  [Code] %s = %s %c %s\n", 
               temp, result.place, op, right.place);
        
        // Semantic Action: Type checking
        if(result.type == TYPE_FLOAT || right.type == TYPE_FLOAT) {
            result.type = TYPE_FLOAT;
        }
        
        result.value = newVal;
        result.place = temp;
    }
    
    printf("  E.val = %.2f, E.place = %s\n", result.value, result.place);
    return result;
}

// T â†’ F T'
// T' â†’ * F T' | / F T' | Îµ
Attribute T() {
    printf("  Parsing T...\n");
    Attribute result = F();
    
    while(currentToken.type == TOKEN_MUL || 
          currentToken.type == TOKEN_DIV) {
        char op = currentToken.type == TOKEN_MUL ? '*' : '/';
        getNextToken();
        
        Attribute right = F();
        
        // Semantic Action: Compute value
        double newVal;
        if(op == '*') {
            newVal = result.value * right.value;
        } else {
            newVal = result.value / right.value;
        }
        
        // Semantic Action: Generate code
        char* temp = newTemp();
        printf("  [Code] %s = %s %c %s\n", 
               temp, result.place, op, right.place);
        
        result.value = newVal;
        result.place = temp;
    }
    
    printf("  T.val = %.2f, T.place = %s\n", result.value, result.place);
    return result;
}

// F â†’ ( E ) | num | id
Attribute F() {
    printf("  Parsing F...\n");
    Attribute result;
    result.type = TYPE_INT;
    
    if(currentToken.type == TOKEN_LPAREN) {
        getNextToken();
        result = E();
        match(TOKEN_RPAREN);
    }
    else if(currentToken.type == TOKEN_NUM) {
        result.value = currentToken.intVal;
        result.place = newTemp();
        
        // Semantic Action: Generate code for constant
        printf("  [Code] %s = %.2f\n", result.place, result.value);
        
        getNextToken();
    }
    else if(currentToken.type == TOKEN_ID) {
        SymEntry* sym = lookupSymbol(currentToken.idName);
        if(sym != NULL) {
            result.value = sym->value;
            result.type = sym->type;
            result.place = strdup(currentToken.idName);
        } else {
            printf("  Error: Undefined variable '%s'\n", currentToken.idName);
            result.value = 0;
            result.place = "?";
        }
        getNextToken();
    }
    
    printf("  F.val = %.2f, F.place = %s\n", result.value, result.place);
    return result;
}

/*
 * Declaration Grammar with Inherited Attributes:
 * 
 * D â†’ T L        { L.in = T.type }
 * T â†’ int        { T.type = integer }
 * T â†’ float      { T.type = real }
 * L â†’ L, id      { Lâ‚.in = L.in; addType(id, L.in) }
 * L â†’ id         { addType(id, L.in) }
 */

void parseDeclaration() {
    printf("\nParsing Declaration...\n");
    
    DataType declType;
    
    // T â†’ int | float
    if(currentToken.type == TOKEN_INT) {
        declType = TYPE_INT;
        printf("  Type = int\n");
    } else if(currentToken.type == TOKEN_FLOAT) {
        declType = TYPE_FLOAT;
        printf("  Type = float\n");
    } else {
        return;
    }
    getNextToken();
    
    // L inherits type from T
    parseList(declType);  // L.in = T.type
    
    if(currentToken.type == TOKEN_SEMICOLON) {
        getNextToken();
    }
}

void parseList(DataType inheritedType) {
    // L â†’ id
    if(currentToken.type == TOKEN_ID) {
        // Semantic Action: Add symbol with inherited type
        addSymbol(currentToken.idName, inheritedType);
        getNextToken();
    }
    
    // L â†’ L, id
    while(currentToken.type == TOKEN_COMMA) {
        getNextToken();
        if(currentToken.type == TOKEN_ID) {
            // Semantic Action: Add symbol with inherited type
            addSymbol(currentToken.idName, inheritedType);
            getNextToken();
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void demonstrateSDT(char* expression) {
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("Input: %s\n", expression);
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    input = expression;
    pos = 0;
    tempCount = 0;
    
    getNextToken();
    
    if(currentToken.type == TOKEN_INT || currentToken.type == TOKEN_FLOAT) {
        parseDeclaration();
    } else {
        Attribute result = E();
        printf("\nFinal Result: %.2f\n", result.value);
    }
}

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘      Syntax Directed Translation Demo                 â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    // Demo 1: Expression with synthesized attributes
    demonstrateSDT("3 + 5 * 2");
    
    // Demo 2: Another expression
    demonstrateSDT("(4 + 6) * 2");
    
    // Demo 3: Declaration with inherited attributes
    demonstrateSDT("int a, b, c;");
    
    // Demo 4: Float declaration
    demonstrateSDT("float x, y;");
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("SDT Demo Complete\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
```

## ğŸ“‹ SDT Summary

| Concept | Description | Direction |
|---------|-------------|-----------|
| Synthesized | Value from children | Bottom-up â†‘ |
| Inherited | Value from parent/sibling | Top-down â†“ |
| S-Attributed | Only synthesized | LR parsable |
| L-Attributed | Left-to-right inherited | LL parsable |
| Semantic Action | Code in { } | With production |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à§‡à¦Ÿ à¦•à§‹à¦¡ à¦œà§‡à¦¨à¦¾à¦°à§‡à¦¶à¦¨](../à§¦à§­-à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à§‡à¦Ÿ-à¦•à§‹à¦¡/à§¦à§§-à¦‡à¦¨à§à¦Ÿà¦¾à¦°à¦®à¦¿à¦¡à¦¿à¦¯à¦¼à§‡à¦Ÿ-à¦•à§‹à¦¡-à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿.md)
