# ğŸ” à¦Ÿà¦¾à¦‡à¦ª à¦šà§‡à¦•à¦¿à¦‚ (Type Checking)

## à¦Ÿà¦¾à¦‡à¦ª à¦šà§‡à¦•à¦¿à¦‚ à¦•à§€?

**à¦Ÿà¦¾à¦‡à¦ª à¦šà§‡à¦•à¦¿à¦‚** à¦¹à¦²à§‹ à¦¯à¦¾à¦šà¦¾à¦‡ à¦•à¦°à¦¾ à¦¯à§‡ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à§‡à¦° expressions à¦à¦¬à¦‚ statements-à¦ à¦¸à¦ à¦¿à¦• types à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à§‡à¦›à§‡ à¦•à¦¿à¦¨à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Type Checking                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚   int x = 5 + 3.14;                                            â”‚
â”‚           â”‚   â”‚                                                 â”‚
â”‚           â”‚   â””â”€â”€ float (3.14)                                 â”‚
â”‚           â”‚                                                     â”‚
â”‚           â””â”€â”€ int (5) + float â†’ float (automatic promotion)   â”‚
â”‚                          â”‚                                      â”‚
â”‚                          â””â”€â”€ Assign float to int               â”‚
â”‚                              â””â”€â”€ Warning: narrowing conversion â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Type System Categories

### Static vs Dynamic Typing

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚  Static Typing (Compile-time):                                    â”‚
â”‚  â”œâ”€â”€ C, C++, Java, Rust                                          â”‚
â”‚  â”œâ”€â”€ Types checked before execution                              â”‚
â”‚  â”œâ”€â”€ Earlier error detection                                     â”‚
â”‚  â””â”€â”€ Better performance                                          â”‚
â”‚                                                                   â”‚
â”‚  Dynamic Typing (Runtime):                                        â”‚
â”‚  â”œâ”€â”€ Python, JavaScript, Ruby                                    â”‚
â”‚  â”œâ”€â”€ Types checked during execution                              â”‚
â”‚  â”œâ”€â”€ More flexible                                               â”‚
â”‚  â””â”€â”€ Slower execution                                            â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Strong vs Weak Typing

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                   â”‚
â”‚  Strong Typing:                                                   â”‚
â”‚  â”œâ”€â”€ Python, Java                                                â”‚
â”‚  â”œâ”€â”€ Strict type rules                                           â”‚
â”‚  â””â”€â”€ "1" + 1 â†’ Error                                             â”‚
â”‚                                                                   â”‚
â”‚  Weak Typing:                                                     â”‚
â”‚  â”œâ”€â”€ JavaScript, C                                               â”‚
â”‚  â”œâ”€â”€ Implicit conversions                                        â”‚
â”‚  â””â”€â”€ "1" + 1 â†’ "11" (JS) or undefined (C)                       â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ Type Conversion

### Implicit Conversion (Type Coercion)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Type Promotion Hierarchy                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  char â†’ short â†’ int â†’ long â†’ float â†’ double â†’ long double      â”‚
â”‚    â”‚      â”‚       â”‚      â”‚       â”‚        â”‚          â”‚          â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚
â”‚           Widening (safe) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’             â”‚
â”‚                                                                 â”‚
â”‚  â†â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Narrowing (may lose data)   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
int a = 5;
float b = 3.14;
float c = a + b;   // a implicitly converted to float

     int(5)  â†’  float(5.0)
                    +
               float(3.14)
                    =
               float(8.14)
```

### Explicit Conversion (Type Casting)

```c
// Explicit casting
float f = 3.14;
int i = (int)f;     // Explicit: 3

double d = 3.14159;
int* p = (int*)&d;  // Dangerous but allowed with explicit cast
```

## ğŸ’» Type Checking Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Type Definitions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    TYPE_VOID,
    TYPE_BOOL,
    TYPE_CHAR,
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_DOUBLE,
    TYPE_STRING,
    TYPE_POINTER,
    TYPE_ARRAY,
    TYPE_FUNCTION,
    TYPE_STRUCT,
    TYPE_ERROR
} TypeKind;

typedef struct Type {
    TypeKind kind;
    struct Type* baseType;      // For pointers, arrays
    struct Type* returnType;    // For functions
    struct Type** paramTypes;   // For functions
    int paramCount;
    int arraySize;
    char* structName;
} Type;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Type Creation Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Type* makeType(TypeKind kind) {
    Type* t = malloc(sizeof(Type));
    t->kind = kind;
    t->baseType = NULL;
    t->returnType = NULL;
    t->paramTypes = NULL;
    t->paramCount = 0;
    t->arraySize = 0;
    t->structName = NULL;
    return t;
}

Type* makePointerType(Type* base) {
    Type* t = makeType(TYPE_POINTER);
    t->baseType = base;
    return t;
}

Type* makeArrayType(Type* base, int size) {
    Type* t = makeType(TYPE_ARRAY);
    t->baseType = base;
    t->arraySize = size;
    return t;
}

Type* makeFunctionType(Type* returnType, Type** params, int paramCount) {
    Type* t = makeType(TYPE_FUNCTION);
    t->returnType = returnType;
    t->paramTypes = params;
    t->paramCount = paramCount;
    return t;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Type Comparison
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int typesEqual(Type* t1, Type* t2) {
    if(t1 == NULL || t2 == NULL) return 0;
    if(t1->kind != t2->kind) return 0;
    
    switch(t1->kind) {
        case TYPE_POINTER:
        case TYPE_ARRAY:
            return typesEqual(t1->baseType, t2->baseType);
            
        case TYPE_FUNCTION:
            if(!typesEqual(t1->returnType, t2->returnType)) return 0;
            if(t1->paramCount != t2->paramCount) return 0;
            for(int i = 0; i < t1->paramCount; i++) {
                if(!typesEqual(t1->paramTypes[i], t2->paramTypes[i])) {
                    return 0;
                }
            }
            return 1;
            
        default:
            return 1;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Type Compatibility and Conversion
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Type rank for promotion
int typeRank(TypeKind kind) {
    switch(kind) {
        case TYPE_BOOL: return 1;
        case TYPE_CHAR: return 2;
        case TYPE_INT: return 3;
        case TYPE_FLOAT: return 4;
        case TYPE_DOUBLE: return 5;
        default: return 0;
    }
}

// Check if implicit conversion is possible
typedef enum {
    CONV_NONE,           // No conversion needed
    CONV_WIDENING,       // Safe promotion
    CONV_NARROWING,      // May lose data
    CONV_NOT_POSSIBLE    // Cannot convert
} ConversionKind;

ConversionKind checkConversion(Type* from, Type* to) {
    if(typesEqual(from, to)) return CONV_NONE;
    
    // Numeric conversions
    if(typeRank(from->kind) > 0 && typeRank(to->kind) > 0) {
        if(typeRank(from->kind) < typeRank(to->kind)) {
            return CONV_WIDENING;
        } else {
            return CONV_NARROWING;
        }
    }
    
    // Array to pointer decay
    if(from->kind == TYPE_ARRAY && to->kind == TYPE_POINTER) {
        if(typesEqual(from->baseType, to->baseType)) {
            return CONV_WIDENING;
        }
    }
    
    // Pointer to bool
    if(from->kind == TYPE_POINTER && to->kind == TYPE_BOOL) {
        return CONV_WIDENING;
    }
    
    return CONV_NOT_POSSIBLE;
}

char* typeToString(Type* t) {
    static char buffer[100];
    
    if(t == NULL) return "null";
    
    switch(t->kind) {
        case TYPE_VOID: return "void";
        case TYPE_BOOL: return "bool";
        case TYPE_CHAR: return "char";
        case TYPE_INT: return "int";
        case TYPE_FLOAT: return "float";
        case TYPE_DOUBLE: return "double";
        case TYPE_STRING: return "string";
        case TYPE_POINTER:
            sprintf(buffer, "%s*", typeToString(t->baseType));
            return buffer;
        case TYPE_ARRAY:
            sprintf(buffer, "%s[%d]", typeToString(t->baseType), t->arraySize);
            return buffer;
        case TYPE_FUNCTION:
            return "function";
        case TYPE_ERROR: return "error";
        default: return "unknown";
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Type Checking Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Type* checkArithmeticOp(Type* left, Type* right, char* op) {
    printf("Checking: %s %s %s\n", 
           typeToString(left), op, typeToString(right));
    
    // Both must be numeric
    if(typeRank(left->kind) == 0 || typeRank(right->kind) == 0) {
        printf("  Error: Non-numeric operand\n");
        return makeType(TYPE_ERROR);
    }
    
    // Result is the larger type
    if(typeRank(left->kind) >= typeRank(right->kind)) {
        printf("  Result: %s\n", typeToString(left));
        return left;
    } else {
        printf("  Result: %s (promotion)\n", typeToString(right));
        return right;
    }
}

Type* checkRelationalOp(Type* left, Type* right, char* op) {
    printf("Checking: %s %s %s\n", 
           typeToString(left), op, typeToString(right));
    
    // Both numeric or both pointers
    int leftNumeric = typeRank(left->kind) > 0;
    int rightNumeric = typeRank(right->kind) > 0;
    
    if((leftNumeric && rightNumeric) || 
       (left->kind == TYPE_POINTER && right->kind == TYPE_POINTER)) {
        printf("  Result: bool\n");
        return makeType(TYPE_BOOL);
    }
    
    printf("  Error: Invalid comparison\n");
    return makeType(TYPE_ERROR);
}

int checkAssignment(Type* target, Type* source, int line) {
    printf("Assignment check (line %d): %s = %s\n",
           line, typeToString(target), typeToString(source));
    
    ConversionKind conv = checkConversion(source, target);
    
    switch(conv) {
        case CONV_NONE:
            printf("  OK: No conversion needed\n");
            return 1;
        case CONV_WIDENING:
            printf("  OK: Widening conversion\n");
            return 1;
        case CONV_NARROWING:
            printf("  Warning: Narrowing conversion (may lose data)\n");
            return 1;  // Allow with warning
        case CONV_NOT_POSSIBLE:
            printf("  Error: Cannot convert %s to %s\n",
                   typeToString(source), typeToString(target));
            return 0;
    }
    return 0;
}

int checkFunctionCall(Type* funcType, Type** argTypes, int argCount, int line) {
    printf("Function call check (line %d):\n", line);
    
    if(funcType->kind != TYPE_FUNCTION) {
        printf("  Error: Not a function\n");
        return 0;
    }
    
    if(funcType->paramCount != argCount) {
        printf("  Error: Expected %d arguments, got %d\n",
               funcType->paramCount, argCount);
        return 0;
    }
    
    for(int i = 0; i < argCount; i++) {
        ConversionKind conv = checkConversion(argTypes[i], 
                                              funcType->paramTypes[i]);
        if(conv == CONV_NOT_POSSIBLE) {
            printf("  Error: Argument %d: cannot convert %s to %s\n",
                   i + 1, typeToString(argTypes[i]),
                   typeToString(funcType->paramTypes[i]));
            return 0;
        }
    }
    
    printf("  OK: Arguments match\n");
    return 1;
}

Type* checkArrayAccess(Type* arrayType, Type* indexType, int line) {
    printf("Array access check (line %d):\n", line);
    
    if(arrayType->kind != TYPE_ARRAY && arrayType->kind != TYPE_POINTER) {
        printf("  Error: Not an array or pointer\n");
        return makeType(TYPE_ERROR);
    }
    
    if(indexType->kind != TYPE_INT) {
        printf("  Error: Array index must be integer\n");
        return makeType(TYPE_ERROR);
    }
    
    printf("  OK: Element type is %s\n", typeToString(arrayType->baseType));
    return arrayType->baseType;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("            Type Checking Demo\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    Type* intType = makeType(TYPE_INT);
    Type* floatType = makeType(TYPE_FLOAT);
    Type* doubleType = makeType(TYPE_DOUBLE);
    Type* charType = makeType(TYPE_CHAR);
    Type* stringType = makeType(TYPE_STRING);
    Type* intPtr = makePointerType(intType);
    Type* intArray = makeArrayType(intType, 10);
    
    printf("1. Arithmetic Operations\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    checkArithmeticOp(intType, intType, "+");
    checkArithmeticOp(intType, floatType, "*");
    checkArithmeticOp(floatType, doubleType, "-");
    checkArithmeticOp(intType, stringType, "+");
    printf("\n");
    
    printf("2. Assignment Compatibility\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    checkAssignment(floatType, intType, 10);
    checkAssignment(intType, floatType, 11);
    checkAssignment(intType, stringType, 12);
    printf("\n");
    
    printf("3. Function Call\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    Type** params = malloc(2 * sizeof(Type*));
    params[0] = intType;
    params[1] = floatType;
    Type* funcType = makeFunctionType(intType, params, 2);
    
    Type** args = malloc(2 * sizeof(Type*));
    args[0] = intType;
    args[1] = intType;  // int to float - OK
    checkFunctionCall(funcType, args, 2, 20);
    
    args[0] = stringType;  // Error
    checkFunctionCall(funcType, args, 2, 21);
    printf("\n");
    
    printf("4. Array Access\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    checkArrayAccess(intArray, intType, 30);
    checkArrayAccess(intArray, floatType, 31);  // Warning/Error
    checkArrayAccess(intType, intType, 32);     // Error: not array
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("            Type Checking Complete\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
```

## ğŸ“‹ Type Checking Rules Summary

| Operation | Rule | Example |
|-----------|------|---------|
| Arithmetic | Both numeric | `int + float â†’ float` |
| Comparison | Same category | `int < float â†’ bool` |
| Assignment | RHS â‰¤ LHS rank | `int = char âœ“` |
| Array Index | Must be integer | `arr[i]` where i is int |
| Pointer Deref | Must be pointer | `*ptr` |
| Function Call | Args match params | `f(int, float)` |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦¡à¦¿à¦°à§‡à¦•à§à¦Ÿà§‡à¦¡ à¦Ÿà§à¦°à¦¾à¦¨à§à¦¸à¦²à§‡à¦¶à¦¨](à§¦à§©-à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸-à¦¡à¦¿à¦°à§‡à¦•à§à¦Ÿà§‡à¦¡-à¦Ÿà§à¦°à¦¾à¦¨à§à¦¸à¦²à§‡à¦¶à¦¨.md)
