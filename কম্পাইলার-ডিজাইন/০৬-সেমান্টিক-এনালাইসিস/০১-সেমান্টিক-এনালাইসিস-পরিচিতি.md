# ğŸ“˜ à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦• à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸ à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿

## à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦• à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸ à¦•à§€?

**à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦• à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸** à¦¹à¦²à§‹ à¦•à¦®à§à¦ªà¦¾à¦‡à¦²à¦¾à¦°à§‡à¦° à¦¤à§ƒà¦¤à§€à¦¯à¦¼ à¦«à§‡à¦œ à¦¯à¦¾ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à§‡à¦° **à¦…à¦°à§à¦¥ (meaning)** à¦¯à¦¾à¦šà¦¾à¦‡ à¦•à¦°à§‡à¥¤ Syntax à¦¸à¦ à¦¿à¦• à¦¹à¦²à§‡à¦“, à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à§‡à¦° à¦…à¦°à§à¦¥ à¦¸à¦ à¦¿à¦• à¦•à¦¿à¦¨à¦¾ à¦¤à¦¾ à¦à¦‡ à¦«à§‡à¦œà§‡ à¦šà§‡à¦• à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Semantic Analysis                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Source Code                                                    â”‚
â”‚      â”‚                                                          â”‚
â”‚      â–¼                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚ Lexical â”‚ â†’ â”‚ Syntax  â”‚ â†’ â”‚  Semantic    â”‚                  â”‚
â”‚  â”‚ Analyzerâ”‚   â”‚ Analyzerâ”‚   â”‚  Analyzer    â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                      â”‚                          â”‚
â”‚                                      â–¼                          â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚                        â”‚   Annotated AST      â”‚                 â”‚
â”‚                        â”‚   (Type info à¦¸à¦¹)     â”‚                 â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ¯ à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦• à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸-à¦à¦° à¦•à¦¾à¦œ

### à§§. Type Checking

```c
// à¦­à§à¦² - Type mismatch
int x = "hello";  // String to int âŒ

// à¦­à§à¦² - Incompatible types
float f = 3.14;
int* p = f;       // float to pointer âŒ

// à¦¸à¦ à¦¿à¦•
int a = 5;
float b = a;      // int to float (implicit conversion) âœ“
```

### à§¨. Variable Declaration Check

```c
// à¦­à§à¦² - Undeclared variable
x = 10;        // x declared à¦¨à¦¯à¦¼ âŒ

// à¦­à§à¦² - Duplicate declaration
int y = 5;
int y = 10;    // y à¦†à¦—à§‡à¦‡ declared âŒ

// à¦¸à¦ à¦¿à¦•
int z;
z = 10;        // âœ“
```

### à§©. Scope Resolution

```c
int x = 10;        // Global scope

void func() {
    int x = 20;    // Local scope - shadows global
    {
        int x = 30;  // Block scope - shadows local
        printf("%d", x);  // 30 à¦ªà§à¦°à¦¿à¦¨à§à¦Ÿ à¦¹à¦¬à§‡
    }
    printf("%d", x);      // 20 à¦ªà§à¦°à¦¿à¦¨à§à¦Ÿ à¦¹à¦¬à§‡
}
```

### à§ª. Function Call Validation

```c
// Function declaration
int add(int a, int b);

// à¦­à§à¦² - Wrong number of arguments
add(1);           // âŒ
add(1, 2, 3);     // âŒ

// à¦­à§à¦² - Wrong argument type
add("hello", 5);  // âŒ

// à¦¸à¦ à¦¿à¦•
add(1, 2);        // âœ“
```

## ğŸ“Š Static vs Dynamic Semantics

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Static vs Dynamic Semantics                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  Static Semantics (Compile-time):                                 â”‚
â”‚  â”œâ”€â”€ Type checking                                                â”‚
â”‚  â”œâ”€â”€ Variable declaration                                         â”‚
â”‚  â”œâ”€â”€ Scope rules                                                  â”‚
â”‚  â”œâ”€â”€ Function signature matching                                  â”‚
â”‚  â””â”€â”€ Constant folding                                             â”‚
â”‚                                                                   â”‚
â”‚  Dynamic Semantics (Runtime):                                     â”‚
â”‚  â”œâ”€â”€ Array bounds checking                                        â”‚
â”‚  â”œâ”€â”€ Null pointer dereference                                     â”‚
â”‚  â”œâ”€â”€ Division by zero                                             â”‚
â”‚  â””â”€â”€ Memory access violations                                     â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸŒ³ Annotated Abstract Syntax Tree

```
Expression: int a = 5 + 3.14;

Parse Tree â†’ AST â†’ Annotated AST

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Annotated AST                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚                    Declaration                                  â”‚
â”‚                   /    |     \                                  â”‚
â”‚               type   name   init                                â”‚
â”‚               int     a       â”‚                                 â”‚
â”‚                              +                                  â”‚
â”‚                            /   \                                â”‚
â”‚                          5     3.14                             â”‚
â”‚                        [int]  [float]                           â”‚
â”‚                            \   /                                â”‚
â”‚                          [float] â†â”€â”€ Result type                â”‚
â”‚                              â”‚                                  â”‚
â”‚                       [int] â†â”€â”€ Implicit cast                   â”‚
â”‚                                                                 â”‚
â”‚  Annotations:                                                   â”‚
â”‚  â€¢ Expression type                                              â”‚
â”‚  â€¢ Implicit conversions                                         â”‚
â”‚  â€¢ Symbol table references                                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Semantic Analyzer Structure

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Type definitions
typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_CHAR,
    TYPE_STRING,
    TYPE_VOID,
    TYPE_POINTER,
    TYPE_ARRAY,
    TYPE_ERROR
} TypeKind;

typedef struct Type {
    TypeKind kind;
    struct Type* baseType;  // For pointers/arrays
    int arraySize;          // For arrays
} Type;

// Symbol Table Entry
typedef struct Symbol {
    char* name;
    Type* type;
    int scope;
    int offset;            // Memory offset
    int isFunction;
    int paramCount;
    struct Symbol* params;
    struct Symbol* next;
} Symbol;

// Symbol Table
typedef struct SymbolTable {
    Symbol* symbols;
    int currentScope;
    struct SymbolTable* parent;
} SymbolTable;

// AST Node
typedef struct ASTNode {
    int nodeType;
    Type* resultType;
    char* name;
    int intValue;
    float floatValue;
    struct ASTNode* left;
    struct ASTNode* right;
    struct ASTNode* next;
} ASTNode;

// Global symbol table
SymbolTable* globalTable = NULL;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Type Management Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Type* createType(TypeKind kind) {
    Type* t = malloc(sizeof(Type));
    t->kind = kind;
    t->baseType = NULL;
    t->arraySize = 0;
    return t;
}

int typesEqual(Type* t1, Type* t2) {
    if(t1->kind != t2->kind) return 0;
    if(t1->kind == TYPE_POINTER || t1->kind == TYPE_ARRAY) {
        return typesEqual(t1->baseType, t2->baseType);
    }
    return 1;
}

int isCompatible(Type* t1, Type* t2) {
    // Same types are compatible
    if(typesEqual(t1, t2)) return 1;
    
    // int and float are compatible
    if((t1->kind == TYPE_INT && t2->kind == TYPE_FLOAT) ||
       (t1->kind == TYPE_FLOAT && t2->kind == TYPE_INT)) {
        return 1;
    }
    
    return 0;
}

Type* getResultType(Type* t1, Type* t2, char op) {
    // Arithmetic operations
    if(op == '+' || op == '-' || op == '*' || op == '/') {
        if(t1->kind == TYPE_FLOAT || t2->kind == TYPE_FLOAT) {
            return createType(TYPE_FLOAT);
        }
        if(t1->kind == TYPE_INT && t2->kind == TYPE_INT) {
            return createType(TYPE_INT);
        }
    }
    
    // Comparison operations
    if(op == '<' || op == '>' || op == '=' || op == '!') {
        return createType(TYPE_INT);  // Boolean as int
    }
    
    return createType(TYPE_ERROR);
}

char* typeToString(Type* t) {
    switch(t->kind) {
        case TYPE_INT: return "int";
        case TYPE_FLOAT: return "float";
        case TYPE_CHAR: return "char";
        case TYPE_STRING: return "string";
        case TYPE_VOID: return "void";
        case TYPE_POINTER: return "pointer";
        case TYPE_ARRAY: return "array";
        default: return "error";
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Symbol Table Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

SymbolTable* createSymbolTable(SymbolTable* parent) {
    SymbolTable* table = malloc(sizeof(SymbolTable));
    table->symbols = NULL;
    table->currentScope = parent ? parent->currentScope + 1 : 0;
    table->parent = parent;
    return table;
}

void addSymbol(SymbolTable* table, char* name, Type* type) {
    Symbol* sym = malloc(sizeof(Symbol));
    sym->name = strdup(name);
    sym->type = type;
    sym->scope = table->currentScope;
    sym->next = table->symbols;
    table->symbols = sym;
    
    printf("Added symbol: %s (type: %s, scope: %d)\n", 
           name, typeToString(type), table->currentScope);
}

Symbol* lookupSymbol(SymbolTable* table, char* name) {
    // Search current scope
    for(Symbol* s = table->symbols; s != NULL; s = s->next) {
        if(strcmp(s->name, name) == 0) {
            return s;
        }
    }
    
    // Search parent scopes
    if(table->parent != NULL) {
        return lookupSymbol(table->parent, name);
    }
    
    return NULL;
}

Symbol* lookupCurrentScope(SymbolTable* table, char* name) {
    for(Symbol* s = table->symbols; s != NULL; s = s->next) {
        if(strcmp(s->name, name) == 0 && s->scope == table->currentScope) {
            return s;
        }
    }
    return NULL;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Semantic Analysis Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void semanticError(const char* message, int line) {
    printf("Semantic Error (line %d): %s\n", line, message);
}

void semanticWarning(const char* message, int line) {
    printf("Warning (line %d): %s\n", line, message);
}

// Check variable declaration
int checkDeclaration(SymbolTable* table, char* name, Type* type, int line) {
    // Check for duplicate declaration in current scope
    if(lookupCurrentScope(table, name) != NULL) {
        char msg[100];
        sprintf(msg, "Variable '%s' already declared in this scope", name);
        semanticError(msg, line);
        return 0;
    }
    
    // Check for shadowing (warning only)
    if(lookupSymbol(table, name) != NULL) {
        char msg[100];
        sprintf(msg, "Variable '%s' shadows a variable in outer scope", name);
        semanticWarning(msg, line);
    }
    
    addSymbol(table, name, type);
    return 1;
}

// Check variable usage
Type* checkVariable(SymbolTable* table, char* name, int line) {
    Symbol* sym = lookupSymbol(table, name);
    if(sym == NULL) {
        char msg[100];
        sprintf(msg, "Undeclared variable '%s'", name);
        semanticError(msg, line);
        return createType(TYPE_ERROR);
    }
    return sym->type;
}

// Check assignment
int checkAssignment(Type* lhs, Type* rhs, int line) {
    if(!isCompatible(lhs, rhs)) {
        char msg[100];
        sprintf(msg, "Cannot assign %s to %s", 
                typeToString(rhs), typeToString(lhs));
        semanticError(msg, line);
        return 0;
    }
    
    // Warning for narrowing conversion
    if(lhs->kind == TYPE_INT && rhs->kind == TYPE_FLOAT) {
        semanticWarning("Possible loss of precision: float to int", line);
    }
    
    return 1;
}

// Check binary expression
Type* checkBinaryExpr(Type* left, Type* right, char op, int line) {
    Type* result = getResultType(left, right, op);
    
    if(result->kind == TYPE_ERROR) {
        char msg[100];
        sprintf(msg, "Invalid operands to '%c': %s and %s",
                op, typeToString(left), typeToString(right));
        semanticError(msg, line);
    }
    
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("        Semantic Analysis Demo\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Create global symbol table
    globalTable = createSymbolTable(NULL);
    
    // Test 1: Variable declaration
    printf("Test 1: Variable Declaration\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    checkDeclaration(globalTable, "x", createType(TYPE_INT), 1);
    checkDeclaration(globalTable, "y", createType(TYPE_FLOAT), 2);
    checkDeclaration(globalTable, "x", createType(TYPE_INT), 3);  // Duplicate!
    printf("\n");
    
    // Test 2: Variable usage
    printf("Test 2: Variable Usage\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    checkVariable(globalTable, "x", 4);
    checkVariable(globalTable, "z", 5);  // Undeclared!
    printf("\n");
    
    // Test 3: Type checking in assignment
    printf("Test 3: Assignment Type Check\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    checkAssignment(createType(TYPE_INT), createType(TYPE_FLOAT), 6);
    checkAssignment(createType(TYPE_INT), createType(TYPE_STRING), 7);  // Error!
    printf("\n");
    
    // Test 4: Expression type checking
    printf("Test 4: Expression Type Check\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    Type* t1 = checkBinaryExpr(createType(TYPE_INT), createType(TYPE_INT), '+', 8);
    printf("int + int = %s\n", typeToString(t1));
    
    Type* t2 = checkBinaryExpr(createType(TYPE_INT), createType(TYPE_FLOAT), '*', 9);
    printf("int * float = %s\n", typeToString(t2));
    
    Type* t3 = checkBinaryExpr(createType(TYPE_INT), createType(TYPE_STRING), '+', 10);
    printf("int + string = %s\n", typeToString(t3));  // Error!
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("        Semantic Analysis Complete\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
```

## ğŸ“‹ Semantic Analysis Checklist

| Check | Description | Example Error |
|-------|-------------|---------------|
| Type Check | Type compatibility | `int x = "hello"` |
| Undeclared | Variable exists | `y = 10` (y not declared) |
| Redeclared | No duplicate | `int x; int x;` |
| Scope | Proper scope | Using out-of-scope var |
| Function | Correct call | `add(1)` (needs 2 args) |
| Return | Type matches | `int func() { return "hi"; }` |
| Array | Valid index | `arr[10]` (size is 5) |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦Ÿà¦¾à¦‡à¦ª à¦šà§‡à¦•à¦¿à¦‚](à§¦à§¨-à¦Ÿà¦¾à¦‡à¦ª-à¦šà§‡à¦•à¦¿à¦‚.md)
