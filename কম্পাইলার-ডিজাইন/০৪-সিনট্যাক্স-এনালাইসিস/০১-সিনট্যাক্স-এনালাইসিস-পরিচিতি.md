# ğŸ“– à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸ à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿ (Introduction to Syntax Analysis)

## à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸ à¦•à§€?

**à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸** (Syntax Analysis) à¦¬à¦¾ **à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚** (Parsing) à¦¹à¦²à§‹ à¦•à¦®à§à¦ªà¦¾à¦‡à¦²à¦¾à¦°à§‡à¦° à¦¦à§à¦¬à¦¿à¦¤à§€à¦¯à¦¼ à¦§à¦¾à¦ªà¥¤ à¦à¦Ÿà¦¿ Token Stream-à¦•à§‡ à¦¬à¦¿à¦¶à§à¦²à§‡à¦·à¦£ à¦•à¦°à§‡ **Parse Tree** à¦¤à§ˆà¦°à¦¿ à¦•à¦°à§‡ à¦à¦¬à¦‚ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à§‡à¦° à¦¬à§à¦¯à¦¾à¦•à¦°à¦£à¦—à¦¤ à¦¸à¦ à¦¿à¦•à¦¤à¦¾ à¦¯à¦¾à¦šà¦¾à¦‡ à¦•à¦°à§‡à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Token Stream â”€â”€â–¶ [Parser] â”€â”€â–¶ Parse Tree                       â”‚
â”‚                                                                 â”‚
â”‚  [int][x][=][5][+][3][;] â”€â”€â–¶      =                            â”‚
â”‚                                  / \                            â”‚
â”‚                                 x   +                           â”‚
â”‚                                    / \                          â”‚
â”‚                                   5   3                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š à¦®à§‚à¦² à¦ªà¦°à¦¿à¦­à¦¾à¦·à¦¾

### à§§. Grammar (à¦¬à§à¦¯à¦¾à¦•à¦°à¦£)
à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à¦¿à¦‚ à¦­à¦¾à¦·à¦¾à¦° à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦¸à¦‚à¦œà§à¦à¦¾à¦¯à¦¼à¦¿à¦¤ à¦•à¦°à¦¾à¦° à¦¨à¦¿à¦¯à¦¼à¦®à¦¾à¦¬à¦²à§€à¥¤

### à§¨. Context-Free Grammar (CFG)
```
G = (V, T, P, S)

V = Non-terminals (Variables)
T = Terminals (Tokens)
P = Production Rules
S = Start Symbol
```

### à§©. Parse Tree
à¦¬à§à¦¯à¦¾à¦•à¦°à¦£ à¦…à¦¨à§à¦¯à¦¾à¦¯à¦¼à§€ à¦¤à§ˆà¦°à¦¿ Tree structureà¥¤

### à§ª. Derivation
Start symbol à¦¥à§‡à¦•à§‡ string à¦‰à§à¦ªà¦¨à§à¦¨ à¦•à¦°à¦¾à¦° à¦ªà§à¦°à¦•à§à¦°à¦¿à¦¯à¦¼à¦¾à¥¤

## ğŸ“ Context-Free Grammar (CFG)

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£: Simple Expression Grammar
```
E â†’ E + T | E - T | T
T â†’ T * F | T / F | F
F â†’ ( E ) | id | num
```

### CFG Components:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  Non-terminals (V): E, T, F                                     â”‚
â”‚  Terminals (T):     +, -, *, /, (, ), id, num                  â”‚
â”‚  Start Symbol (S):  E                                           â”‚
â”‚  Productions (P):   E â†’ E + T | E - T | T                       â”‚
â”‚                     T â†’ T * F | T / F | F                       â”‚
â”‚                     F â†’ ( E ) | id | num                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸŒ³ Parse Tree

### à¦¸à§‹à¦°à§à¦¸: `id + id * id`

### Parse Tree:
```
                    E
                   /|\
                  E + T
                  |  /|\
                  T T * F
                  |  |   |
                  F  F   id
                  |  |
                 id id
```

### Parse Tree à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯:
- **Root**: Start symbol
- **Internal Nodes**: Non-terminals
- **Leaves**: Terminals
- **In-order Traversal**: Original string

## ğŸ”„ Derivation (à¦…à¦¬à¦¤à¦°à¦£)

### Leftmost Derivation
à¦¸à¦¬à¦¸à¦®à¦¯à¦¼ à¦¬à¦¾à¦®à¦¦à¦¿à¦•à§‡à¦° non-terminal à¦ªà§à¦°à¦¥à¦®à§‡ replace à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
E â‡’ E + T
  â‡’ T + T
  â‡’ F + T
  â‡’ id + T
  â‡’ id + T * F
  â‡’ id + F * F
  â‡’ id + id * F
  â‡’ id + id * id
```

### Rightmost Derivation
à¦¸à¦¬à¦¸à¦®à¦¯à¦¼ à¦¡à¦¾à¦¨à¦¦à¦¿à¦•à§‡à¦° non-terminal à¦ªà§à¦°à¦¥à¦®à§‡ replace à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
E â‡’ E + T
  â‡’ E + T * F
  â‡’ E + T * id
  â‡’ E + F * id
  â‡’ E + id * id
  â‡’ T + id * id
  â‡’ F + id * id
  â‡’ id + id * id
```

## ğŸ”€ Ambiguous Grammar

### à¦à¦•à¦Ÿà¦¿ Grammar **Ambiguous** à¦¹à¦¯à¦¼ à¦¯à¦¦à¦¿ à¦•à§‹à¦¨à§‹ string-à¦à¦° à¦œà¦¨à§à¦¯ à¦à¦•à¦¾à¦§à¦¿à¦• Parse Tree à¦¥à¦¾à¦•à§‡à¥¤

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£: Dangling Else Problem
```
stmt â†’ if expr then stmt
     | if expr then stmt else stmt
     | other

Input: if E1 then if E2 then S1 else S2
```

### à¦¦à§à¦Ÿà¦¿ à¦¸à¦®à§à¦­à¦¾à¦¬à§à¦¯ Parse Tree:
```
Parse Tree 1:                    Parse Tree 2:
    if                               if
   /|\                              /|\
  E1 then if                       E1 then if else S2
         /|\                             /|
        E2 then S1 else S2              E2 then S1
        
(else matches inner if)          (else matches outer if)
```

### à¦¸à¦®à¦¾à¦§à¦¾à¦¨:
```
stmt â†’ matched_stmt | unmatched_stmt

matched_stmt â†’ if expr then matched_stmt else matched_stmt
             | other

unmatched_stmt â†’ if expr then stmt
               | if expr then matched_stmt else unmatched_stmt
```

## ğŸ“‹ Operator Precedence à¦“ Associativity

### Precedence (à¦…à¦—à§à¦°à¦¾à¦§à¦¿à¦•à¦¾à¦°)
```
* à¦à¦¬à¦‚ / à¦à¦° precedence à¦¬à§‡à¦¶à¦¿ + à¦à¦¬à¦‚ - à¦¥à§‡à¦•à§‡

2 + 3 * 4 = 2 + (3 * 4) = 14
      à¦¨à¦¾: (2 + 3) * 4 = 20
```

### Associativity (à¦¸à¦‚à¦¯à§à¦•à§à¦¤à¦¤à¦¾)
```
Left Associative:  2 - 3 - 4 = (2 - 3) - 4 = -5
Right Associative: 2 ^ 3 ^ 4 = 2 ^ (3 ^ 4)
```

### Grammar-à¦ Precedence à¦¬à¦œà¦¾à¦¯à¦¼ à¦°à¦¾à¦–à¦¾:
```
// Lower precedence = closer to start symbol
E â†’ E + T | E - T | T      // + - (lowest)
T â†’ T * F | T / F | F      // * / (higher)
F â†’ G ^ F | G              // ^ right associative (highest)
G â†’ ( E ) | id | num
```

## ğŸ”§ Parser-à¦à¦° à¦ªà§à¦°à¦•à¦¾à¦°à¦­à§‡à¦¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       Parser Types                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚                     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                         â”‚
â”‚                     â”‚     Parser      â”‚                         â”‚
â”‚                     â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                              â”‚                                  â”‚
â”‚            â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                â”‚
â”‚            â”‚                                   â”‚                â”‚
â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”       â”‚
â”‚   â”‚   Top-Down      â”‚               â”‚   Bottom-Up      â”‚       â”‚
â”‚   â”‚   (à¦‰à¦ªà¦° à¦¥à§‡à¦•à§‡)    â”‚               â”‚   (à¦¨à¦¿à¦š à¦¥à§‡à¦•à§‡)     â”‚       â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜       â”‚
â”‚            â”‚                                   â”‚                â”‚
â”‚      â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                      â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”          â”‚
â”‚      â”‚           â”‚                      â”‚           â”‚          â”‚
â”‚   Recursive   LL(1)                  LR(0)   LALR(1)           â”‚
â”‚   Descent    Parser                  SLR(1)  LR(1)             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Top-Down Parsing
- Root à¦¥à§‡à¦•à§‡ Leaves-à¦à¦° à¦¦à¦¿à¦•à§‡ Parse Tree à¦¤à§ˆà¦°à¦¿
- Leftmost Derivation à¦…à¦¨à§à¦¸à¦°à¦£ à¦•à¦°à§‡
- à¦‰à¦¦à¦¾à¦¹à¦°à¦£: Recursive Descent, LL(1)

### Bottom-Up Parsing
- Leaves à¦¥à§‡à¦•à§‡ Root-à¦à¦° à¦¦à¦¿à¦•à§‡ Parse Tree à¦¤à§ˆà¦°à¦¿
- Rightmost Derivation-à¦à¦° reverse
- à¦‰à¦¦à¦¾à¦¹à¦°à¦£: LR(0), SLR(1), LALR(1), LR(1)

## ğŸ“Š Parser à¦¤à§à¦²à¦¨à¦¾

| à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯ | Top-Down | Bottom-Up |
|----------|----------|-----------|
| Direction | Root â†’ Leaves | Leaves â†’ Root |
| Derivation | Leftmost | Reverse Rightmost |
| Power | à¦•à¦® à¦¶à¦•à§à¦¤à¦¿à¦¶à¦¾à¦²à§€ | à¦¬à§‡à¦¶à¦¿ à¦¶à¦•à§à¦¤à¦¿à¦¶à¦¾à¦²à§€ |
| Implementation | à¦¸à¦¹à¦œ | à¦œà¦Ÿà¦¿à¦² |
| Left Recursion | Handle à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‡ à¦¨à¦¾ | Handle à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‡ |
| Error Recovery | à¦­à¦¾à¦²à§‹ | à¦•à¦ à¦¿à¦¨ |
| Tools | Hand-written | Yacc, Bison |

## ğŸ’» à¦¸à¦¹à¦œ Recursive Descent Parser

```c
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>

char* input;
int pos = 0;

char peek() { return input[pos]; }
char advance() { return input[pos++]; }

void error(char* msg) {
    printf("Error: %s at position %d\n", msg, pos);
    exit(1);
}

void match(char expected) {
    if(peek() == expected) advance();
    else {
        char msg[50];
        sprintf(msg, "Expected '%c'", expected);
        error(msg);
    }
}

int expr();
int term();
int factor();

// E â†’ T (('+' | '-') T)*
int expr() {
    int result = term();
    
    while(peek() == '+' || peek() == '-') {
        char op = advance();
        int right = term();
        if(op == '+') result += right;
        else result -= right;
    }
    
    return result;
}

// T â†’ F (('*' | '/') F)*
int term() {
    int result = factor();
    
    while(peek() == '*' || peek() == '/') {
        char op = advance();
        int right = factor();
        if(op == '*') result *= right;
        else result /= right;
    }
    
    return result;
}

// F â†’ '(' E ')' | number
int factor() {
    if(peek() == '(') {
        advance(); // consume '('
        int result = expr();
        match(')');
        return result;
    }
    else if(isdigit(peek())) {
        int num = 0;
        while(isdigit(peek())) {
            num = num * 10 + (advance() - '0');
        }
        return num;
    }
    else {
        error("Expected number or '('");
        return 0;
    }
}

int main() {
    input = "2+3*4";
    printf("Input: %s\n", input);
    printf("Result: %d\n", expr());  // Output: 14
    
    pos = 0;
    input = "(2+3)*4";
    printf("\nInput: %s\n", input);
    printf("Result: %d\n", expr());  // Output: 20
    
    return 0;
}
```

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [Context-Free Grammar](à§¦à§¨-à¦•à¦¨à¦Ÿà§‡à¦•à§à¦¸à¦Ÿ-à¦«à§à¦°à¦¿-à¦—à§à¦°à¦¾à¦®à¦¾à¦°.md)
