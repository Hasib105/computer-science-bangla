# ğŸ¯ FIRST à¦à¦¬à¦‚ FOLLOW Sets

## à¦•à§‡à¦¨ FIRST à¦à¦¬à¦‚ FOLLOW à¦ªà§à¦°à¦¯à¦¼à§‹à¦œà¦¨?

Predictive Parsing-à¦ (LL(1) Parser) à¦ªà¦°à¦¬à¦°à§à¦¤à§€ token à¦¦à§‡à¦–à§‡ à¦¸à¦¿à¦¦à§à¦§à¦¾à¦¨à§à¦¤ à¦¨à¦¿à¦¤à§‡ à¦¹à¦¯à¦¼ à¦•à§‹à¦¨ production à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡à¥¤ FIRST à¦à¦¬à¦‚ FOLLOW sets à¦à¦‡ à¦¸à¦¿à¦¦à§à¦§à¦¾à¦¨à§à¦¤ à¦¨à¦¿à¦¤à§‡ à¦¸à¦¾à¦¹à¦¾à¦¯à§à¦¯ à¦•à¦°à§‡à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                FIRST à¦“ FOLLOW-à¦à¦° à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦°                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Input: id + id * id                                            â”‚
â”‚         â†‘                                                       â”‚
â”‚      current token                                              â”‚
â”‚                                                                 â”‚
â”‚  Parser sees 'id', checks:                                      â”‚
â”‚  - Which production to use for E?                               â”‚
â”‚  - Use FIRST(production_body) to decide                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š FIRST Set

### à¦¸à¦‚à¦œà§à¦à¦¾:
**FIRST(Î±)** = Î± à¦¥à§‡à¦•à§‡ derive à¦•à¦°à¦¾ à¦¸à¦®à§à¦­à¦¬ à¦à¦®à¦¨ à¦¸à¦¬ strings-à¦à¦° à¦ªà§à¦°à¦¥à¦® terminal-à¦à¦° setà¥¤

### Rules:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FIRST Set Rules                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Rule 1: Terminal                                               â”‚
â”‚          FIRST(a) = {a}  for any terminal a                     â”‚
â”‚                                                                 â”‚
â”‚  Rule 2: Epsilon                                                â”‚
â”‚          If A â†’ Îµ is a production                               â”‚
â”‚          then Îµ âˆˆ FIRST(A)                                      â”‚
â”‚                                                                 â”‚
â”‚  Rule 3: Non-terminal                                           â”‚
â”‚          If A â†’ Yâ‚Yâ‚‚...Yâ‚– is a production:                      â”‚
â”‚          - Add FIRST(Yâ‚) - {Îµ} to FIRST(A)                      â”‚
â”‚          - If Îµ âˆˆ FIRST(Yâ‚), add FIRST(Yâ‚‚) - {Îµ}                â”‚
â”‚          - Continue until Yáµ¢ where Îµ âˆ‰ FIRST(Yáµ¢)                â”‚
â”‚          - If Îµ âˆˆ FIRST(Yáµ¢) for all i, add Îµ to FIRST(A)       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£ à§§:

```
Grammar:
E  â†’ TE'
E' â†’ +TE' | Îµ
T  â†’ FT'
T' â†’ *FT' | Îµ
F  â†’ (E) | id
```

### Step-by-Step Calculation:

```
Step 1: Start with productions that begin with terminals

FIRST(F):
  F â†’ (E)  : '(' âˆˆ FIRST(F)
  F â†’ id   : 'id' âˆˆ FIRST(F)
  FIRST(F) = {(, id}

Step 2: T â†’ FT'
  FIRST(T) = FIRST(F) - {Îµ} = {(, id}
  (F à¦¤à§‡ Îµ à¦¨à§‡à¦‡, à¦¤à¦¾à¦‡ T' à¦¦à§‡à¦–à¦¤à§‡ à¦¹à¦¬à§‡ à¦¨à¦¾)

Step 3: T' â†’ *FT' | Îµ
  FIRST(T') = {*, Îµ}

Step 4: E â†’ TE'
  FIRST(E) = FIRST(T) = {(, id}

Step 5: E' â†’ +TE' | Îµ
  FIRST(E') = {+, Îµ}
```

### Final FIRST Sets:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Symbol   â”‚    FIRST        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    E     â”‚   { (, id }     â”‚
â”‚    E'    â”‚   { +, Îµ }      â”‚
â”‚    T     â”‚   { (, id }     â”‚
â”‚    T'    â”‚   { *, Îµ }      â”‚
â”‚    F     â”‚   { (, id }     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“ FOLLOW Set

### à¦¸à¦‚à¦œà§à¦à¦¾:
**FOLLOW(A)** = A-à¦à¦° à¦ªà¦°à§‡ immediately à¦†à¦¸à¦¤à§‡ à¦ªà¦¾à¦°à§‡ à¦à¦®à¦¨ à¦¸à¦¬ terminal-à¦à¦° setà¥¤

### Rules:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FOLLOW Set Rules                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Rule 1: Start Symbol                                           â”‚
â”‚          $ âˆˆ FOLLOW(S) where S is start symbol                  â”‚
â”‚          ($ = end of input marker)                              â”‚
â”‚                                                                 â”‚
â”‚  Rule 2: Production A â†’ Î±BÎ²                                     â”‚
â”‚          FIRST(Î²) - {Îµ} âŠ† FOLLOW(B)                             â”‚
â”‚                                                                 â”‚
â”‚  Rule 3: Production A â†’ Î±B or A â†’ Î±BÎ² where Îµ âˆˆ FIRST(Î²)       â”‚
â”‚          FOLLOW(A) âŠ† FOLLOW(B)                                  â”‚
â”‚          (à¦¯à¦¾ A-à¦•à§‡ follow à¦•à¦°à§‡, à¦¤à¦¾ B-à¦•à§‡à¦“ follow à¦•à¦°à§‡)             â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£ (à¦à¦•à¦‡ Grammar):

```
Step 1: Start symbol
  $ âˆˆ FOLLOW(E)

Step 2: Scan all productions

E â†’ TE'
  - T is followed by E'
  - FIRST(E') - {Îµ} = {+} âŠ† FOLLOW(T)
  - Îµ âˆˆ FIRST(E'), so FOLLOW(E) âŠ† FOLLOW(T)
  - E' is at end, so FOLLOW(E) âŠ† FOLLOW(E')

E' â†’ +TE'
  - T is followed by E'
  - Same as above for T

T â†’ FT'
  - F is followed by T'
  - FIRST(T') - {Îµ} = {*} âŠ† FOLLOW(F)
  - Îµ âˆˆ FIRST(T'), so FOLLOW(T) âŠ† FOLLOW(F)
  - T' at end, FOLLOW(T) âŠ† FOLLOW(T')

F â†’ (E)
  - E is followed by )
  - ')' âˆˆ FOLLOW(E)
```

### Iterative Calculation:
```
Iteration 1:
  FOLLOW(E) = {$, )}
  FOLLOW(E') = FOLLOW(E) = {$, )}
  FOLLOW(T) = {+} âˆª FOLLOW(E) = {+, $, )}
  FOLLOW(T') = FOLLOW(T) = {+, $, )}
  FOLLOW(F) = {*} âˆª FOLLOW(T) = {*, +, $, )}
```

### Final FOLLOW Sets:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Symbol   â”‚      FOLLOW         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚    E     â”‚   { ), $ }          â”‚
â”‚    E'    â”‚   { ), $ }          â”‚
â”‚    T     â”‚   { +, ), $ }       â”‚
â”‚    T'    â”‚   { +, ), $ }       â”‚
â”‚    F     â”‚   { *, +, ), $ }    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» FIRST/FOLLOW Algorithm Implementation

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h>

#define MAX 20

// Grammar storage
int numProductions = 0;
char productions[MAX][MAX];  // e.g., "E=TE'"

// Symbol sets
char nonTerminals[MAX];
int numNT = 0;
char terminals[MAX];
int numT = 0;

// FIRST and FOLLOW sets
char firstSet[MAX][MAX];
int firstCount[MAX];
char followSet[MAX][MAX];
int followCount[MAX];

bool isNonTerminal(char c) {
    return isupper(c);
}

int getNTIndex(char c) {
    for(int i = 0; i < numNT; i++)
        if(nonTerminals[i] == c) return i;
    return -1;
}

bool inSet(char* set, int count, char c) {
    for(int i = 0; i < count; i++)
        if(set[i] == c) return true;
    return false;
}

void addToSet(char* set, int* count, char c) {
    if(!inSet(set, *count, c)) {
        set[(*count)++] = c;
    }
}

// Calculate FIRST for a symbol
void computeFirst(char symbol) {
    int idx = getNTIndex(symbol);
    if(idx == -1) return;  // Terminal
    
    // Find all productions for this symbol
    for(int i = 0; i < numProductions; i++) {
        if(productions[i][0] != symbol) continue;
        
        char* rhs = productions[i] + 2;  // Skip "X="
        
        for(int j = 0; rhs[j] != '\0'; j++) {
            char current = rhs[j];
            
            if(!isNonTerminal(current)) {
                // Terminal - add to FIRST
                addToSet(firstSet[idx], &firstCount[idx], current);
                break;
            } else {
                // Non-terminal - add its FIRST (except epsilon)
                int ntIdx = getNTIndex(current);
                computeFirst(current);  // Recursive
                
                bool hasEpsilon = false;
                for(int k = 0; k < firstCount[ntIdx]; k++) {
                    if(firstSet[ntIdx][k] == '#') {  // # = epsilon
                        hasEpsilon = true;
                    } else {
                        addToSet(firstSet[idx], &firstCount[idx], 
                                firstSet[ntIdx][k]);
                    }
                }
                
                if(!hasEpsilon) break;
                
                // If last symbol and has epsilon
                if(rhs[j+1] == '\0' && hasEpsilon) {
                    addToSet(firstSet[idx], &firstCount[idx], '#');
                }
            }
        }
    }
}

void computeFollow() {
    // Add $ to FOLLOW of start symbol
    addToSet(followSet[0], &followCount[0], '$');
    
    bool changed = true;
    while(changed) {
        changed = false;
        
        for(int i = 0; i < numProductions; i++) {
            char lhs = productions[i][0];
            char* rhs = productions[i] + 2;
            int lhsIdx = getNTIndex(lhs);
            
            for(int j = 0; rhs[j] != '\0'; j++) {
                if(!isNonTerminal(rhs[j])) continue;
                
                int ntIdx = getNTIndex(rhs[j]);
                
                // Look at what follows this non-terminal
                if(rhs[j+1] == '\0') {
                    // At end - add FOLLOW(LHS)
                    for(int k = 0; k < followCount[lhsIdx]; k++) {
                        int oldCount = followCount[ntIdx];
                        addToSet(followSet[ntIdx], &followCount[ntIdx],
                                followSet[lhsIdx][k]);
                        if(followCount[ntIdx] > oldCount) changed = true;
                    }
                } else {
                    // Add FIRST of following
                    char next = rhs[j+1];
                    
                    if(!isNonTerminal(next)) {
                        int oldCount = followCount[ntIdx];
                        addToSet(followSet[ntIdx], &followCount[ntIdx], next);
                        if(followCount[ntIdx] > oldCount) changed = true;
                    } else {
                        int nextIdx = getNTIndex(next);
                        bool hasEpsilon = false;
                        
                        for(int k = 0; k < firstCount[nextIdx]; k++) {
                            if(firstSet[nextIdx][k] == '#') {
                                hasEpsilon = true;
                            } else {
                                int oldCount = followCount[ntIdx];
                                addToSet(followSet[ntIdx], &followCount[ntIdx],
                                        firstSet[nextIdx][k]);
                                if(followCount[ntIdx] > oldCount) changed = true;
                            }
                        }
                        
                        if(hasEpsilon) {
                            for(int k = 0; k < followCount[lhsIdx]; k++) {
                                int oldCount = followCount[ntIdx];
                                addToSet(followSet[ntIdx], &followCount[ntIdx],
                                        followSet[lhsIdx][k]);
                                if(followCount[ntIdx] > oldCount) changed = true;
                            }
                        }
                    }
                }
            }
        }
    }
}

void printSets() {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘          FIRST Sets                â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    
    for(int i = 0; i < numNT; i++) {
        printf("â•‘  FIRST(%c) = { ", nonTerminals[i]);
        for(int j = 0; j < firstCount[i]; j++) {
            if(j > 0) printf(", ");
            if(firstSet[i][j] == '#') printf("Îµ");
            else printf("%c", firstSet[i][j]);
        }
        printf(" }\n");
    }
    
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    printf("â•‘          FOLLOW Sets               â•‘\n");
    printf("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£\n");
    
    for(int i = 0; i < numNT; i++) {
        printf("â•‘  FOLLOW(%c) = { ", nonTerminals[i]);
        for(int j = 0; j < followCount[i]; j++) {
            if(j > 0) printf(", ");
            printf("%c", followSet[i][j]);
        }
        printf(" }\n");
    }
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
}

int main() {
    // Example grammar: E â†’ T+E | T, T â†’ i
    strcpy(productions[0], "E=T+E");
    strcpy(productions[1], "E=T");
    strcpy(productions[2], "T=i");
    numProductions = 3;
    
    nonTerminals[0] = 'E';
    nonTerminals[1] = 'T';
    numNT = 2;
    
    printf("Grammar:\n");
    printf("E â†’ T+E | T\n");
    printf("T â†’ i\n");
    
    // Compute FIRST
    for(int i = 0; i < numNT; i++) {
        computeFirst(nonTerminals[i]);
    }
    
    // Compute FOLLOW
    computeFollow();
    
    printSets();
    
    return 0;
}
```

## ğŸ“‹ LL(1) Parsing Table Construction

```
For each production A â†’ Î±:
1. For each terminal a in FIRST(Î±):
   Add A â†’ Î± to M[A, a]
   
2. If Îµ âˆˆ FIRST(Î±):
   For each terminal b in FOLLOW(A):
   Add A â†’ Î± to M[A, b]
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£ Parsing Table:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚        â”‚     id      â”‚      +      â”‚   *   â”‚   (   â”‚   )   â”‚   $   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   E    â”‚   E â†’ TE'   â”‚             â”‚       â”‚E â†’ TE'â”‚       â”‚       â”‚
â”‚   E'   â”‚             â”‚   E' â†’ +TE' â”‚       â”‚       â”‚E' â†’ Îµ â”‚E' â†’ Îµ â”‚
â”‚   T    â”‚   T â†’ FT'   â”‚             â”‚       â”‚T â†’ FT'â”‚       â”‚       â”‚
â”‚   T'   â”‚             â”‚   T' â†’ Îµ    â”‚T'â†’*FT'â”‚       â”‚T' â†’ Îµ â”‚T' â†’ Îµ â”‚
â”‚   F    â”‚   F â†’ id    â”‚             â”‚       â”‚F â†’ (E)â”‚       â”‚       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
```

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [Top-Down Parsing](../à§¦à§«-à¦ªà¦¾à¦°à§à¦¸à¦¾à¦°/à§¦à§§-à¦Ÿà¦ª-à¦¡à¦¾à¦‰à¦¨-à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚.md)
