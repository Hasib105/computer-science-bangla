# ğŸ“š Context-Free Grammar (CFG)

## CFG à¦•à§€?

**Context-Free Grammar (CFG)** à¦¹à¦²à§‹ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à¦¿à¦‚ à¦­à¦¾à¦·à¦¾à¦° à¦¸à¦¿à¦¨à¦Ÿà§à¦¯à¦¾à¦•à§à¦¸ à¦¸à¦‚à¦œà§à¦à¦¾à¦¯à¦¼à¦¿à¦¤ à¦•à¦°à¦¾à¦° à¦œà¦¨à§à¦¯ à¦¬à§à¦¯à¦¬à¦¹à§ƒà¦¤ à¦à¦•à¦Ÿà¦¿ à¦«à¦°à§à¦®à¦¾à¦² à¦¸à¦¿à¦¸à§à¦Ÿà§‡à¦®à¥¤ à¦à¦Ÿà¦¿ Regular Expression-à¦à¦° à¦šà§‡à¦¯à¦¼à§‡ à¦¶à¦•à§à¦¤à¦¿à¦¶à¦¾à¦²à§€ à¦à¦¬à¦‚ nested structure à¦¬à¦°à§à¦£à¦¨à¦¾ à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‡à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     Context-Free Grammar                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  G = (V, T, P, S)                                               â”‚
â”‚                                                                 â”‚
â”‚  V = Variables/Non-terminals                                    â”‚
â”‚  T = Terminals                                                  â”‚
â”‚  P = Production Rules                                           â”‚
â”‚  S = Start Symbol                                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š CFG-à¦à¦° à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨

### à§§. Non-terminals (V)
```
à¦¬à§à¦¯à¦¾à¦•à¦°à¦£à§‡à¦° variable à¦¯à¦¾ replace à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡

à¦‰à¦¦à¦¾à¦¹à¦°à¦£: E, T, F, stmt, expr, program
à¦¬à¦¡à¦¼ à¦¹à¦¾à¦¤à§‡à¦° à¦…à¦•à§à¦·à¦° à¦¬à¦¾ <> à¦¦à¦¿à¦¯à¦¼à§‡ à¦²à§‡à¦–à¦¾ à¦¹à¦¯à¦¼
<expression>, <statement>
```

### à§¨. Terminals (T)
```
à¦­à¦¾à¦·à¦¾à¦° actual symbols/tokens

à¦‰à¦¦à¦¾à¦¹à¦°à¦£: +, -, *, /, id, num, if, while, (, )
à¦›à§‹à¦Ÿ à¦¹à¦¾à¦¤à§‡à¦° à¦…à¦•à§à¦·à¦° à¦¬à¦¾ quoted strings
```

### à§©. Production Rules (P)
```
Non-terminal-à¦•à§‡ à¦•à§€à¦­à¦¾à¦¬à§‡ replace à¦•à¦°à¦¤à§‡ à¦¹à¦¬à§‡

Format: A â†’ Î±
A = Non-terminal
Î± = String of terminals à¦à¦¬à¦‚/à¦…à¦¥à¦¬à¦¾ non-terminals

à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
E â†’ E + T
E â†’ T
T â†’ id
```

### à§ª. Start Symbol (S)
```
à¦ªà§à¦°à¦¥à¦® non-terminal à¦¯à§‡à¦–à¦¾à¦¨ à¦¥à§‡à¦•à§‡ derivation à¦¶à§à¦°à§ à¦¹à¦¯à¦¼

à¦¸à¦¾à¦§à¦¾à¦°à¦£à¦¤ à¦ªà§à¦°à¦¥à¦® production-à¦à¦° à¦¬à¦¾à¦®à¦¦à¦¿à¦•à§‡à¦° non-terminal
```

## ğŸ“ BNF (Backus-Naur Form)

### CFG à¦²à§‡à¦–à¦¾à¦° Standard Notation:

```
<expr> ::= <term> | <expr> + <term> | <expr> - <term>
<term> ::= <factor> | <term> * <factor> | <term> / <factor>
<factor> ::= ( <expr> ) | <identifier> | <number>
```

### EBNF (Extended BNF):
```
expr = term { ("+" | "-") term }
term = factor { ("*" | "/") factor }
factor = "(" expr ")" | identifier | number

{ } = à¦¶à§‚à¦¨à§à¦¯ à¦¬à¦¾ à¦¤à¦¾à¦° à¦¬à§‡à¦¶à¦¿à¦¬à¦¾à¦°
[ ] = à¦à¦šà§à¦›à¦¿à¦• (à¦¶à§‚à¦¨à§à¦¯ à¦¬à¦¾ à¦à¦•à¦¬à¦¾à¦°)
( ) = à¦—à§à¦°à§à¦ªà¦¿à¦‚
| = à¦¬à¦¿à¦•à¦²à§à¦ª
```

## ğŸ” à¦¸à¦®à§à¦ªà§‚à¦°à§à¦£ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à¦¿à¦‚ à¦­à¦¾à¦·à¦¾à¦° Grammar

### Simple C-Like Language:
```
program     â†’ declaration_list

declaration_list â†’ declaration declaration_list
                 | Îµ

declaration â†’ var_declaration
            | fun_declaration

var_declaration â†’ type_specifier ID ;
                | type_specifier ID [ NUM ] ;

type_specifier â†’ int | float | void

fun_declaration â†’ type_specifier ID ( params ) compound_stmt

params â†’ param_list | void

param_list â†’ param_list , param | param

param â†’ type_specifier ID
      | type_specifier ID [ ]

compound_stmt â†’ { local_declarations statement_list }

local_declarations â†’ local_declarations var_declaration
                   | Îµ

statement_list â†’ statement_list statement
               | Îµ

statement â†’ expression_stmt
          | compound_stmt
          | selection_stmt
          | iteration_stmt
          | return_stmt

expression_stmt â†’ expression ; | ;

selection_stmt â†’ if ( expression ) statement
               | if ( expression ) statement else statement

iteration_stmt â†’ while ( expression ) statement

return_stmt â†’ return ; | return expression ;

expression â†’ var = expression
           | simple_expression

var â†’ ID | ID [ expression ]

simple_expression â†’ additive_expression relop additive_expression
                  | additive_expression

relop â†’ <= | < | > | >= | == | !=

additive_expression â†’ additive_expression addop term
                    | term

addop â†’ + | -

term â†’ term mulop factor
     | factor

mulop â†’ * | /

factor â†’ ( expression )
       | var
       | call
       | NUM

call â†’ ID ( args )

args â†’ arg_list | Îµ

arg_list â†’ arg_list , expression
         | expression
```

## ğŸ”„ Derivation à¦‰à¦¦à¦¾à¦¹à¦°à¦£

### Grammar:
```
E â†’ E + T | T
T â†’ T * F | F
F â†’ ( E ) | id
```

### String: `id + id * id`

### Leftmost Derivation:
```
E â‡’ E + T                    (E â†’ E + T)
  â‡’ T + T                    (E â†’ T)
  â‡’ F + T                    (T â†’ F)
  â‡’ id + T                   (F â†’ id)
  â‡’ id + T * F               (T â†’ T * F)
  â‡’ id + F * F               (T â†’ F)
  â‡’ id + id * F              (F â†’ id)
  â‡’ id + id * id             (F â†’ id)
```

### Parse Tree:
```
              E
            / | \
           E  +  T
           |    /|\
           T   T * F
           |   |   |
           F   F   id
           |   |
          id  id
```

## âš ï¸ Grammar Transformations

### à§§. Left Recursion Elimination

**à¦¸à¦®à¦¸à§à¦¯à¦¾:** `A â†’ AÎ± | Î²` (Left Recursive)

Top-down parser à¦à¦Ÿà¦¿ handle à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‡ à¦¨à¦¾ (infinite loop)

**à¦¸à¦®à¦¾à¦§à¦¾à¦¨:**
```
A â†’ AÎ± | Î²
    â†“
A â†’ Î²A'
A' â†’ Î±A' | Îµ
```

**à¦‰à¦¦à¦¾à¦¹à¦°à¦£:**
```
Before:                  After:
E â†’ E + T | T           E â†’ TE'
                        E' â†’ +TE' | Îµ
```

### à§¨. Left Factoring

**à¦¸à¦®à¦¸à§à¦¯à¦¾:** `A â†’ Î±Î²â‚ | Î±Î²â‚‚` (Common prefix)

**à¦¸à¦®à¦¾à¦§à¦¾à¦¨:**
```
A â†’ Î±Î²â‚ | Î±Î²â‚‚
    â†“
A â†’ Î±A'
A' â†’ Î²â‚ | Î²â‚‚
```

**à¦‰à¦¦à¦¾à¦¹à¦°à¦£:**
```
Before:                  After:
stmt â†’ if E then S       stmt â†’ if E then S stmt'
     | if E then S else S    stmt' â†’ else S | Îµ
```

## ğŸ“ FIRST à¦à¦¬à¦‚ FOLLOW Sets

### FIRST(Î±)
```
Î± à¦¥à§‡à¦•à§‡ derive à¦•à¦°à¦¾ à¦¯à¦¾à¦¯à¦¼ à¦à¦®à¦¨ à¦¸à¦¬ terminal à¦¯à¦¾ à¦ªà§à¦°à¦¥à¦®à§‡ à¦†à¦¸à¦¤à§‡ à¦ªà¦¾à¦°à§‡

Rules:
1. FIRST(a) = {a} for terminal a
2. If A â†’ Îµ, then Îµ âˆˆ FIRST(A)
3. If A â†’ BÎ±, then FIRST(B) - {Îµ} âŠ† FIRST(A)
   If Îµ âˆˆ FIRST(B), then FIRST(Î±) âŠ† FIRST(A)
```

### FOLLOW(A)
```
A-à¦à¦° à¦ªà¦°à§‡ à¦•à§€ terminal à¦†à¦¸à¦¤à§‡ à¦ªà¦¾à¦°à§‡

Rules:
1. $ âˆˆ FOLLOW(S) for start symbol S
2. If A â†’ Î±BÎ², then FIRST(Î²) - {Îµ} âŠ† FOLLOW(B)
3. If A â†’ Î±B, or A â†’ Î±BÎ² where Îµ âˆˆ FIRST(Î²),
   then FOLLOW(A) âŠ† FOLLOW(B)
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
```
Grammar:
E â†’ TE'
E' â†’ +TE' | Îµ
T â†’ FT'
T' â†’ *FT' | Îµ
F â†’ (E) | id

FIRST Sets:
FIRST(E) = FIRST(T) = FIRST(F) = {(, id}
FIRST(E') = {+, Îµ}
FIRST(T') = {*, Îµ}

FOLLOW Sets:
FOLLOW(E) = {), $}
FOLLOW(E') = {), $}
FOLLOW(T) = {+, ), $}
FOLLOW(T') = {+, ), $}
FOLLOW(F) = {*, +, ), $}
```

## ğŸ’» FIRST/FOLLOW Calculator

```c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define MAX_SYMBOLS 20
#define MAX_PROD 10

// Simple grammar representation
char nonTerminals[] = {'E', 'T', 'F'};
int numNT = 3;

char terminals[] = {'+', '*', '(', ')', 'i'};  // 'i' for 'id'
int numT = 5;

// Productions: Eâ†’E+T|T, Tâ†’T*F|F, Fâ†’(E)|id
// Simplified for demo

bool first[MAX_SYMBOLS][MAX_SYMBOLS];  // first[NT][terminal]
bool follow[MAX_SYMBOLS][MAX_SYMBOLS];

int getNTIndex(char c) {
    for(int i = 0; i < numNT; i++)
        if(nonTerminals[i] == c) return i;
    return -1;
}

int getTIndex(char c) {
    for(int i = 0; i < numT; i++)
        if(terminals[i] == c) return i;
    return -1;
}

void computeFirst() {
    // F â†’ (E) | id
    // FIRST(F) = {(, id}
    first[getNTIndex('F')][getTIndex('(')] = true;
    first[getNTIndex('F')][getTIndex('i')] = true;
    
    // T â†’ T*F | F
    // FIRST(T) = FIRST(F) = {(, id}
    first[getNTIndex('T')][getTIndex('(')] = true;
    first[getNTIndex('T')][getTIndex('i')] = true;
    
    // E â†’ E+T | T
    // FIRST(E) = FIRST(T) = {(, id}
    first[getNTIndex('E')][getTIndex('(')] = true;
    first[getNTIndex('E')][getTIndex('i')] = true;
}

void printFirst() {
    printf("\nFIRST Sets:\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    for(int i = 0; i < numNT; i++) {
        printf("FIRST(%c) = { ", nonTerminals[i]);
        bool hasElement = false;
        for(int j = 0; j < numT; j++) {
            if(first[i][j]) {
                if(hasElement) printf(", ");
                printf("%c", terminals[j]);
                hasElement = true;
            }
        }
        printf(" }\n");
    }
}

int main() {
    memset(first, false, sizeof(first));
    memset(follow, false, sizeof(follow));
    
    computeFirst();
    printFirst();
    
    return 0;
}
```

## ğŸ“‹ CFG Classification

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Grammar Hierarchy                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚       â”‚          All CFG                    â”‚                   â”‚
â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                   â”‚
â”‚       â”‚  â”‚      Unambiguous CFG          â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚        LR(k)            â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚     LALR(1)       â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”‚   SLR(1)    â”‚  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”‚  â”‚ LR(0) â”‚  â”‚  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚      LL(k)        â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â”‚   LL(1)     â”‚  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚  â”‚                   â”‚
â”‚       â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â”‚                   â”‚
â”‚       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                   â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [FIRST à¦à¦¬à¦‚ FOLLOW](à§¦à§©-à¦«à¦¾à¦°à§à¦¸à§à¦Ÿ-à¦à¦¬à¦‚-à¦«à¦²à§‹.md)
