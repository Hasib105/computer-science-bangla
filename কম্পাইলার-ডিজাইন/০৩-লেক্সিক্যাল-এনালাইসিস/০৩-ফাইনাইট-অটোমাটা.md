# âš™ï¸ à¦«à¦¾à¦‡à¦¨à¦¾à¦‡à¦Ÿ à¦…à¦Ÿà§‹à¦®à¦¾à¦Ÿà¦¾ (Finite Automata)

## à¦«à¦¾à¦‡à¦¨à¦¾à¦‡à¦Ÿ à¦…à¦Ÿà§‹à¦®à¦¾à¦Ÿà¦¾ à¦•à§€?

**à¦«à¦¾à¦‡à¦¨à¦¾à¦‡à¦Ÿ à¦…à¦Ÿà§‹à¦®à¦¾à¦Ÿà¦¾** (FA) à¦¹à¦²à§‹ à¦à¦•à¦Ÿà¦¿ à¦—à¦¾à¦£à¦¿à¦¤à¦¿à¦• à¦®à¦¡à§‡à¦² à¦¯à¦¾ à¦¸à§à¦Ÿà§à¦°à¦¿à¦‚ à¦šà¦¿à¦¨à¦¤à§‡ à¦¬à§à¦¯à¦¬à¦¹à§ƒà¦¤ à¦¹à¦¯à¦¼à¥¤ à¦à¦Ÿà¦¿ Regular Expression-à¦•à§‡ implement à¦•à¦°à¦¤à§‡ à¦¬à§à¦¯à¦¬à¦¹à§ƒà¦¤ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Finite Automaton                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Input String â”€â”€â–¶ [FA Machine] â”€â”€â–¶ Accept / Reject             â”‚
â”‚                                                                 â”‚
â”‚  "ab" â”€â”€â–¶ [DFA for ab] â”€â”€â–¶ Accept âœ“                            â”‚
â”‚  "abc" â”€â”€â–¶ [DFA for ab] â”€â”€â–¶ Reject âœ—                           â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š FA-à¦à¦° à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨

### à§«-à¦Ÿà§à¦ªà¦²: M = (Q, Î£, Î´, qâ‚€, F)

| à¦‰à¦ªà¦¾à¦¦à¦¾à¦¨ | à¦…à¦°à§à¦¥ | à¦‰à¦¦à¦¾à¦¹à¦°à¦£ |
|--------|-----|--------|
| Q | States-à¦à¦° finite set | {qâ‚€, qâ‚, qâ‚‚} |
| Î£ | Input alphabet | {a, b} |
| Î´ | Transition function | Î´(qâ‚€, a) = qâ‚ |
| qâ‚€ | Initial/Start state | qâ‚€ |
| F | Final/Accepting states | {qâ‚‚} |

## ğŸ”€ FA-à¦à¦° à¦ªà§à¦°à¦•à¦¾à¦°à¦­à§‡à¦¦

### à§§. DFA (Deterministic Finite Automata)

```
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ state à¦à¦¬à¦‚ input-à¦à¦° à¦œà¦¨à§à¦¯ exactly à¦à¦•à¦Ÿà¦¿ transition

Î´: Q Ã— Î£ â†’ Q

à¦‰à¦¦à¦¾à¦¹à¦°à¦£: L = {ab}
        a          b
   â—‹ â”€â”€â”€â”€â–¶ â—‹ â”€â”€â”€â”€â–¶ â—
  qâ‚€      qâ‚      qâ‚‚
```

**à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯:**
- à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ state à¦¥à§‡à¦•à§‡ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ symbol-à¦à¦° à¦œà¦¨à§à¦¯ à¦à¦•à¦Ÿà¦¿ transition
- à¦•à§‹à¦¨à§‹ Îµ (empty) transition à¦¨à§‡à¦‡
- Deterministic - à¦ªà¦°à¦¬à¦°à§à¦¤à§€ state à¦¨à¦¿à¦°à§à¦¦à¦¿à¦·à§à¦Ÿ

### à§¨. NFA (Non-deterministic Finite Automata)

```
à¦à¦•à¦‡ input-à¦à¦° à¦œà¦¨à§à¦¯ à¦à¦•à¦¾à¦§à¦¿à¦• transition à¦¥à¦¾à¦•à¦¤à§‡ à¦ªà¦¾à¦°à§‡

Î´: Q Ã— (Î£ âˆª {Îµ}) â†’ P(Q)  (Power set of Q)

à¦‰à¦¦à¦¾à¦¹à¦°à¦£: L = a*b
         a
       â”Œâ”€â”€â”
       â–¼  â”‚    b
   â—‹ â”€â”€â—â”€â”€â”˜ â”€â”€â”€â”€â–¶ â—
  qâ‚€        qâ‚
```

**à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯:**
- à¦à¦•à¦‡ symbol-à¦ à¦à¦•à¦¾à¦§à¦¿à¦• transition
- Îµ (empty) transition à¦¥à¦¾à¦•à¦¤à§‡ à¦ªà¦¾à¦°à§‡
- Non-deterministic - à¦à¦•à¦¾à¦§à¦¿à¦• à¦¸à¦®à§à¦­à¦¾à¦¬à§à¦¯ path

## ğŸ“ DFA à¦‰à¦¦à¦¾à¦¹à¦°à¦£

### L = {strings ending with "ab"}

```
         a           b           a
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                                 â”‚
    â”‚    â”Œâ”€â”€â”€â”                        â–¼
    â”‚    â”‚   â”‚ b      a      b
    â””â”€â”€â”€â–¶â—‹ â”€â”€â”´â”€â”€â”€â–¶ â—‹ â”€â”€â”€â”€â–¶ â—‹ â”€â”€â”€â”€â–¶ â—
        qâ‚€        qâ‚      qâ‚‚      qâ‚ƒ
                   â”‚               â”‚
                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                         a

Transition Table:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚ State  â”‚  a  â”‚  b  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚  qâ‚€    â”‚ qâ‚  â”‚ qâ‚€  â”‚
â”‚  qâ‚    â”‚ qâ‚  â”‚ qâ‚‚  â”‚
â”‚  qâ‚‚*   â”‚ qâ‚  â”‚ qâ‚€  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
* = accepting state
```

### C à¦•à§‹à¦¡à§‡ DFA:

```c
#include <stdio.h>
#include <string.h>

// States
enum State { Q0, Q1, Q2 };

// DFA for strings ending with "ab"
int dfa_ends_with_ab(char* str) {
    enum State state = Q0;
    
    while(*str != '\0') {
        switch(state) {
            case Q0:
                if(*str == 'a') state = Q1;
                else if(*str == 'b') state = Q0;
                break;
            case Q1:
                if(*str == 'a') state = Q1;
                else if(*str == 'b') state = Q2;
                break;
            case Q2:
                if(*str == 'a') state = Q1;
                else if(*str == 'b') state = Q0;
                break;
        }
        str++;
    }
    
    return state == Q2;  // Accept if in state Q2
}

int main() {
    char* tests[] = {"ab", "aab", "bab", "abb", "ba", "a"};
    int n = 6;
    
    for(int i = 0; i < n; i++) {
        printf("'%s': %s\n", tests[i], 
               dfa_ends_with_ab(tests[i]) ? "Accepted" : "Rejected");
    }
    
    return 0;
}
```

## ğŸ”„ NFA à¦¥à§‡à¦•à§‡ DFA à¦°à§‚à¦ªà¦¾à¦¨à§à¦¤à¦° (Subset Construction)

### NFA à¦‰à¦¦à¦¾à¦¹à¦°à¦£: L = (a|b)*abb

```
NFA:
              a,b
             â”Œâ”€â”€â”
             â–¼  â”‚
        Îµ    â—‹â”€â”€â”˜  a      b      b
   â—‹ â”€â”€â”€â”€â–¶  qâ‚€  â”€â”€â”€â”€â–¶ qâ‚ â”€â”€â”€â”€â–¶ qâ‚‚ â”€â”€â”€â”€â–¶ â— qâ‚ƒ
```

### à¦°à§‚à¦ªà¦¾à¦¨à§à¦¤à¦° à¦ªà§à¦°à¦•à§à¦°à¦¿à¦¯à¦¼à¦¾:

```
Step 1: Îµ-closure of start state
        Îµ-closure({qâ‚€}) = {qâ‚€}
        
Step 2: Create DFA states from NFA state sets
        
DFA State A = {qâ‚€}
  A --a--> {qâ‚€, qâ‚} = B
  A --b--> {qâ‚€} = A

DFA State B = {qâ‚€, qâ‚}
  B --a--> {qâ‚€, qâ‚} = B
  B --b--> {qâ‚€, qâ‚‚} = C

DFA State C = {qâ‚€, qâ‚‚}
  C --a--> {qâ‚€, qâ‚} = B
  C --b--> {qâ‚€, qâ‚ƒ} = D

DFA State D = {qâ‚€, qâ‚ƒ} (Accepting, contains qâ‚ƒ)
  D --a--> {qâ‚€, qâ‚} = B
  D --b--> {qâ‚€} = A
```

### à¦«à¦²à¦¾à¦«à¦² DFA:

```
         a
       â”Œâ”€â”€â”€â”
       â–¼   â”‚
       A â”€â”€â”˜
       â”‚
    a  â”‚ b
       â–¼
       B â”€â”€â”€â”€bâ”€â”€â”€â–¶ C â”€â”€â”€â”€bâ”€â”€â”€â–¶ â— D
       â–²          â”‚            â”‚
       â””â”€â”€â”€â”€aâ”€â”€â”€â”€â”€â”˜     a      â”‚
                       â””â”€â”€â”€â”€â”€â”€â”€â”˜
                          b
                       â”Œâ”€â”€â”€â”€â”€â”€â”€â”
                       â–¼       â”‚
                       A â—€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ Îµ-closure Algorithm

```c
Set epsilon_closure(Set states) {
    Stack stack;
    Set closure = states;
    
    // Push all states onto stack
    for each state s in states:
        push(stack, s)
    
    while stack is not empty:
        s = pop(stack)
        for each state t with Îµ-transition from s:
            if t not in closure:
                add t to closure
                push(stack, t)
    
    return closure
}
```

## ğŸ”§ DFA Minimization

### Hopcroft's Algorithm:

```
1. Partition states into accepting and non-accepting

2. Repeat:
   For each partition P:
     For each symbol a:
       Split P based on where transitions go
   Until no more splits

3. Merge states in same partition
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£:

```
Original DFA:        After Minimization:
qâ‚€ --a--> qâ‚         
qâ‚ --b--> qâ‚‚         qâ‚€ --a--> qâ‚
qâ‚‚ --a--> qâ‚ƒ         qâ‚ --b--> qâ‚‚ (accepting)
qâ‚ƒ --b--> qâ‚„*        
(qâ‚‚ and qâ‚„ equivalent)
```

## ğŸ’» Complete Lexer using DFA

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Token types
typedef enum {
    TOKEN_IDENTIFIER,
    TOKEN_INTEGER,
    TOKEN_KEYWORD,
    TOKEN_UNKNOWN,
    TOKEN_EOF
} TokenType;

// DFA States for Identifier
typedef enum {
    ID_START,
    ID_IN_ID,
    ID_ACCEPT
} IdentifierState;

// DFA States for Integer
typedef enum {
    INT_START,
    INT_IN_NUM,
    INT_ACCEPT
} IntegerState;

// Check if identifier
int isIdentifier(char* str, int len) {
    IdentifierState state = ID_START;
    
    for(int i = 0; i < len; i++) {
        char c = str[i];
        
        switch(state) {
            case ID_START:
                if(isalpha(c) || c == '_')
                    state = ID_IN_ID;
                else
                    return 0;
                break;
                
            case ID_IN_ID:
                if(isalnum(c) || c == '_')
                    state = ID_IN_ID;
                else
                    return 0;
                break;
                
            default:
                return 0;
        }
    }
    
    return state == ID_IN_ID;
}

// Check if integer
int isInteger(char* str, int len) {
    IntegerState state = INT_START;
    
    for(int i = 0; i < len; i++) {
        char c = str[i];
        
        switch(state) {
            case INT_START:
                if(isdigit(c))
                    state = INT_IN_NUM;
                else
                    return 0;
                break;
                
            case INT_IN_NUM:
                if(isdigit(c))
                    state = INT_IN_NUM;
                else
                    return 0;
                break;
                
            default:
                return 0;
        }
    }
    
    return state == INT_IN_NUM;
}

// Check if keyword
char* keywords[] = {"if", "else", "while", "for", "int", "return"};
int numKeywords = 6;

int isKeyword(char* str, int len) {
    char temp[100];
    strncpy(temp, str, len);
    temp[len] = '\0';
    
    for(int i = 0; i < numKeywords; i++) {
        if(strcmp(temp, keywords[i]) == 0)
            return 1;
    }
    return 0;
}

// Get token type
TokenType getTokenType(char* str, int len) {
    if(isKeyword(str, len))
        return TOKEN_KEYWORD;
    if(isIdentifier(str, len))
        return TOKEN_IDENTIFIER;
    if(isInteger(str, len))
        return TOKEN_INTEGER;
    return TOKEN_UNKNOWN;
}

int main() {
    char* tests[] = {"if", "count", "123", "_var", "for", "3.14"};
    int lengths[] = {2, 5, 3, 4, 3, 4};
    char* typeNames[] = {"IDENTIFIER", "INTEGER", "KEYWORD", "UNKNOWN", "EOF"};
    
    printf("Token Analysis:\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    for(int i = 0; i < 6; i++) {
        TokenType type = getTokenType(tests[i], lengths[i]);
        printf("'%s' â†’ %s\n", tests[i], typeNames[type]);
    }
    
    return 0;
}
```

## ğŸ“Š DFA vs NFA à¦¤à§à¦²à¦¨à¦¾

| à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯ | DFA | NFA |
|----------|-----|-----|
| Transitions | à¦à¦•à¦Ÿà¦¿ | à¦à¦•à¦¾à¦§à¦¿à¦• |
| Îµ-moves | à¦¨à§‡à¦‡ | à¦†à¦›à§‡ |
| States | à¦¬à§‡à¦¶à¦¿ à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡ | à¦•à¦® |
| Implementation | à¦¸à¦¹à¦œ | à¦œà¦Ÿà¦¿à¦² |
| Speed | O(n) | O(nÂ²) worst case |
| Space | à¦¬à§‡à¦¶à¦¿ | à¦•à¦® |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [Flex à¦Ÿà§à¦²](à§¦à§ª-à¦«à§à¦²à§‡à¦•à§à¦¸-à¦Ÿà§à¦².md)
