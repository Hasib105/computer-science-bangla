# ЁЯФН рж▓рзЗржХрзНрж╕рж┐ржХрзНржпрж╛рж▓ ржПржирж╛рж▓рж╛ржЗрж╕рж┐рж╕ ржкрж░рж┐ржЪрж┐рждрж┐ (Introduction to Lexical Analysis)

## рж▓рзЗржХрзНрж╕рж┐ржХрзНржпрж╛рж▓ ржПржирж╛рж▓рж╛ржЗрж╕рж┐рж╕ ржХрзА?

**рж▓рзЗржХрзНрж╕рж┐ржХрзНржпрж╛рж▓ ржПржирж╛рж▓рж╛ржЗрж╕рж┐рж╕** (Lexical Analysis) ржмрж╛ **рж╕рзНржХрзНржпрж╛ржирж┐ржВ** (Scanning) рж╣рж▓рзЛ ржХржорзНржкрж╛ржЗрж▓рж╛рж░рзЗрж░ ржкрзНрж░ржержо ржзрж╛ржкред ржПржЗ ржзрж╛ржкрзЗ рж╕рзЛрж░рзНрж╕ ржХрзЛржбржХрзЗ **ржЯрзЛржХрзЗржирзЗ** (Tokens) ржнрж╛ржЧ ржХрж░рж╛ рж╣ржпрж╝ред

```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ                  рж▓рзЗржХрзНрж╕рж┐ржХрзНржпрж╛рж▓ ржПржирж╛рж▓рж╛ржЗрж╕рж┐рж╕                           тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ                                                                 тФВ
тФВ  Character Stream тФАтФАтЦ╢ [Lexer/Scanner] тФАтФАтЦ╢ Token Stream          тФВ
тФВ                                                                 тФВ
тФВ  "int x = 5;"  тФАтФАтЦ╢  [int] [x] [=] [5] [;]                      тФВ
тФВ                                                                 тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

## ЁЯУК ржорзВрж▓ ржкрж░рж┐ржнрж╛рж╖рж╛

### рзз. Token (ржЯрзЛржХрзЗржи)
ржкрзНрж░рзЛржЧрзНрж░рж╛ржорж┐ржВ ржнрж╛рж╖рж╛рж░ ржХрзНрж╖рзБржжрзНрж░рждржо ржЕрж░рзНржержмрж╣ ржПржХржХред

```
Token = <Token Type, Token Value>

ржЙржжрж╛рж╣рж░ржг:
<KEYWORD, int>
<IDENTIFIER, x>
<OPERATOR, =>
<NUMBER, 5>
<PUNCTUATION, ;>
```

### рзи. Lexeme (рж▓рзЗржХрзНрж╕рж┐ржо)
рж╕рзЛрж░рзНрж╕ ржХрзЛржбрзЗрж░ ржкрзНрж░ржХрзГржд ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ рж╕рж┐ржХрзЛржпрж╝рзЗржирзНрж╕ред

```
рж╕рзЛрж░рзНрж╕: int count = 100;

Lexemes: "int", "count", "=", "100", ";"
```

### рзй. Pattern (ржкрзНржпрж╛ржЯрж╛рж░рзНржи)
ржПржХржЯрж┐ Token Type-ржПрж░ ржЬржирзНржп рж╕ржорзНржнрж╛ржмрзНржп Lexeme-ржПрж░ ржирж┐ржпрж╝ржоред

```
IDENTIFIER Pattern: letter followed by letters or digits
                    [a-zA-Z][a-zA-Z0-9]*

NUMBER Pattern: one or more digits
                [0-9]+
```

### рж╕ржорзНржкрж░рзНржХ:
```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ                                                                 тФВ
тФВ  Pattern тФАтФА(describes)тФАтФАтЦ╢ Token Type                            тФВ
тФВ                              тФВ                                  тФВ
тФВ  Lexeme  тФАтФА(matches)тФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ                                  тФВ
тФВ                              тФВ                                  тФВ
тФВ            тЧАтФАтФА(instance of)тФАтФАтФШ                                  тФВ
тФВ                                                                 тФВ
тФВ  ржЙржжрж╛рж╣рж░ржг:                                                        тФВ
тФВ  Pattern: [a-zA-Z][a-zA-Z0-9]*                                  тФВ
тФВ  Token Type: IDENTIFIER                                         тФВ
тФВ  Lexeme: count, sum, x, myVar                                  тФВ
тФВ                                                                 тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

## ЁЯП╖я╕П Token-ржПрж░ ржкрзНрж░ржХрж╛рж░ржнрзЗржж

| Token Type | ржмрж░рзНржгржирж╛ | ржЙржжрж╛рж╣рж░ржг |
|------------|-------|--------|
| **Keywords** | рж╕ржВрж░ржХрзНрж╖рж┐ржд рж╢ржмрзНржж | `int`, `if`, `while`, `return` |
| **Identifiers** | ржнрзЗрж░рж┐ржпрж╝рзЗржмрж▓/ржлрж╛ржВрж╢ржи ржирж╛ржо | `count`, `sum`, `main` |
| **Constants** | рж╕ржВржЦрзНржпрж╛/рж╕рзНржЯрзНрж░рж┐ржВ | `42`, `3.14`, `"hello"` |
| **Operators** | ржЕржкрж╛рж░рзЗржЯрж░ | `+`, `-`, `*`, `/`, `==` |
| **Punctuators** | ржмрж┐рж░рж╛ржо ржЪрж┐рж╣рзНржи | `;`, `,`, `{`, `}`, `(`, `)` |
| **Comments** | ржоржирзНрждржмрзНржп (рж╕рж╛ржзрж╛рж░ржгржд ржмрж╛ржж ржжрзЗржУржпрж╝рж╛ рж╣ржпрж╝) | `// comment`, `/* */` |

## ЁЯФН ржЙржжрж╛рж╣рж░ржг: рж╕ржорзНржкрзВрж░рзНржг ржмрж┐рж╢рзНрж▓рзЗрж╖ржг

### рж╕рзЛрж░рзНрж╕ ржХрзЛржб:
```c
int main() {
    float pi = 3.14;
    int r = 5;
    float area = pi * r * r;
    return 0;
}
```

### Token Stream:
```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ  Token Type тФВ     Lexeme     тФВ  Line   тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ╝тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ╝тФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ  KEYWORD    тФВ      int       тФВ    1    тФВ
тФВ  IDENTIFIER тФВ      main      тФВ    1    тФВ
тФВ  LPAREN     тФВ       (        тФВ    1    тФВ
тФВ  RPAREN     тФВ       )        тФВ    1    тФВ
тФВ  LBRACE     тФВ       {        тФВ    1    тФВ
тФВ  KEYWORD    тФВ     float      тФВ    2    тФВ
тФВ  IDENTIFIER тФВ       pi       тФВ    2    тФВ
тФВ  ASSIGN     тФВ       =        тФВ    2    тФВ
тФВ  FLOAT      тФВ     3.14       тФВ    2    тФВ
тФВ  SEMICOLON  тФВ       ;        тФВ    2    тФВ
тФВ  KEYWORD    тФВ      int       тФВ    3    тФВ
тФВ  IDENTIFIER тФВ       r        тФВ    3    тФВ
тФВ  ASSIGN     тФВ       =        тФВ    3    тФВ
тФВ  INTEGER    тФВ       5        тФВ    3    тФВ
тФВ  SEMICOLON  тФВ       ;        тФВ    3    тФВ
тФВ  KEYWORD    тФВ     float      тФВ    4    тФВ
тФВ  IDENTIFIER тФВ      area      тФВ    4    тФВ
тФВ  ASSIGN     тФВ       =        тФВ    4    тФВ
тФВ  IDENTIFIER тФВ       pi       тФВ    4    тФВ
тФВ  MULTIPLY   тФВ       *        тФВ    4    тФВ
тФВ  IDENTIFIER тФВ       r        тФВ    4    тФВ
тФВ  MULTIPLY   тФВ       *        тФВ    4    тФВ
тФВ  IDENTIFIER тФВ       r        тФВ    4    тФВ
тФВ  SEMICOLON  тФВ       ;        тФВ    4    тФВ
тФВ  KEYWORD    тФВ     return     тФВ    5    тФВ
тФВ  INTEGER    тФВ       0        тФВ    5    тФВ
тФВ  SEMICOLON  тФВ       ;        тФВ    5    тФВ
тФВ  RBRACE     тФВ       }        тФВ    6    тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

## ЁЯПЧя╕П Lexer-ржПрж░ ржХрж╛ржЬ

```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ                      Lexer Functions                            тФВ
тФЬтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФд
тФВ                                                                 тФВ
тФВ  рзз. Character Reading                                           тФВ
тФВ     - рж╕рзЛрж░рзНрж╕ ржлрж╛ржЗрж▓ ржерзЗржХрзЗ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржкржбрж╝рж╛                            тФВ
тФВ     - Buffer management                                         тФВ
тФВ                                                                 тФВ
тФВ  рзи. Lexeme Extraction                                           тФВ
тФВ     - Pattern matching                                          тФВ
тФВ     - Token boundary detection                                  тФВ
тФВ                                                                 тФВ
тФВ  рзй. Token Creation                                              тФВ
тФВ     - Token type ржирж┐рж░рзНржзрж╛рж░ржг                                        тФВ
тФВ     - Attribute/value рж╕ржВрж░ржХрзНрж╖ржг                                    тФВ
тФВ                                                                 тФВ
тФВ  рзк. Whitespace/Comment Removal                                  тФВ
тФВ     - рж╕рзНржкрзЗрж╕, ржЯрзНржпрж╛ржм, ржирж┐ржЙрж▓рж╛ржЗржи ржПржбрж╝рж┐ржпрж╝рзЗ ржпрж╛ржУржпрж╝рж╛                        тФВ
тФВ     - ржХржорзЗржирзНржЯ ржмрж╛ржж ржжрзЗржУржпрж╝рж╛                                          тФВ
тФВ                                                                 тФВ
тФВ  рзл. Error Detection                                             тФВ
тФВ     - ржЕржмрзИржз ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ рж╕ржирж╛ржХрзНржд                                    тФВ
тФВ     - Malformed token рж░рж┐ржкрзЛрж░рзНржЯ                                   тФВ
тФВ                                                                 тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

## ЁЯУР Input Buffering

### рж╕ржорж╕рзНржпрж╛:
ржкрзНрж░рждрж┐ржЯрж┐ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржкржбрж╝рждрзЗ I/O ржЕржкрж╛рж░рзЗрж╢ржи рж▓рж╛ржЧрзЗ - ржзрзАрж░!

### рж╕ржорж╛ржзрж╛ржи: Two-Buffer Scheme
```
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ                                                                тФВ
тФВ  Buffer 1                      Buffer 2                        тФВ
тФВ  тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР      тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР          тФВ
тФВ  тФВ i тФВ n тФВ t тФВ   тФВ x тФВ тФВ      тФВ = тФВ   тФВ 5 тФВ ; тФВ EOFтФВ          тФВ
тФВ  тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ      тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ          тФВ
тФВ            тЖС                                                   тФВ
тФВ       lexemeBegin                                              тФВ
тФВ                 тЖС                                              тФВ
тФВ              forward                                           тФВ
тФВ                                                                тФВ
тФВ  - ржжрзБржЯрж┐ buffer ржкрж░рзНржпрж╛ржпрж╝ржХрзНрж░ржорзЗ ржкрзВрж░ржг рж╣ржпрж╝                              тФВ
тФВ  - lexemeBegin: ржмрж░рзНрждржорж╛ржи lexeme рж╢рзБрж░рзБ                            тФВ
тФВ  - forward: ржмрж░рзНрждржорж╛ржи ржкржбрж╝рж╛рж░ ржЕржмрж╕рзНржерж╛ржи                               тФВ
тФВ                                                                тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

### Sentinels ржмрзНржпржмрж╣рж╛рж░:
```
Buffer:
тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
тФВ i тФВ n тФВ t тФВ   тФВ x тФВ = тФВ 5 тФВ ; тФВ EOF тФВ
тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
                                    тЖС
                               Sentinel
                               (Buffer рж╢рзЗрж╖ ржмрзЛржЭрж╛ржпрж╝)
```

## ЁЯТ╗ рж╕рж╣ржЬ Lexer ржЙржжрж╛рж╣рж░ржг

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Token types
typedef enum {
    TOKEN_INT, TOKEN_FLOAT, TOKEN_IF, TOKEN_ELSE, TOKEN_WHILE,
    TOKEN_RETURN, TOKEN_IDENTIFIER, TOKEN_NUMBER, TOKEN_PLUS,
    TOKEN_MINUS, TOKEN_MULTIPLY, TOKEN_DIVIDE, TOKEN_ASSIGN,
    TOKEN_SEMICOLON, TOKEN_LPAREN, TOKEN_RPAREN, TOKEN_LBRACE,
    TOKEN_RBRACE, TOKEN_EOF, TOKEN_UNKNOWN
} TokenType;

typedef struct {
    TokenType type;
    char lexeme[100];
    int line;
} Token;

char* keywords[] = {"int", "float", "if", "else", "while", "return"};
TokenType keywordTypes[] = {TOKEN_INT, TOKEN_FLOAT, TOKEN_IF, 
                            TOKEN_ELSE, TOKEN_WHILE, TOKEN_RETURN};

char* input;
int pos = 0;
int line = 1;

char peek() {
    return input[pos];
}

char advance() {
    return input[pos++];
}

void skipWhitespace() {
    while(isspace(peek())) {
        if(peek() == '\n') line++;
        advance();
    }
}

Token scanNumber() {
    Token token;
    token.line = line;
    int i = 0;
    
    while(isdigit(peek())) {
        token.lexeme[i++] = advance();
    }
    
    if(peek() == '.' && isdigit(input[pos+1])) {
        token.lexeme[i++] = advance();
        while(isdigit(peek())) {
            token.lexeme[i++] = advance();
        }
    }
    
    token.lexeme[i] = '\0';
    token.type = TOKEN_NUMBER;
    return token;
}

Token scanIdentifier() {
    Token token;
    token.line = line;
    int i = 0;
    
    while(isalnum(peek()) || peek() == '_') {
        token.lexeme[i++] = advance();
    }
    token.lexeme[i] = '\0';
    
    // Check if keyword
    for(int j = 0; j < 6; j++) {
        if(strcmp(token.lexeme, keywords[j]) == 0) {
            token.type = keywordTypes[j];
            return token;
        }
    }
    
    token.type = TOKEN_IDENTIFIER;
    return token;
}

Token getNextToken() {
    skipWhitespace();
    
    Token token;
    token.line = line;
    
    char c = peek();
    
    if(c == '\0') {
        token.type = TOKEN_EOF;
        strcpy(token.lexeme, "EOF");
        return token;
    }
    
    if(isdigit(c)) return scanNumber();
    if(isalpha(c) || c == '_') return scanIdentifier();
    
    token.lexeme[0] = advance();
    token.lexeme[1] = '\0';
    
    switch(c) {
        case '+': token.type = TOKEN_PLUS; break;
        case '-': token.type = TOKEN_MINUS; break;
        case '*': token.type = TOKEN_MULTIPLY; break;
        case '/': token.type = TOKEN_DIVIDE; break;
        case '=': token.type = TOKEN_ASSIGN; break;
        case ';': token.type = TOKEN_SEMICOLON; break;
        case '(': token.type = TOKEN_LPAREN; break;
        case ')': token.type = TOKEN_RPAREN; break;
        case '{': token.type = TOKEN_LBRACE; break;
        case '}': token.type = TOKEN_RBRACE; break;
        default: token.type = TOKEN_UNKNOWN;
    }
    
    return token;
}

int main() {
    input = "int x = 5 + 10;";
    
    printf("Input: %s\n\n", input);
    printf("Tokens:\n");
    printf("%-15s %-15s %-5s\n", "Type", "Lexeme", "Line");
    printf("тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФА\n");
    
    Token token;
    do {
        token = getNextToken();
        printf("%-15d %-15s %-5d\n", token.type, token.lexeme, token.line);
    } while(token.type != TOKEN_EOF);
    
    return 0;
}
```

## тЬЕ Lexer-ржПрж░ рж╕рзБржмрж┐ржзрж╛

1. **Simplicity**: Parser-ржПрж░ ржХрж╛ржЬ рж╕рж╣ржЬ рж╣ржпрж╝
2. **Efficiency**: Character-by-character ржирж╛ ржкржбрж╝рзЗ Token-by-Token ржкржбрж╝рж╛ ржпрж╛ржпрж╝
3. **Portability**: Character encoding ржЖрж▓рж╛ржжрж╛ржнрж╛ржмрзЗ handle ржХрж░рж╛ ржпрж╛ржпрж╝
4. **Modularity**: ржкрж░рж┐ржмрж░рзНрждржи рж╕рж╣ржЬ

---
**ржкрж░ржмрж░рзНрждрзА ржЕржзрзНржпрж╛ржпрж╝**: [рж░рзЗржЧрзБрж▓рж╛рж░ ржПржХрзНрж╕ржкрзНрж░рзЗрж╢ржи](рзжрзи-рж░рзЗржЧрзБрж▓рж╛рж░-ржПржХрзНрж╕ржкрзНрж░рзЗрж╢ржи.md)
