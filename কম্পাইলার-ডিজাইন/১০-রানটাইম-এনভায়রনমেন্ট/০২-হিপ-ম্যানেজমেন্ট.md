# ğŸ“¦ à¦¹à¦¿à¦ª à¦®à§à¦¯à¦¾à¦¨à§‡à¦œà¦®à§‡à¦¨à§à¦Ÿ à¦“ à¦—à¦¾à¦°à§à¦¬à§‡à¦œ à¦•à¦¾à¦²à§‡à¦•à¦¶à¦¨

## à¦¹à¦¿à¦ª à¦•à§€?

**Heap** à¦¹à¦²à§‹ dynamic memory allocation-à¦à¦° à¦œà¦¨à§à¦¯ à¦¬à§à¦¯à¦¬à¦¹à§ƒà¦¤ memory region à¦¯à§‡à¦–à¦¾à¦¨à§‡ objects-à¦à¦° lifetime programmer à¦¬à¦¾ garbage collector à¦¨à¦¿à¦¯à¦¼à¦¨à§à¦¤à§à¦°à¦£ à¦•à¦°à§‡à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Heap Memory                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Stack vs Heap:                                                 â”‚
â”‚                                                                 â”‚
â”‚  Stack:                         Heap:                           â”‚
â”‚  â”œâ”€â”€ LIFO order                 â”œâ”€â”€ Any order allocation       â”‚
â”‚  â”œâ”€â”€ Auto deallocation          â”œâ”€â”€ Manual/GC deallocation     â”‚
â”‚  â”œâ”€â”€ Fast (pointer move)        â”œâ”€â”€ Slower (search free block) â”‚
â”‚  â”œâ”€â”€ Fixed size at call         â”œâ”€â”€ Variable size              â”‚
â”‚  â””â”€â”€ Limited size               â””â”€â”€ Larger, fragmented         â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    Heap Layout                           â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚ [USED:100] [FREE:50] [USED:200] [FREE:30] [USED:80]     â”‚   â”‚
â”‚  â”‚     â†‘          â†‘          â†‘          â†‘          â†‘        â”‚   â”‚
â”‚  â”‚   Object1   (hole)    Object2    (hole)    Object3      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Fragmentation: Free memory à¦†à¦›à§‡ à¦•à¦¿à¦¨à§à¦¤à§ contiguous à¦¨à¦¯à¦¼          â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Heap Allocation Strategies

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               Allocation Strategies                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. First Fit:                                                  â”‚
â”‚     â””â”€â”€ à¦ªà§à¦°à¦¥à¦® à¦¯à§‡ block fit à¦•à¦°à§‡ à¦¸à§‡à¦Ÿà¦¿ use à¦•à¦°à¦¾                     â”‚
â”‚     â””â”€â”€ Fast à¦•à¦¿à¦¨à§à¦¤à§ fragmentation à¦¬à§‡à¦¶à¦¿                          â”‚
â”‚                                                                 â”‚
â”‚  2. Best Fit:                                                   â”‚
â”‚     â””â”€â”€ à¦¸à¦¬à¦šà§‡à¦¯à¦¼à§‡ à¦›à§‹à¦Ÿ block à¦¯à§‡à¦Ÿà¦¾ fit à¦•à¦°à§‡                          â”‚
â”‚     â””â”€â”€ Less fragmentation but slower                           â”‚
â”‚                                                                 â”‚
â”‚  3. Worst Fit:                                                  â”‚
â”‚     â””â”€â”€ à¦¸à¦¬à¦šà§‡à¦¯à¦¼à§‡ à¦¬à¦¡à¦¼ block à¦¥à§‡à¦•à§‡ allocate                          â”‚
â”‚     â””â”€â”€ Large remaining piece                                   â”‚
â”‚                                                                 â”‚
â”‚  4. Buddy System:                                               â”‚
â”‚     â””â”€â”€ Power of 2 sizes                                        â”‚
â”‚     â””â”€â”€ Fast coalescing                                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ—‘ï¸ Garbage Collection

### GC à¦•à§€?

**Garbage Collection** à¦¹à¦²à§‹ automatic memory management à¦¯à§‡à¦–à¦¾à¦¨à§‡ unused objects automatically free à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Garbage Collection                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Live Object: à¦¯à¦¾ program à¦¥à§‡à¦•à§‡ reach à¦•à¦°à¦¾ à¦¯à¦¾à¦¯à¦¼                    â”‚
â”‚  Garbage: à¦¯à¦¾ à¦†à¦° reach à¦•à¦°à¦¾ à¦¯à¦¾à¦¯à¦¼ à¦¨à¦¾                                â”‚
â”‚                                                                 â”‚
â”‚  Root Set:                                                      â”‚
â”‚  â”œâ”€â”€ Global variables                                           â”‚
â”‚  â”œâ”€â”€ Stack variables                                            â”‚
â”‚  â””â”€â”€ CPU registers                                              â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                        Heap                               â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â”‚    [Root]                                                 â”‚  â”‚
â”‚  â”‚      â”‚                                                    â”‚  â”‚
â”‚  â”‚      â–¼                                                    â”‚  â”‚
â”‚  â”‚    [A] â”€â”€â”€â”€â”€â”€â†’ [B] â”€â”€â”€â”€â”€â”€â†’ [C]   (LIVE)                  â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â”‚    [D] â”€â”€â”€â”€â”€â”€â†’ [E]               (GARBAGE - no root)     â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ GC Algorithms

### 1. Mark and Sweep

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Mark and Sweep                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Phase 1: Mark                                                  â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  1. Start from roots                                            â”‚
â”‚  2. Traverse all reachable objects                              â”‚
â”‚  3. Mark each as "alive"                                        â”‚
â”‚                                                                 â”‚
â”‚  Phase 2: Sweep                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                              â”‚
â”‚  1. Scan entire heap                                            â”‚
â”‚  2. Free unmarked objects                                       â”‚
â”‚  3. Clear marks for next cycle                                  â”‚
â”‚                                                                 â”‚
â”‚  Before:          After Mark:       After Sweep:                â”‚
â”‚  â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”    â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”               â”‚
â”‚  â”‚ A â”‚ B â”‚ C â”‚    â”‚âœ“A â”‚ B â”‚âœ“C â”‚    â”‚ A â”‚   â”‚ C â”‚               â”‚
â”‚  â”‚ D â”‚ E â”‚ F â”‚    â”‚âœ“D â”‚ E â”‚ F â”‚    â”‚ D â”‚   â”‚   â”‚               â”‚
â”‚  â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜    â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜               â”‚
â”‚   Live: A,C,D      Marked: A,C,D    Freed: B,E,F                â”‚
â”‚                                                                 â”‚
â”‚  Pros: Simple, handles cycles                                   â”‚
â”‚  Cons: Stop-the-world, fragmentation                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Reference Counting

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Reference Counting                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ object-à¦ reference count maintain à¦•à¦°à¦¾:                  â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚   Object A         Object B         Object C            â”‚    â”‚
â”‚  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”          â”‚    â”‚
â”‚  â”‚   â”‚ RC: 2 â”‚â†â”€â”€â”€â”€â”€â”€â”€â”‚ RC: 1 â”‚â†â”€â”€â”€â”€â”€â”€â”€â”‚ RC: 1 â”‚          â”‚    â”‚
â”‚  â”‚   â”‚ data  â”‚        â”‚ data  â”‚        â”‚ data  â”‚          â”‚    â”‚
â”‚  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”˜          â”‚    â”‚
â”‚  â”‚      â†‘                                                  â”‚    â”‚
â”‚  â”‚    [root]                                               â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                 â”‚
â”‚  Operations:                                                    â”‚
â”‚  â€¢ Assignment (x = y): y.RC++, old(x).RC--                     â”‚
â”‚  â€¢ When RC == 0: Free object                                   â”‚
â”‚                                                                 â”‚
â”‚  Pros: Immediate reclamation, no stop-the-world                â”‚
â”‚  Cons: Cannot handle cycles, overhead on every assignment      â”‚
â”‚                                                                 â”‚
â”‚  Cycle Problem:                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â”€â”€â”€â”                                      â”‚
â”‚  â”‚ RC: 1 â”‚â”€â”€â”€â”€â”€â”€â”‚ RC: 1 â”‚                                      â”‚
â”‚  â”‚   A   â”‚â†â”€â”€â”€â”€â”€â”‚   B   â”‚                                      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”˜                                      â”‚
â”‚  Aâ†’B, Bâ†’A: Both RC=1 but no external reference!                â”‚
â”‚  This memory will LEAK!                                        â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Copying/Compacting GC

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Copying GC                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Heap à¦¦à§à¦‡ à¦­à¦¾à¦—à§‡ à¦­à¦¾à¦—: From-space à¦“ To-space                       â”‚
â”‚                                                                 â”‚
â”‚  Before GC:                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚     From-space      â”‚      To-space       â”‚                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚
â”‚  â”‚ [A][X][B][Y][C][Z] â”‚      (empty)        â”‚                  â”‚
â”‚  â”‚ Live: A,B,C         â”‚                     â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                 â”‚
â”‚  After GC:                                                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                  â”‚
â”‚  â”‚     From-space      â”‚      To-space       â”‚                  â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤                  â”‚
â”‚  â”‚      (clear)        â”‚ [A'][B'][C']        â”‚                  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                  â”‚
â”‚                                                                 â”‚
â”‚  Swap From â†” To for next cycle                                 â”‚
â”‚                                                                 â”‚
â”‚  Pros: No fragmentation, simple allocation (bump pointer)      â”‚
â”‚  Cons: Uses double memory, copying overhead                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4. Generational GC

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Generational GC                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Observation: Most objects die young!                           â”‚
â”‚                                                                 â”‚
â”‚  Object Lifetime Distribution:                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  â”‚                                                        â”‚  â”‚
â”‚  â”‚  â”‚â–ˆ                                                       â”‚  â”‚
â”‚  â”‚  â”‚â–ˆâ–ˆ                                                      â”‚  â”‚
â”‚  â”‚  â”‚â–ˆâ–ˆâ–ˆ                                                     â”‚  â”‚
â”‚  â”‚  â”‚â–ˆâ–ˆâ–ˆâ–ˆ                                                    â”‚  â”‚
â”‚  â”‚  â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                               â”‚  â”‚
â”‚  â”‚  â”‚â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ                                â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚  â”‚
â”‚  â”‚   Young              â†’               Old                  â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚  Generation Structure:                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Young Generation       â”‚       Old Generation            â”‚  â”‚
â”‚  â”‚  (Nursery)              â”‚       (Tenured)                 â”‚  â”‚
â”‚  â”‚                         â”‚                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚  â”‚  â”‚  Eden   â”‚Survivor â”‚  â”‚  â”‚         Tenured             â”‚â”‚  â”‚
â”‚  â”‚  â”‚         â”‚ S1 â”‚ S2 â”‚  â”‚  â”‚                             â”‚â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚  â”‚                         â”‚                                 â”‚  â”‚
â”‚  â”‚  Collected frequently   â”‚  Collected rarely              â”‚  â”‚
â”‚  â”‚  (Minor GC)             â”‚  (Major GC)                    â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â”‚  Algorithm:                                                     â”‚
â”‚  1. New objects â†’ Eden                                         â”‚
â”‚  2. Minor GC: Eden + Survivor â†’ Survivor                       â”‚
â”‚  3. After N survivals â†’ Promote to Old                         â”‚
â”‚  4. Major GC: Collect Old generation (rare)                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Garbage Collector Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Simple Mark-and-Sweep GC
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define HEAP_SIZE 100
#define MAX_OBJECTS 50
#define MAX_ROOTS 10

typedef struct Object {
    int id;
    int size;
    int marked;
    int numRefs;
    struct Object* refs[5];  // References to other objects
} Object;

// Heap
Object* heap[HEAP_SIZE];
int heapUsed = 0;

// All allocated objects
Object* objects[MAX_OBJECTS];
int numObjects = 0;

// Root set
Object* roots[MAX_ROOTS];
int numRoots = 0;

// Statistics
int totalAllocated = 0;
int totalFreed = 0;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Allocation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Object* allocate(int size) {
    if(numObjects >= MAX_OBJECTS) {
        printf("  [GC] Heap full, triggering collection...\n");
        collect();
    }
    
    if(numObjects >= MAX_OBJECTS) {
        printf("  [GC] Out of memory!\n");
        return NULL;
    }
    
    Object* obj = malloc(sizeof(Object));
    obj->id = numObjects;
    obj->size = size;
    obj->marked = 0;
    obj->numRefs = 0;
    
    objects[numObjects++] = obj;
    totalAllocated++;
    
    printf("  Allocated Object %d (size: %d)\n", obj->id, size);
    return obj;
}

void addReference(Object* from, Object* to) {
    if(from->numRefs < 5) {
        from->refs[from->numRefs++] = to;
        printf("  Object %d -> Object %d\n", from->id, to->id);
    }
}

void addRoot(Object* obj) {
    if(numRoots < MAX_ROOTS) {
        roots[numRoots++] = obj;
        printf("  Added root: Object %d\n", obj->id);
    }
}

void removeRoot(Object* obj) {
    for(int i = 0; i < numRoots; i++) {
        if(roots[i] == obj) {
            roots[i] = roots[--numRoots];
            printf("  Removed root: Object %d\n", obj->id);
            return;
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Mark Phase
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void mark(Object* obj) {
    if(obj == NULL || obj->marked) return;
    
    obj->marked = 1;
    printf("    Marked Object %d\n", obj->id);
    
    // Recursively mark referenced objects
    for(int i = 0; i < obj->numRefs; i++) {
        mark(obj->refs[i]);
    }
}

void markAll() {
    printf("\n  === Mark Phase ===\n");
    
    // Clear all marks
    for(int i = 0; i < numObjects; i++) {
        if(objects[i] != NULL) {
            objects[i]->marked = 0;
        }
    }
    
    // Mark from roots
    for(int i = 0; i < numRoots; i++) {
        printf("    Starting from root Object %d\n", roots[i]->id);
        mark(roots[i]);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Sweep Phase
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void sweep() {
    printf("\n  === Sweep Phase ===\n");
    
    int freed = 0;
    int j = 0;
    
    for(int i = 0; i < numObjects; i++) {
        if(objects[i] != NULL) {
            if(!objects[i]->marked) {
                printf("    Freed Object %d (garbage)\n", objects[i]->id);
                free(objects[i]);
                objects[i] = NULL;
                freed++;
                totalFreed++;
            } else {
                objects[j++] = objects[i];
            }
        }
    }
    
    numObjects = j;
    printf("    Freed %d objects\n", freed);
}

void collect() {
    printf("\nâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘          Garbage Collection Started                   â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    printf("\n  Objects before GC: %d\n", numObjects);
    
    markAll();
    sweep();
    
    printf("\n  Objects after GC: %d\n", numObjects);
    printf("  Total allocated: %d, Total freed: %d\n", totalAllocated, totalFreed);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Visualization
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void printHeapState() {
    printf("\n  Heap State:\n");
    printf("  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    printf("  â”‚ Objects: ");
    
    for(int i = 0; i < numObjects; i++) {
        if(objects[i] != NULL) {
            printf("[%d]", objects[i]->id);
            if(objects[i]->marked) printf("*");
            printf(" ");
        }
    }
    printf("\n");
    
    printf("  â”‚ Roots:   ");
    for(int i = 0; i < numRoots; i++) {
        printf("[%d] ", roots[i]->id);
    }
    printf("\n");
    
    printf("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

void printObjectGraph() {
    printf("\n  Object Graph:\n");
    printf("  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”\n");
    
    for(int i = 0; i < numObjects; i++) {
        if(objects[i] != NULL) {
            printf("  â”‚ Object %d â†’ ", objects[i]->id);
            for(int j = 0; j < objects[i]->numRefs; j++) {
                printf("%d ", objects[i]->refs[j]->id);
            }
            printf("\n");
        }
    }
    
    printf("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜\n");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘       Mark and Sweep Garbage Collector Demo           â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    // Create object graph
    printf("Creating objects...\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    Object* a = allocate(100);
    Object* b = allocate(200);
    Object* c = allocate(150);
    Object* d = allocate(80);
    Object* e = allocate(120);
    
    // Create references: a â†’ b â†’ c, a â†’ d
    printf("\nCreating references...\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    addReference(a, b);
    addReference(b, c);
    addReference(a, d);
    
    // e is orphan (no reference to it)
    printf("  Object 4 (e) has no incoming references\n");
    
    // a is root
    printf("\nSetting roots...\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    addRoot(a);
    
    printObjectGraph();
    printHeapState();
    
    // Run GC
    collect();
    
    printHeapState();
    
    // Remove root and run GC again
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("     Removing all roots...\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    removeRoot(a);
    
    collect();
    
    printHeapState();
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("     All objects should be garbage now!\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    return 0;
}
```

## ğŸ“‹ GC Algorithm Comparison

| Algorithm | Pros | Cons | Used In |
|-----------|------|------|---------|
| Mark-Sweep | Simple, handles cycles | Stop-the-world, fragmentation | Basic implementations |
| Reference Counting | Immediate, incremental | No cycles, overhead | Python, Swift |
| Copying | No fragmentation, fast alloc | 50% memory waste | Young gen |
| Generational | Fast for common case | Complex | JVM, .NET, V8 |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦…à§à¦¯à¦¾à¦¡à¦­à¦¾à¦¨à§à¦¸à¦¡ à¦Ÿà¦ªà¦¿à¦•](../à§§à§§-à¦…à§à¦¯à¦¾à¦¡à¦­à¦¾à¦¨à§à¦¸à¦¡-à¦Ÿà¦ªà¦¿à¦•/à§¦à§§-à¦œà¦¿à¦Ÿ-à¦•à¦®à§à¦ªà¦¾à¦‡à¦²à§‡à¦¶à¦¨.md)
