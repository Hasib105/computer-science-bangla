# âš¡ JIT à¦•à¦®à§à¦ªà¦¾à¦‡à¦²à§‡à¦¶à¦¨

## JIT Compilation à¦•à§€?

**Just-In-Time (JIT) Compilation** à¦¹à¦²à§‹ runtime-à¦ bytecode à¦¬à¦¾ intermediate code-à¦•à§‡ native machine code-à¦ compile à¦•à¦°à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    JIT Compilation                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Traditional Compilation:                                       â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚  â”‚ Source  â”‚ â†’  â”‚ Compiler â”‚ â†’  â”‚ Machine  â”‚  â†’ Run            â”‚
â”‚  â”‚ Code    â”‚    â”‚          â”‚    â”‚ Code     â”‚                   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚       Compile time              Run time                        â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  JIT Compilation:                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Source  â”‚ â†’  â”‚ Bytecode â”‚ â†’  â”‚   JIT    â”‚ â†’  â”‚ Machine  â”‚   â”‚
â”‚  â”‚ Code    â”‚    â”‚ Compiler â”‚    â”‚ Compiler â”‚    â”‚ Code     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚     Ahead of time          At runtime (when needed)             â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  à¦¸à§à¦¬à¦¿à¦§à¦¾:                                                         â”‚
â”‚  â”œâ”€â”€ Platform independence (bytecode portable)                  â”‚
â”‚  â”œâ”€â”€ Runtime optimization (knows actual usage patterns)         â”‚
â”‚  â”œâ”€â”€ Adaptive optimization (hot paths optimized more)           â”‚
â”‚  â””â”€â”€ Security (verified bytecode)                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š JIT vs AOT Compilation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  JIT vs AOT                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  AOT (Ahead-of-Time):         JIT (Just-in-Time):              â”‚
â”‚  â”œâ”€â”€ C, C++, Rust             â”œâ”€â”€ Java, JavaScript, C#         â”‚
â”‚  â”œâ”€â”€ Compile before run       â”œâ”€â”€ Compile during run           â”‚
â”‚  â”œâ”€â”€ Faster startup           â”œâ”€â”€ Slower startup               â”‚
â”‚  â”œâ”€â”€ Static optimization      â”œâ”€â”€ Dynamic optimization         â”‚
â”‚  â”œâ”€â”€ No runtime overhead      â”œâ”€â”€ Runtime compiler overhead    â”‚
â”‚  â””â”€â”€ Platform specific        â””â”€â”€ Platform independent         â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                 Performance Over Time                     â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â”‚  Performance                                              â”‚  â”‚
â”‚  â”‚  â†‘                         â”Œâ”€â”€â”€â”€â”€â”€â”€ JIT (optimized)      â”‚  â”‚
â”‚  â”‚  â”‚                    ____/                               â”‚  â”‚
â”‚  â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€/â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ AOT                   â”‚  â”‚
â”‚  â”‚  â”‚              __/                                       â”‚  â”‚
â”‚  â”‚  â”‚         ___/                                           â”‚  â”‚
â”‚  â”‚  â”‚       /                                                â”‚  â”‚
â”‚  â”‚  â”‚   JITâ”‚(interpreting + compiling)                       â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ Time          â”‚  â”‚
â”‚  â”‚         Startup    Steady State                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”¥ Hot Spot Detection

### Tiered Compilation:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Tiered Compilation                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Level 0: Interpreter                                           â”‚
â”‚     â””â”€â”€ No compilation, just interpret                          â”‚
â”‚     â””â”€â”€ Fast startup, slow execution                            â”‚
â”‚                                                                 â”‚
â”‚  Level 1: Simple JIT (C1)                                       â”‚
â”‚     â””â”€â”€ Quick compile, basic optimizations                      â”‚
â”‚     â””â”€â”€ Faster than interpreter                                 â”‚
â”‚                                                                 â”‚
â”‚  Level 2: Profiling JIT                                         â”‚
â”‚     â””â”€â”€ Collect execution data                                  â”‚
â”‚     â””â”€â”€ Track hot methods, branch probabilities                 â”‚
â”‚                                                                 â”‚
â”‚  Level 3: Optimizing JIT (C2)                                   â”‚
â”‚     â””â”€â”€ Full optimization for hot code                          â”‚
â”‚     â””â”€â”€ Inlining, loop unrolling, escape analysis               â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚                    Execution Flow                         â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚  â”‚
â”‚  â”‚  â”‚ Interpreter â”‚ â†â”€â”€ All code starts here                 â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                          â”‚  â”‚
â”‚  â”‚         â”‚ Hot?                                            â”‚  â”‚
â”‚  â”‚         â–¼                                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚  â”‚
â”‚  â”‚  â”‚   C1 JIT    â”‚ â†â”€â”€ Quick compile                        â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                                          â”‚  â”‚
â”‚  â”‚         â”‚ Very Hot?                                       â”‚  â”‚
â”‚  â”‚         â–¼                                                 â”‚  â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                          â”‚  â”‚
â”‚  â”‚  â”‚   C2 JIT    â”‚ â†â”€â”€ Full optimization                    â”‚  â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚  â”‚
â”‚  â”‚                                                           â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ› ï¸ JIT Optimization Techniques

### 1. Inline Caching

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Inline Caching                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Problem: Dynamic dispatch is slow (virtual method calls)       â”‚
â”‚                                                                 â”‚
â”‚  Without cache:                                                 â”‚
â”‚  obj.method()  â†’  Lookup type â†’ Find method â†’ Call              â”‚
â”‚                   (slow)                                        â”‚
â”‚                                                                 â”‚
â”‚  With inline cache:                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  if (obj.type == CachedType) {                           â”‚   â”‚
â”‚  â”‚      // Direct call (fast)                               â”‚   â”‚
â”‚  â”‚      call CachedMethod                                   â”‚   â”‚
â”‚  â”‚  } else {                                                â”‚   â”‚
â”‚  â”‚      // Slow path - update cache                         â”‚   â”‚
â”‚  â”‚      lookup and call                                     â”‚   â”‚
â”‚  â”‚      update cache                                        â”‚   â”‚
â”‚  â”‚  }                                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Monomorphic: One type â†’ Super fast                            â”‚
â”‚  Polymorphic: Few types â†’ PIC (Polymorphic Inline Cache)       â”‚
â”‚  Megamorphic: Many types â†’ Fall back to slow lookup            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2. Method Inlining

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    Method Inlining                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Before:                          After Inlining:               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€                        â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€             â”‚
â”‚  int add(int a, int b) {                                        â”‚
â”‚      return a + b;                                              â”‚
â”‚  }                                                              â”‚
â”‚                                                                 â”‚
â”‚  int main() {                     int main() {                  â”‚
â”‚      int x = add(3, 4);   â†’          int x = 3 + 4;            â”‚
â”‚      int y = add(x, 5);              int y = x + 5;            â”‚
â”‚  }                                }                             â”‚
â”‚                                                                 â”‚
â”‚  Benefits:                                                      â”‚
â”‚  â”œâ”€â”€ No function call overhead                                  â”‚
â”‚  â”œâ”€â”€ Enables further optimizations                              â”‚
â”‚  â”œâ”€â”€ Constant folding possible (x = 7)                         â”‚
â”‚  â””â”€â”€ Better register allocation                                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3. Escape Analysis

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Escape Analysis                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Determines if an object "escapes" its creation scope           â”‚
â”‚                                                                 â”‚
â”‚  No Escape (Stack Allocation):                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  void process() {                                        â”‚   â”‚
â”‚  â”‚      Point p = new Point(3, 4);  // p doesn't escape     â”‚   â”‚
â”‚  â”‚      int d = p.x + p.y;          // use only locally     â”‚   â”‚
â”‚  â”‚      return d;                                           â”‚   â”‚
â”‚  â”‚  }                                                       â”‚   â”‚
â”‚  â”‚                                                          â”‚   â”‚
â”‚  â”‚  Optimization: Allocate Point on stack, not heap         â”‚   â”‚
â”‚  â”‚                No GC needed for p                        â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Escape (Heap Required):                                        â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Point getPoint() {                                      â”‚   â”‚
â”‚  â”‚      Point p = new Point(3, 4);                          â”‚   â”‚
â”‚  â”‚      return p;    // p escapes! Must be on heap          â”‚   â”‚
â”‚  â”‚  }                                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                 â”‚
â”‚  Benefits: Stack allocation faster, no GC pressure              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Simple JIT Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>  // For mmap (executable memory)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Bytecode Definition
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    OP_PUSH,     // Push constant
    OP_POP,      // Pop value
    OP_ADD,      // Add top two
    OP_SUB,      // Subtract
    OP_MUL,      // Multiply
    OP_LOAD,     // Load variable
    OP_STORE,    // Store variable
    OP_PRINT,    // Print top
    OP_RET       // Return
} OpCode;

typedef struct {
    OpCode op;
    int arg;
} Instruction;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Interpreter (Baseline)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define MAX_STACK 100
int stack[MAX_STACK];
int sp = 0;
int variables[26];  // a-z

void push(int val) { stack[sp++] = val; }
int pop() { return stack[--sp]; }

int interpret(Instruction* code, int len) {
    printf("\n[Interpreter Mode]\n");
    
    for(int ip = 0; ip < len; ip++) {
        Instruction* instr = &code[ip];
        
        switch(instr->op) {
            case OP_PUSH:
                push(instr->arg);
                printf("  PUSH %d\n", instr->arg);
                break;
                
            case OP_ADD: {
                int b = pop();
                int a = pop();
                push(a + b);
                printf("  ADD: %d + %d = %d\n", a, b, a + b);
                break;
            }
            
            case OP_SUB: {
                int b = pop();
                int a = pop();
                push(a - b);
                printf("  SUB: %d - %d = %d\n", a, b, a - b);
                break;
            }
            
            case OP_MUL: {
                int b = pop();
                int a = pop();
                push(a * b);
                printf("  MUL: %d * %d = %d\n", a, b, a * b);
                break;
            }
            
            case OP_LOAD:
                push(variables[instr->arg]);
                printf("  LOAD var[%d] = %d\n", instr->arg, variables[instr->arg]);
                break;
                
            case OP_STORE:
                variables[instr->arg] = pop();
                printf("  STORE var[%d] = %d\n", instr->arg, variables[instr->arg]);
                break;
                
            case OP_PRINT:
                printf("  PRINT: %d\n", stack[sp - 1]);
                break;
                
            case OP_RET:
                printf("  RET: %d\n", stack[sp - 1]);
                return pop();
        }
    }
    
    return 0;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// JIT Compiler (Conceptual - x86-64)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

/*
 * Note: This is a simplified conceptual example.
 * Real JIT requires platform-specific machine code generation
 * and memory protection handling.
 */

typedef struct {
    unsigned char* code;
    int size;
    int capacity;
} JITCode;

JITCode* createJIT() {
    JITCode* jit = malloc(sizeof(JITCode));
    jit->capacity = 4096;
    jit->size = 0;
    
    // Allocate executable memory (platform specific)
    // On Windows, use VirtualAlloc with PAGE_EXECUTE_READWRITE
    // On Linux, use mmap with PROT_EXEC
    
    #ifdef _WIN32
        // Windows implementation would go here
        jit->code = malloc(jit->capacity);
    #else
        jit->code = mmap(NULL, jit->capacity,
                        PROT_READ | PROT_WRITE | PROT_EXEC,
                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    #endif
    
    return jit;
}

void emitByte(JITCode* jit, unsigned char byte) {
    if(jit->size < jit->capacity) {
        jit->code[jit->size++] = byte;
    }
}

void emitInt32(JITCode* jit, int value) {
    emitByte(jit, value & 0xFF);
    emitByte(jit, (value >> 8) & 0xFF);
    emitByte(jit, (value >> 16) & 0xFF);
    emitByte(jit, (value >> 24) & 0xFF);
}

// x86-64 code generation helpers
void emit_mov_eax_imm(JITCode* jit, int value) {
    // mov eax, imm32
    emitByte(jit, 0xB8);
    emitInt32(jit, value);
    printf("  x86: mov eax, %d\n", value);
}

void emit_add_eax_imm(JITCode* jit, int value) {
    // add eax, imm32
    emitByte(jit, 0x05);
    emitInt32(jit, value);
    printf("  x86: add eax, %d\n", value);
}

void emit_ret(JITCode* jit) {
    // ret
    emitByte(jit, 0xC3);
    printf("  x86: ret\n");
}

void compileToNative(Instruction* bytecode, int len, JITCode* jit) {
    printf("\n[JIT Compilation]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    // Simple JIT: Constant fold at compile time for this example
    // Real JIT would generate actual x86 instructions
    
    int result = 0;
    int temp[100];
    int tempSp = 0;
    
    for(int i = 0; i < len; i++) {
        switch(bytecode[i].op) {
            case OP_PUSH:
                temp[tempSp++] = bytecode[i].arg;
                break;
            case OP_ADD:
                temp[tempSp - 2] = temp[tempSp - 2] + temp[tempSp - 1];
                tempSp--;
                break;
            case OP_MUL:
                temp[tempSp - 2] = temp[tempSp - 2] * temp[tempSp - 1];
                tempSp--;
                break;
            case OP_RET:
                result = temp[tempSp - 1];
                break;
            default:
                break;
        }
    }
    
    // Generate native code for computed result
    emit_mov_eax_imm(jit, result);
    emit_ret(jit);
    
    printf("\n  Compiled %d bytes of machine code\n", jit->size);
    printf("  Machine code: ");
    for(int i = 0; i < jit->size; i++) {
        printf("%02X ", jit->code[i]);
    }
    printf("\n");
}

typedef int (*JITFunc)();

int executeJIT(JITCode* jit) {
    printf("\n[Executing JIT Code]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    // Cast code buffer to function pointer and call
    JITFunc func = (JITFunc)jit->code;
    int result = func();
    
    printf("  Result: %d\n", result);
    return result;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Hot Spot Detection
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define HOT_THRESHOLD 10

typedef struct {
    Instruction* code;
    int len;
    int executionCount;
    JITCode* compiledCode;
    int isCompiled;
} Method;

void executeMethod(Method* method) {
    method->executionCount++;
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("  Method execution #%d\n", method->executionCount);
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    if(!method->isCompiled) {
        if(method->executionCount >= HOT_THRESHOLD) {
            printf("\n  *** Hot spot detected! Triggering JIT ***\n");
            
            method->compiledCode = createJIT();
            compileToNative(method->code, method->len, method->compiledCode);
            method->isCompiled = 1;
        } else {
            printf("  (Not hot yet: %d/%d)\n", 
                   method->executionCount, HOT_THRESHOLD);
            interpret(method->code, method->len);
        }
    }
    
    if(method->isCompiled) {
        printf("\n  Running compiled native code...\n");
        executeJIT(method->compiledCode);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘           JIT Compilation Demo                        â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    // Sample bytecode: (3 + 4) * 2 = 14
    Instruction bytecode[] = {
        {OP_PUSH, 3},
        {OP_PUSH, 4},
        {OP_ADD, 0},
        {OP_PUSH, 2},
        {OP_MUL, 0},
        {OP_RET, 0}
    };
    int len = sizeof(bytecode) / sizeof(bytecode[0]);
    
    printf("\nBytecode: (3 + 4) * 2\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    for(int i = 0; i < len; i++) {
        printf("  %d: ", i);
        switch(bytecode[i].op) {
            case OP_PUSH: printf("PUSH %d\n", bytecode[i].arg); break;
            case OP_ADD:  printf("ADD\n"); break;
            case OP_MUL:  printf("MUL\n"); break;
            case OP_RET:  printf("RET\n"); break;
            default: break;
        }
    }
    
    // Create method with hot spot detection
    Method method = {
        .code = bytecode,
        .len = len,
        .executionCount = 0,
        .compiledCode = NULL,
        .isCompiled = 0
    };
    
    // Execute multiple times to trigger JIT
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("     Simulating repeated execution...\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    for(int i = 0; i < 12; i++) {
        executeMethod(&method);
    }
    
    return 0;
}
```

## ğŸ“‹ JIT Summary

| Feature | JIT | AOT |
|---------|-----|-----|
| Compile Time | Runtime | Build time |
| Startup | Slower | Faster |
| Peak Performance | Can be higher | Fixed |
| Platform | Independent bytecode | Platform specific |
| Optimization | Adaptive | Static |
| Memory | More (compiler + code) | Less |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [LLVM à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿](à§¦à§¨-à¦à¦²à¦à¦²à¦­à¦¿à¦à¦®-à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿.md)
