# ğŸ”§ LLVM à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿

## LLVM à¦•à§€?

**LLVM (Low Level Virtual Machine)** à¦¹à¦²à§‹ à¦à¦•à¦Ÿà¦¿ compiler infrastructure à¦¯à¦¾ modular à¦à¦¬à¦‚ reusable compiler components à¦ªà§à¦°à¦¦à¦¾à¦¨ à¦•à¦°à§‡à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      LLVM Architecture                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    Front Ends                           â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”         â”‚    â”‚
â”‚  â”‚  â”‚Clangâ”‚  â”‚Swiftâ”‚  â”‚Rust â”‚  â”‚Julia â”‚  â”‚ ...  â”‚         â”‚    â”‚
â”‚  â”‚  â”‚(C++) â”‚  â”‚     â”‚  â”‚    â”‚  â”‚      â”‚  â”‚      â”‚         â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜  â””â”€â”€â”¬â”€â”€â”€â”˜         â”‚    â”‚
â”‚  â”‚     â”‚        â”‚        â”‚        â”‚         â”‚              â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚        â”‚        â”‚        â”‚        â”‚         â”‚                   â”‚
â”‚        â–¼        â–¼        â–¼        â–¼         â–¼                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                     LLVM IR                              â”‚    â”‚
â”‚  â”‚              (Intermediate Representation)               â”‚    â”‚
â”‚  â”‚                                                          â”‚    â”‚
â”‚  â”‚  â€¢ Type system (i32, float, pointer, struct, etc.)      â”‚    â”‚
â”‚  â”‚  â€¢ SSA form (Static Single Assignment)                  â”‚    â”‚
â”‚  â”‚  â€¢ Control flow (branches, loops)                       â”‚    â”‚
â”‚  â”‚  â€¢ Low-level operations (load, store, arithmetic)       â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â”‚                                     â”‚
â”‚                           â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    Optimizer                             â”‚    â”‚
â”‚  â”‚  â€¢ Constant propagation   â€¢ Dead code elimination       â”‚    â”‚
â”‚  â”‚  â€¢ Loop optimization      â€¢ Inlining                    â”‚    â”‚
â”‚  â”‚  â€¢ Vectorization          â€¢ Memory optimization         â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                           â”‚                                     â”‚
â”‚                           â–¼                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚                    Back Ends                             â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”           â”‚    â”‚
â”‚  â”‚  â”‚x86  â”‚  â”‚ARM  â”‚  â”‚RISC-Vâ”‚ â”‚WebAsmâ”‚  â”‚ ...  â”‚           â”‚    â”‚
â”‚  â”‚  â”‚     â”‚  â”‚     â”‚  â”‚     â”‚  â”‚     â”‚  â”‚      â”‚           â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”˜           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š LLVM IR (Intermediate Representation)

### LLVM IR Features:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     LLVM IR Features                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. SSA Form (Static Single Assignment)                        â”‚
â”‚     â””â”€â”€ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ variable à¦à¦•à¦¬à¦¾à¦°à¦‡ assign à¦¹à¦¯à¦¼                       â”‚
â”‚     â””â”€â”€ Simplifies analysis and optimization                    â”‚
â”‚                                                                 â”‚
â”‚  2. Three-Address Code Style                                    â”‚
â”‚     â””â”€â”€ %result = add i32 %a, %b                               â”‚
â”‚                                                                 â”‚
â”‚  3. Typed Language                                              â”‚
â”‚     â””â”€â”€ i32, i64, float, double, pointers, etc.                â”‚
â”‚                                                                 â”‚
â”‚  4. Explicit Memory Operations                                  â”‚
â”‚     â””â”€â”€ load, store, alloca, getelementptr                     â”‚
â”‚                                                                 â”‚
â”‚  5. Rich Type System                                            â”‚
â”‚     â””â”€â”€ Vectors, structures, arrays                            â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### LLVM IR Example:

```llvm
; C Code:
; int add(int a, int b) {
;     return a + b;
; }

define i32 @add(i32 %a, i32 %b) {
entry:
    %result = add i32 %a, %b
    ret i32 %result
}

; â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

; C Code:
; int factorial(int n) {
;     if (n <= 1) return 1;
;     return n * factorial(n - 1);
; }

define i32 @factorial(i32 %n) {
entry:
    %cmp = icmp sle i32 %n, 1
    br i1 %cmp, label %base, label %recurse

base:
    ret i32 1

recurse:
    %n_minus_1 = sub i32 %n, 1
    %fact_result = call i32 @factorial(i32 %n_minus_1)
    %result = mul i32 %n, %fact_result
    ret i32 %result
}
```

## ğŸ”§ LLVM Tools

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      LLVM Tools                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  clang     : C/C++/Objective-C compiler frontend               â”‚
â”‚  opt       : LLVM optimizer                                    â”‚
â”‚  llc       : LLVM static compiler (IR â†’ Assembly)              â”‚
â”‚  lli       : LLVM interpreter/JIT                              â”‚
â”‚  llvm-as   : LLVM assembler (.ll â†’ .bc)                        â”‚
â”‚  llvm-dis  : LLVM disassembler (.bc â†’ .ll)                     â”‚
â”‚  llvm-link : LLVM linker                                       â”‚
â”‚                                                                 â”‚
â”‚  Compilation Flow:                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚
â”‚  â”‚                                                        â”‚     â”‚
â”‚  â”‚  source.c  â”€â”€clangâ”€â”€â†’  file.ll  â”€â”€llvm-asâ”€â”€â†’  file.bc â”‚     â”‚
â”‚  â”‚     â”‚                    â”‚                      â”‚      â”‚     â”‚
â”‚  â”‚     â”‚                    â”‚                      â”‚      â”‚     â”‚
â”‚  â”‚     â–¼                    â–¼                      â–¼      â”‚     â”‚
â”‚  â”‚  Human      â—„â”€â”€llvm-disâ”€â”€â”¤        â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤      â”‚     â”‚
â”‚  â”‚  readable                â”‚        Binary       â”‚      â”‚     â”‚
â”‚  â”‚  LLVM IR                 â”‚                     â”‚      â”‚     â”‚
â”‚  â”‚                          â”‚                     â”‚      â”‚     â”‚
â”‚  â”‚                          â–¼                     â–¼      â”‚     â”‚
â”‚  â”‚                       â”€â”€optâ”€â”€â†’  optimized.bc          â”‚     â”‚
â”‚  â”‚                          â”‚                            â”‚     â”‚
â”‚  â”‚                          â–¼                            â”‚     â”‚
â”‚  â”‚                       â”€â”€llcâ”€â”€â†’  assembly.s            â”‚     â”‚
â”‚  â”‚                          â”‚                            â”‚     â”‚
â”‚  â”‚                          â–¼                            â”‚     â”‚
â”‚  â”‚                       â”€â”€asâ”€â”€â”€â†’  object.o              â”‚     â”‚
â”‚  â”‚                          â”‚                            â”‚     â”‚
â”‚  â”‚                          â–¼                            â”‚     â”‚
â”‚  â”‚                       â”€â”€ldâ”€â”€â”€â†’  executable            â”‚     â”‚
â”‚  â”‚                                                        â”‚     â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» LLVM IR Generation Example

```cpp
// simple_frontend.cpp
// A simple frontend that generates LLVM IR

#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Verifier.h"
#include "llvm/Support/raw_ostream.h"

using namespace llvm;

int main() {
    // Create context and module
    LLVMContext Context;
    Module* M = new Module("my_module", Context);
    IRBuilder<> Builder(Context);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Create function: int add(int a, int b) { return a + b; }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Function type: (i32, i32) -> i32
    FunctionType* AddFuncType = FunctionType::get(
        Type::getInt32Ty(Context),                    // Return type
        {Type::getInt32Ty(Context), 
         Type::getInt32Ty(Context)},                  // Parameters
        false                                         // Not variadic
    );
    
    // Create function
    Function* AddFunc = Function::Create(
        AddFuncType,
        Function::ExternalLinkage,
        "add",
        M
    );
    
    // Name parameters
    auto args = AddFunc->arg_begin();
    Value* ArgA = args++;
    ArgA->setName("a");
    Value* ArgB = args++;
    ArgB->setName("b");
    
    // Create entry block
    BasicBlock* Entry = BasicBlock::Create(Context, "entry", AddFunc);
    Builder.SetInsertPoint(Entry);
    
    // Generate: %result = add i32 %a, %b
    Value* Result = Builder.CreateAdd(ArgA, ArgB, "result");
    
    // Generate: ret i32 %result
    Builder.CreateRet(Result);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Create function: int main() { return add(3, 4); }
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    FunctionType* MainFuncType = FunctionType::get(
        Type::getInt32Ty(Context),
        {},
        false
    );
    
    Function* MainFunc = Function::Create(
        MainFuncType,
        Function::ExternalLinkage,
        "main",
        M
    );
    
    BasicBlock* MainEntry = BasicBlock::Create(Context, "entry", MainFunc);
    Builder.SetInsertPoint(MainEntry);
    
    // Call add(3, 4)
    Value* Three = ConstantInt::get(Type::getInt32Ty(Context), 3);
    Value* Four = ConstantInt::get(Type::getInt32Ty(Context), 4);
    Value* CallResult = Builder.CreateCall(AddFunc, {Three, Four}, "call_result");
    
    Builder.CreateRet(CallResult);
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Verify and print
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Verify module
    if (verifyModule(*M, &errs())) {
        errs() << "Error: Module verification failed!\n";
        return 1;
    }
    
    // Print LLVM IR
    M->print(outs(), nullptr);
    
    delete M;
    return 0;
}

/*
Output:
; ModuleID = 'my_module'

define i32 @add(i32 %a, i32 %b) {
entry:
  %result = add i32 %a, %b
  ret i32 %result
}

define i32 @main() {
entry:
  %call_result = call i32 @add(i32 3, i32 4)
  ret i32 %call_result
}
*/
```

## ğŸ“Š LLVM Optimization Passes

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚               LLVM Optimization Passes                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Analysis Passes:                                               â”‚
â”‚  â”œâ”€â”€ -basicaa        : Basic Alias Analysis                    â”‚
â”‚  â”œâ”€â”€ -domtree        : Dominator Tree                          â”‚
â”‚  â”œâ”€â”€ -loops          : Natural Loop Information                â”‚
â”‚  â””â”€â”€ -scalar-evolution : Scalar Evolution Analysis             â”‚
â”‚                                                                 â”‚
â”‚  Transform Passes:                                              â”‚
â”‚  â”œâ”€â”€ -adce           : Aggressive Dead Code Elimination        â”‚
â”‚  â”œâ”€â”€ -constprop      : Constant Propagation                    â”‚
â”‚  â”œâ”€â”€ -dce            : Dead Code Elimination                   â”‚
â”‚  â”œâ”€â”€ -deadargelim    : Dead Argument Elimination               â”‚
â”‚  â”œâ”€â”€ -dse            : Dead Store Elimination                  â”‚
â”‚  â”œâ”€â”€ -gvn            : Global Value Numbering                  â”‚
â”‚  â”œâ”€â”€ -inline         : Function Inlining                       â”‚
â”‚  â”œâ”€â”€ -instcombine    : Instruction Combining                   â”‚
â”‚  â”œâ”€â”€ -licm           : Loop Invariant Code Motion              â”‚
â”‚  â”œâ”€â”€ -loop-unroll    : Loop Unrolling                          â”‚
â”‚  â”œâ”€â”€ -mem2reg        : Promote Memory to Register              â”‚
â”‚  â”œâ”€â”€ -reassociate    : Reassociate Expressions                 â”‚
â”‚  â”œâ”€â”€ -sccp           : Sparse Conditional Constant Propagation â”‚
â”‚  â”œâ”€â”€ -simplifycfg    : Simplify CFG                            â”‚
â”‚  â””â”€â”€ -tailcallelim   : Tail Call Elimination                   â”‚
â”‚                                                                 â”‚
â”‚  Optimization Levels:                                           â”‚
â”‚  â”œâ”€â”€ -O0 : No optimization                                     â”‚
â”‚  â”œâ”€â”€ -O1 : Basic optimizations                                 â”‚
â”‚  â”œâ”€â”€ -O2 : Standard optimizations                              â”‚
â”‚  â”œâ”€â”€ -O3 : Aggressive optimizations                            â”‚
â”‚  â”œâ”€â”€ -Os : Size optimizations                                  â”‚
â”‚  â””â”€â”€ -Oz : Aggressive size optimizations                       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Optimization Example:

```llvm
; Before optimization (unoptimized.ll)
define i32 @example(i32 %x) {
entry:
    %a = add i32 %x, 0        ; Adding 0
    %b = mul i32 %a, 1        ; Multiplying by 1
    %c = add i32 10, 20       ; Constant expression
    %d = add i32 %b, %c       ; Using constant
    ret i32 %d
}

; After: opt -O2 unoptimized.ll -o optimized.ll
define i32 @example(i32 %x) {
entry:
    %d = add i32 %x, 30       ; All simplified!
    ret i32 %d
}
```

## ğŸ”„ Creating a Simple Language with LLVM

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            Simple Language â†’ LLVM Pipeline                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. Lexer (Tokenizer):                                          â”‚
â”‚     "x = 3 + 4"  â†’  [ID:x] [=] [NUM:3] [+] [NUM:4]             â”‚
â”‚                                                                 â”‚
â”‚  2. Parser (AST):                                               â”‚
â”‚          Assign                                                 â”‚
â”‚          /    \                                                 â”‚
â”‚        "x"    Add                                               â”‚
â”‚               / \                                               â”‚
â”‚              3   4                                              â”‚
â”‚                                                                 â”‚
â”‚  3. Code Generator (LLVM IR):                                   â”‚
â”‚     %tmp = add i32 3, 4                                        â”‚
â”‚     store i32 %tmp, i32* @x                                    â”‚
â”‚                                                                 â”‚
â”‚  4. Optimizer:                                                  â”‚
â”‚     store i32 7, i32* @x    ; Constant folded                  â”‚
â”‚                                                                 â”‚
â”‚  5. Backend:                                                    â”‚
â”‚     mov eax, 7                                                 â”‚
â”‚     mov [x], eax                                               â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“‹ LLVM Summary

| Component | Purpose |
|-----------|---------|
| Frontend | Source â†’ LLVM IR |
| LLVM IR | Platform-independent representation |
| Optimizer | Transform/improve IR |
| Backend | LLVM IR â†’ Machine code |
| JIT | Runtime compilation |

---
**à¦à¦Ÿà¦¿ à¦•à¦®à§à¦ªà¦¾à¦‡à¦²à¦¾à¦° à¦¡à¦¿à¦œà¦¾à¦‡à¦¨ à¦¡à¦•à§à¦®à§‡à¦¨à§à¦Ÿà§‡à¦¶à¦¨à§‡à¦° à¦¶à§‡à¦· à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼à¥¤**

[à¦®à§‚à¦² à¦ªà¦¾à¦¤à¦¾à¦¯à¦¼ à¦«à¦¿à¦°à§‡ à¦¯à¦¾à¦¨](../README.md)
