# ğŸ”½ Top-Down Parsing (à¦Ÿà¦ª-à¦¡à¦¾à¦‰à¦¨ à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚)

## Top-Down Parsing à¦•à§€?

**Top-Down Parsing** à¦¹à¦²à§‹ à¦à¦®à¦¨ à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚ à¦ªà¦¦à§à¦§à¦¤à¦¿ à¦¯à§‡à¦–à¦¾à¦¨à§‡ Parse Tree-à¦° Root (Start Symbol) à¦¥à§‡à¦•à§‡ à¦¶à§à¦°à§ à¦•à¦°à§‡ Leaves (Terminals) à¦ªà¦°à§à¦¯à¦¨à§à¦¤ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Top-Down Parsing                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Start Symbol à¦¥à§‡à¦•à§‡ à¦¶à§à¦°à§                                         â”‚
â”‚        â”‚                                                        â”‚
â”‚        â–¼                                                        â”‚
â”‚        E  â†â”€â”€â”€ Root                                             â”‚
â”‚       /|\                                                       â”‚
â”‚      E + T â†â”€â”€ Expand                                           â”‚
â”‚      â”‚   â”‚                                                      â”‚
â”‚      T   F â†â”€â”€ Continue                                         â”‚
â”‚      â”‚   â”‚                                                      â”‚
â”‚      F   id â†â”€ Leaves                                           â”‚
â”‚      â”‚                                                          â”‚
â”‚     id                                                          â”‚
â”‚                                                                 â”‚
â”‚  à¦‰à¦ªà¦° à¦¥à§‡à¦•à§‡ à¦¨à¦¿à¦šà§‡ (Top â†’ Down)                                     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Top-Down Parser-à¦à¦° à¦ªà§à¦°à¦•à¦¾à¦°à¦­à§‡à¦¦

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Top-Down Parsers                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚                    Top-Down                                     â”‚
â”‚                       â”‚                                         â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                           â”‚
â”‚         â”‚                           â”‚                           â”‚
â”‚    With Backtracking          Without Backtracking              â”‚
â”‚         â”‚                           â”‚                           â”‚
â”‚    Recursive                  â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                     â”‚
â”‚    Descent                    â”‚           â”‚                     â”‚
â”‚    (Brute Force)         Predictive    LL(1)                    â”‚
â”‚                          Parser        Parser                   â”‚
â”‚                              â”‚                                  â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚                    â”‚                   â”‚                        â”‚
â”‚              Recursive           Table-Driven                   â”‚
â”‚              Descent             LL(1)                          â”‚
â”‚              Predictive                                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ Recursive Descent Parser

### à¦§à¦¾à¦°à¦£à¦¾:
à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ Non-terminal-à¦à¦° à¦œà¦¨à§à¦¯ à¦à¦•à¦Ÿà¦¿ Function à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

### à¦¸à§à¦¬à¦¿à¦§à¦¾:
- à¦¸à¦¹à¦œ implementation
- Hand-written à¦•à¦°à¦¾ à¦¯à¦¾à¦¯à¦¼
- à¦­à¦¾à¦²à§‹ error messages

### à¦…à¦¸à§à¦¬à¦¿à¦§à¦¾:
- Left-recursive grammar handle à¦•à¦°à¦¤à§‡ à¦ªà¦¾à¦°à§‡ à¦¨à¦¾
- Backtracking à¦ªà§à¦°à¦¯à¦¼à§‹à¦œà¦¨ à¦¹à¦¤à§‡ à¦ªà¦¾à¦°à§‡

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£ Grammar:
```
E  â†’ TE'
E' â†’ +TE' | Îµ
T  â†’ FT'
T' â†’ *FT' | Îµ
F  â†’ (E) | id
```

### Recursive Descent Implementation:

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Token types
typedef enum {
    TOKEN_ID, TOKEN_NUM, TOKEN_PLUS, TOKEN_MINUS,
    TOKEN_MUL, TOKEN_DIV, TOKEN_LPAREN, TOKEN_RPAREN,
    TOKEN_EOF, TOKEN_ERROR
} TokenType;

typedef struct {
    TokenType type;
    char value[50];
} Token;

char* input;
int pos = 0;
Token currentToken;

// Lexer
void getNextToken() {
    // Skip whitespace
    while(input[pos] == ' ' || input[pos] == '\t') pos++;
    
    if(input[pos] == '\0') {
        currentToken.type = TOKEN_EOF;
        return;
    }
    
    if(isalpha(input[pos])) {
        int i = 0;
        while(isalnum(input[pos])) {
            currentToken.value[i++] = input[pos++];
        }
        currentToken.value[i] = '\0';
        currentToken.type = TOKEN_ID;
        return;
    }
    
    if(isdigit(input[pos])) {
        int i = 0;
        while(isdigit(input[pos])) {
            currentToken.value[i++] = input[pos++];
        }
        currentToken.value[i] = '\0';
        currentToken.type = TOKEN_NUM;
        return;
    }
    
    switch(input[pos]) {
        case '+': currentToken.type = TOKEN_PLUS; break;
        case '-': currentToken.type = TOKEN_MINUS; break;
        case '*': currentToken.type = TOKEN_MUL; break;
        case '/': currentToken.type = TOKEN_DIV; break;
        case '(': currentToken.type = TOKEN_LPAREN; break;
        case ')': currentToken.type = TOKEN_RPAREN; break;
        default: currentToken.type = TOKEN_ERROR;
    }
    currentToken.value[0] = input[pos++];
    currentToken.value[1] = '\0';
}

void match(TokenType expected) {
    if(currentToken.type == expected) {
        printf("Matched: %s\n", currentToken.value);
        getNextToken();
    } else {
        printf("Error: Expected token type %d, got %d\n", expected, currentToken.type);
        exit(1);
    }
}

// Forward declarations
void E();
void E_prime();
void T();
void T_prime();
void F();

// E â†’ TE'
void E() {
    printf("E â†’ TE'\n");
    T();
    E_prime();
}

// E' â†’ +TE' | Îµ
void E_prime() {
    if(currentToken.type == TOKEN_PLUS) {
        printf("E' â†’ +TE'\n");
        match(TOKEN_PLUS);
        T();
        E_prime();
    } else {
        printf("E' â†’ Îµ\n");
        // epsilon - do nothing
    }
}

// T â†’ FT'
void T() {
    printf("T â†’ FT'\n");
    F();
    T_prime();
}

// T' â†’ *FT' | Îµ
void T_prime() {
    if(currentToken.type == TOKEN_MUL) {
        printf("T' â†’ *FT'\n");
        match(TOKEN_MUL);
        F();
        T_prime();
    } else {
        printf("T' â†’ Îµ\n");
        // epsilon
    }
}

// F â†’ (E) | id | num
void F() {
    if(currentToken.type == TOKEN_LPAREN) {
        printf("F â†’ (E)\n");
        match(TOKEN_LPAREN);
        E();
        match(TOKEN_RPAREN);
    } else if(currentToken.type == TOKEN_ID) {
        printf("F â†’ id\n");
        match(TOKEN_ID);
    } else if(currentToken.type == TOKEN_NUM) {
        printf("F â†’ num\n");
        match(TOKEN_NUM);
    } else {
        printf("Error: Expected ( or id or num\n");
        exit(1);
    }
}

int main() {
    input = "a + b * c";
    printf("Input: %s\n\n");
    printf("Parsing Steps:\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    getNextToken();  // Get first token
    E();             // Start parsing
    
    if(currentToken.type == TOKEN_EOF) {
        printf("\nâœ“ Parsing successful!\n");
    } else {
        printf("\nâœ— Unexpected tokens remaining\n");
    }
    
    return 0;
}
```

## ğŸ“‹ LL(1) Parser

### LL(1) à¦à¦° à¦…à¦°à§à¦¥:
- **L**: Left-to-right scanning
- **L**: Leftmost derivation
- **1**: 1 lookahead token

### LL(1) Grammar à¦¶à¦°à§à¦¤:
```
Grammar G is LL(1) if and only if:

For every A â†’ Î± | Î²:
1. FIRST(Î±) âˆ© FIRST(Î²) = âˆ…
2. If Îµ âˆˆ FIRST(Î±), then FIRST(Î²) âˆ© FOLLOW(A) = âˆ…
3. If Îµ âˆˆ FIRST(Î²), then FIRST(Î±) âˆ© FOLLOW(A) = âˆ…
```

### LL(1) Parsing Table Construction:

```
Algorithm:
For each production A â†’ Î±:
  1. For each terminal a âˆˆ FIRST(Î±):
     Add A â†’ Î± to M[A, a]
     
  2. If Îµ âˆˆ FIRST(Î±):
     For each terminal b âˆˆ FOLLOW(A):
     Add A â†’ Î± to M[A, b]
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£ Parsing Table:

```
Grammar:
E  â†’ TE'
E' â†’ +TE' | Îµ
T  â†’ FT'
T' â†’ *FT' | Îµ
F  â†’ (E) | id

Parsing Table M:
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     â”‚   id    â”‚    +    â”‚    *    â”‚    (    â”‚    )    â”‚    $    â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  E  â”‚ Eâ†’TE'   â”‚         â”‚         â”‚ Eâ†’TE'   â”‚         â”‚         â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  E' â”‚         â”‚ E'â†’+TE' â”‚         â”‚         â”‚ E'â†’Îµ    â”‚ E'â†’Îµ    â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  T  â”‚ Tâ†’FT'   â”‚         â”‚         â”‚ Tâ†’FT'   â”‚         â”‚         â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  T' â”‚         â”‚ T'â†’Îµ    â”‚ T'â†’*FT' â”‚         â”‚ T'â†’Îµ    â”‚ T'â†’Îµ    â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  F  â”‚ Fâ†’id    â”‚         â”‚         â”‚ Fâ†’(E)   â”‚         â”‚         â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Table-Driven LL(1) Parser

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STACK 100

// Symbols
typedef enum {
    // Non-terminals (0-4)
    SYM_E, SYM_E_PRIME, SYM_T, SYM_T_PRIME, SYM_F,
    // Terminals (5-10)
    SYM_ID, SYM_PLUS, SYM_MUL, SYM_LPAREN, SYM_RPAREN, SYM_EOF,
    // Special
    SYM_EPSILON
} Symbol;

char* symbolNames[] = {
    "E", "E'", "T", "T'", "F",
    "id", "+", "*", "(", ")", "$", "Îµ"
};

// Productions
typedef struct {
    int length;
    Symbol symbols[10];
} Production;

Production productions[] = {
    {2, {SYM_T, SYM_E_PRIME}},           // 0: E â†’ TE'
    {3, {SYM_PLUS, SYM_T, SYM_E_PRIME}}, // 1: E' â†’ +TE'
    {1, {SYM_EPSILON}},                   // 2: E' â†’ Îµ
    {2, {SYM_F, SYM_T_PRIME}},           // 3: T â†’ FT'
    {3, {SYM_MUL, SYM_F, SYM_T_PRIME}},  // 4: T' â†’ *FT'
    {1, {SYM_EPSILON}},                   // 5: T' â†’ Îµ
    {1, {SYM_ID}},                        // 6: F â†’ id
    {3, {SYM_LPAREN, SYM_E, SYM_RPAREN}} // 7: F â†’ (E)
};

// Parsing table: M[non-terminal][terminal] = production number (-1 = error)
int parseTable[5][6] = {
    //  id   +   *   (   )   $
    {   0, -1, -1,  0, -1, -1},  // E
    {  -1,  1, -1, -1,  2,  2},  // E'
    {   3, -1, -1,  3, -1, -1},  // T
    {  -1,  5,  4, -1,  5,  5},  // T'
    {   6, -1, -1,  7, -1, -1}   // F
};

// Stack
Symbol stack[MAX_STACK];
int top = -1;

void push(Symbol s) { stack[++top] = s; }
Symbol pop() { return stack[top--]; }
Symbol peek() { return stack[top]; }
int isEmpty() { return top == -1; }

// Input
Symbol input_tokens[] = {SYM_ID, SYM_PLUS, SYM_ID, SYM_MUL, SYM_ID, SYM_EOF};
int inputPos = 0;

Symbol currentInput() { return input_tokens[inputPos]; }
void advance() { inputPos++; }

void printStack() {
    printf("Stack: ");
    for(int i = 0; i <= top; i++) {
        printf("%s ", symbolNames[stack[i]]);
    }
    printf("\n");
}

int parse() {
    push(SYM_EOF);
    push(SYM_E);  // Start symbol
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("         LL(1) Parsing Steps\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    while(!isEmpty()) {
        printStack();
        printf("Input: %s\n", symbolNames[currentInput()]);
        
        Symbol X = peek();
        Symbol a = currentInput();
        
        if(X == SYM_EOF && a == SYM_EOF) {
            printf("\nâœ“ Parsing successful!\n");
            return 1;
        }
        
        if(X == SYM_EPSILON) {
            pop();
            printf("Action: Pop Îµ\n\n");
            continue;
        }
        
        if(X >= SYM_ID) {  // Terminal
            if(X == a) {
                pop();
                advance();
                printf("Action: Match %s\n\n", symbolNames[X]);
            } else {
                printf("Error: Expected %s, got %s\n", 
                       symbolNames[X], symbolNames[a]);
                return 0;
            }
        } else {  // Non-terminal
            int prodNum = parseTable[X][a - SYM_ID];
            
            if(prodNum == -1) {
                printf("Error: No production for M[%s, %s]\n",
                       symbolNames[X], symbolNames[a]);
                return 0;
            }
            
            pop();
            Production* prod = &productions[prodNum];
            
            printf("Action: Apply %s â†’ ", symbolNames[X]);
            for(int i = 0; i < prod->length; i++) {
                printf("%s", symbolNames[prod->symbols[i]]);
            }
            printf("\n\n");
            
            // Push in reverse order
            for(int i = prod->length - 1; i >= 0; i--) {
                push(prod->symbols[i]);
            }
        }
    }
    
    return 0;
}

int main() {
    printf("Input: id + id * id\n");
    parse();
    return 0;
}
```

## ğŸ“Š Top-Down Parser à¦¤à§à¦²à¦¨à¦¾

| à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯ | Recursive Descent | LL(1) Table-Driven |
|----------|-------------------|---------------------|
| Implementation | à¦¸à¦¹à¦œ | à¦®à¦¾à¦à¦¾à¦°à¦¿ |
| Speed | à¦®à¦¾à¦à¦¾à¦°à¦¿ | à¦¦à§à¦°à§à¦¤ |
| Memory | Stack (function calls) | Explicit stack |
| Error Recovery | à¦­à¦¾à¦²à§‹ | à¦•à¦ à¦¿à¦¨ |
| Maintenance | à¦¸à¦¹à¦œ | à¦•à¦ à¦¿à¦¨ |
| Tool Support | Hand-written | Generated |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [Bottom-Up Parsing](à§¦à§¨-à¦¬à¦Ÿà¦®-à¦†à¦ª-à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚.md)
