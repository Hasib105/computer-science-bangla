# ğŸ”¼ Bottom-Up Parsing (à¦¬à¦Ÿà¦®-à¦†à¦ª à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚)

## Bottom-Up Parsing à¦•à§€?

**Bottom-Up Parsing** à¦¹à¦²à§‹ à¦à¦®à¦¨ à¦ªà¦¾à¦°à§à¦¸à¦¿à¦‚ à¦ªà¦¦à§à¦§à¦¤à¦¿ à¦¯à§‡à¦–à¦¾à¦¨à§‡ Parse Tree-à¦° Leaves (Input Tokens) à¦¥à§‡à¦•à§‡ à¦¶à§à¦°à§ à¦•à¦°à§‡ Root (Start Symbol) à¦ªà¦°à§à¦¯à¦¨à§à¦¤ à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Bottom-Up Parsing                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Input: id + id * id                                            â”‚
â”‚                                                                 â”‚
â”‚       id  id  id  â†â”€â”€ Leaves à¦¥à§‡à¦•à§‡ à¦¶à§à¦°à§                          â”‚
â”‚        |   |   |                                                â”‚
â”‚        F   F   F  â†â”€â”€ Reduce                                    â”‚
â”‚        |   |   |                                                â”‚
â”‚        T   T * F  â†â”€â”€ Reduce                                    â”‚
â”‚        |   â””â”€â”¬â”€â”˜                                                â”‚
â”‚        T     T    â†â”€â”€ Reduce                                    â”‚
â”‚        |     |                                                  â”‚
â”‚        E  +  T    â†â”€â”€ Reduce                                    â”‚
â”‚        â””â”€â”€â”¬â”€â”€â”˜                                                  â”‚
â”‚           E       â†â”€â”€ Root                                      â”‚
â”‚                                                                 â”‚
â”‚  à¦¨à¦¿à¦š à¦¥à§‡à¦•à§‡ à¦‰à¦ªà¦°à§‡ (Bottom â†’ Up)                                    â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”„ Shift-Reduce Parsing

### à¦®à§‚à¦² Operations:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Shift-Reduce Actions                          â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. SHIFT: Input token-à¦•à§‡ Stack-à¦ push à¦•à¦°à¦¾                     â”‚
â”‚                                                                 â”‚
â”‚  2. REDUCE: Stack-à¦à¦° top-à¦ à¦¥à¦¾à¦•à¦¾ symbols-à¦•à§‡                     â”‚
â”‚             production-à¦à¦° LHS à¦¦à¦¿à¦¯à¦¼à§‡ replace à¦•à¦°à¦¾                 â”‚
â”‚                                                                 â”‚
â”‚  3. ACCEPT: Parsing à¦¸à¦«à¦²à¦­à¦¾à¦¬à§‡ à¦¸à¦®à§à¦ªà¦¨à§à¦¨                              â”‚
â”‚                                                                 â”‚
â”‚  4. ERROR: Syntax error à¦¸à¦¨à¦¾à¦•à§à¦¤                                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### à¦‰à¦¦à¦¾à¦¹à¦°à¦£: `id + id * id`

```
Grammar:
E â†’ E + T | T
T â†’ T * F | F
F â†’ id

Parsing Steps:
â”Œâ”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Step â”‚     Stack       â”‚    Input      â”‚       Action         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  1   â”‚ $               â”‚ id + id * id$ â”‚ Shift                â”‚
â”‚  2   â”‚ $ id            â”‚ + id * id$    â”‚ Reduce F â†’ id        â”‚
â”‚  3   â”‚ $ F             â”‚ + id * id$    â”‚ Reduce T â†’ F         â”‚
â”‚  4   â”‚ $ T             â”‚ + id * id$    â”‚ Reduce E â†’ T         â”‚
â”‚  5   â”‚ $ E             â”‚ + id * id$    â”‚ Shift                â”‚
â”‚  6   â”‚ $ E +           â”‚ id * id$      â”‚ Shift                â”‚
â”‚  7   â”‚ $ E + id        â”‚ * id$         â”‚ Reduce F â†’ id        â”‚
â”‚  8   â”‚ $ E + F         â”‚ * id$         â”‚ Reduce T â†’ F         â”‚
â”‚  9   â”‚ $ E + T         â”‚ * id$         â”‚ Shift                â”‚
â”‚ 10   â”‚ $ E + T *       â”‚ id$           â”‚ Shift                â”‚
â”‚ 11   â”‚ $ E + T * id    â”‚ $             â”‚ Reduce F â†’ id        â”‚
â”‚ 12   â”‚ $ E + T * F     â”‚ $             â”‚ Reduce T â†’ T * F     â”‚
â”‚ 13   â”‚ $ E + T         â”‚ $             â”‚ Reduce E â†’ E + T     â”‚
â”‚ 14   â”‚ $ E             â”‚ $             â”‚ Accept               â”‚
â””â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š LR Parser Family

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    LR Parsers                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚                       LR(k)                                     â”‚
â”‚                         â”‚                                       â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚         â”‚               â”‚               â”‚                       â”‚
â”‚       LR(0)           SLR(1)         LR(1)                      â”‚
â”‚     (Simplest)      (Simple LR)   (Canonical)                   â”‚
â”‚         â”‚               â”‚               â”‚                       â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚
â”‚                         â”‚                                       â”‚
â”‚                      LALR(1)                                    â”‚
â”‚                   (Look-Ahead LR)                               â”‚
â”‚                         â”‚                                       â”‚
â”‚                    Most Common                                  â”‚
â”‚                   (Yacc, Bison)                                 â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### LR(k) à¦à¦° à¦…à¦°à§à¦¥:
- **L**: Left-to-right scanning
- **R**: Rightmost derivation (in reverse)
- **k**: k lookahead tokens

## ğŸ“ LR(0) Items à¦“ Parsing

### LR(0) Item:
```
Production with a dot (â€¢) showing parsing progress

A â†’ Î±â€¢Î²
     â”‚
     â””â”€â”€ â€¢ à¦à¦° à¦†à¦—à§‡à¦° à¦…à¦‚à¦¶ à¦¦à§‡à¦–à¦¾ à¦¹à¦¯à¦¼à§‡à¦›à§‡
         â€¢ à¦à¦° à¦ªà¦°à§‡à¦° à¦…à¦‚à¦¶ à¦¦à§‡à¦–à¦¾ à¦¬à¦¾à¦•à¦¿

à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
E â†’ â€¢E + T    (à¦¶à§à¦°à§)
E â†’ Eâ€¢+ T     (E à¦¦à§‡à¦–à¦¾ à¦¹à¦¯à¦¼à§‡à¦›à§‡)
E â†’ E +â€¢T     (E + à¦¦à§‡à¦–à¦¾ à¦¹à¦¯à¦¼à§‡à¦›à§‡)
E â†’ E + Tâ€¢    (à¦¸à¦®à§à¦ªà§‚à¦°à§à¦£ - Reduce!)
```

### Closure Operation:
```
CLOSURE(I):
  Repeat:
    For each item A â†’ Î±â€¢BÎ² in I:
      For each production B â†’ Î³:
        Add B â†’ â€¢Î³ to I
  Until no new items added
```

### GOTO Operation:
```
GOTO(I, X):
  J = empty set
  For each item A â†’ Î±â€¢XÎ² in I:
    Add A â†’ Î±Xâ€¢Î² to J
  Return CLOSURE(J)
```

## ğŸ’» SLR(1) Parser Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_STACK 100
#define NUM_STATES 12
#define NUM_SYMBOLS 10

// Symbols: 0=id, 1=+, 2=*, 3=(, 4=), 5=$, 6=E, 7=T, 8=F
enum Symbol {
    SYM_ID, SYM_PLUS, SYM_MUL, SYM_LPAREN, SYM_RPAREN, SYM_EOF,
    SYM_E, SYM_T, SYM_F
};

char* symNames[] = {"id", "+", "*", "(", ")", "$", "E", "T", "F"};

// Productions
// 0: E â†’ E + T
// 1: E â†’ T
// 2: T â†’ T * F
// 3: T â†’ F
// 4: F â†’ ( E )
// 5: F â†’ id
int prodLHS[] = {SYM_E, SYM_E, SYM_T, SYM_T, SYM_F, SYM_F};
int prodLen[] = {3, 1, 3, 1, 3, 1};

// Action table: positive = shift state, negative = reduce production, 0 = error, 99 = accept
// Format: action[state][terminal]
int actionTable[12][6] = {
    //  id    +    *    (    )    $
    {   5,   0,   0,   4,   0,   0},   // State 0
    {   0,   6,   0,   0,   0,  99},   // State 1
    {   0,  -1,   7,   0,  -1,  -1},   // State 2
    {   0,  -3,  -3,   0,  -3,  -3},   // State 3
    {   5,   0,   0,   4,   0,   0},   // State 4
    {   0,  -5,  -5,   0,  -5,  -5},   // State 5
    {   5,   0,   0,   4,   0,   0},   // State 6
    {   5,   0,   0,   4,   0,   0},   // State 7
    {   0,   6,   0,   0,  11,   0},   // State 8
    {   0,  -0,   7,   0,  -0,  -0},   // State 9
    {   0,  -2,  -2,   0,  -2,  -2},   // State 10
    {   0,  -4,  -4,   0,  -4,  -4}    // State 11
};

// Goto table: gotoTable[state][non-terminal - 6]
int gotoTable[12][3] = {
    //  E   T   F
    {   1,  2,  3},   // State 0
    {   0,  0,  0},   // State 1
    {   0,  0,  0},   // State 2
    {   0,  0,  0},   // State 3
    {   8,  2,  3},   // State 4
    {   0,  0,  0},   // State 5
    {   0,  9, 3},    // State 6
    {   0,  0, 10},   // State 7
    {   0,  0,  0},   // State 8
    {   0,  0,  0},   // State 9
    {   0,  0,  0},   // State 10
    {   0,  0,  0}    // State 11
};

// Stack (stores states)
int stack[MAX_STACK];
int top = -1;

void push(int state) { stack[++top] = state; }
int pop() { return stack[top--]; }
int peek() { return stack[top]; }

// Input
int input[] = {SYM_ID, SYM_PLUS, SYM_ID, SYM_MUL, SYM_ID, SYM_EOF};
int inputPos = 0;

int currentInput() { return input[inputPos]; }

void printStack() {
    printf("Stack: [");
    for(int i = 0; i <= top; i++) {
        printf("%d", stack[i]);
        if(i < top) printf(", ");
    }
    printf("]");
}

int parse() {
    push(0);  // Initial state
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                    SLR(1) Parsing\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    while(1) {
        int state = peek();
        int sym = currentInput();
        int action = actionTable[state][sym];
        
        printStack();
        printf("  Input: %s  ", symNames[sym]);
        
        if(action == 99) {
            printf("Action: ACCEPT\n");
            printf("\nâœ“ Parsing successful!\n");
            return 1;
        }
        else if(action > 0) {
            // Shift
            printf("Action: Shift %d\n", action);
            push(action);
            inputPos++;
        }
        else if(action < 0) {
            // Reduce
            int prod = -action;
            printf("Action: Reduce by production %d\n", prod);
            
            // Pop production length states
            for(int i = 0; i < prodLen[prod]; i++) {
                pop();
            }
            
            // Push goto state
            state = peek();
            int nt = prodLHS[prod];
            int gotoState = gotoTable[state][nt - SYM_E];
            push(gotoState);
        }
        else {
            printf("Action: ERROR\n");
            printf("\nâœ— Parsing failed!\n");
            return 0;
        }
    }
}

int main() {
    printf("Input: id + id * id\n");
    printf("Grammar:\n");
    printf("  E â†’ E + T | T\n");
    printf("  T â†’ T * F | F\n");
    printf("  F â†’ ( E ) | id\n");
    
    parse();
    return 0;
}
```

## ğŸ“‹ LR Parser Comparison

| à¦¬à§ˆà¦¶à¦¿à¦·à§à¦Ÿà§à¦¯ | LR(0) | SLR(1) | LALR(1) | LR(1) |
|----------|-------|--------|---------|-------|
| Power | à¦¸à¦°à§à¦¬à¦¨à¦¿à¦®à§à¦¨ | à¦®à¦¾à¦à¦¾à¦°à¦¿ | à¦¬à§‡à¦¶à¦¿ | à¦¸à¦°à§à¦¬à§‹à¦šà§à¦š |
| States | à¦•à¦® | LR(0) à¦¸à¦®à¦¾à¦¨ | LALR à¦®à¦¾à¦°à§à¦œ | à¦¬à§‡à¦¶à¦¿ |
| Table Size | à¦›à§‹à¦Ÿ | à¦›à§‹à¦Ÿ | à¦®à¦¾à¦à¦¾à¦°à¦¿ | à¦¬à¦¡à¦¼ |
| Tool | - | - | Yacc, Bison | - |

## ğŸ”„ Conflict Resolution

### Shift-Reduce Conflict:
```
Parser uncertain: Shift or Reduce?

à¦‰à¦¦à¦¾à¦¹à¦°à¦£: Dangling else
if E then if E then S else S

Solution: Usually prefer SHIFT
```

### Reduce-Reduce Conflict:
```
Parser uncertain: Which production to reduce?

à¦‰à¦¦à¦¾à¦¹à¦°à¦£:
A â†’ Î±
B â†’ Î±
Stack has Î±, which to use?

Solution: Use precedence/associativity rules
```

## ğŸ“Š LALR(1) vs SLR(1)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                                                                 â”‚
â”‚  SLR(1): Uses FOLLOW(A) for reduce decisions                   â”‚
â”‚          Simpler but less powerful                              â”‚
â”‚                                                                 â”‚
â”‚  LALR(1): Uses specific lookahead for each item                â”‚
â”‚           More precise, handles more grammars                   â”‚
â”‚           Same number of states as SLR(1)                       â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  SLR(1) âŠ‚ LALR(1) âŠ‚ LR(1)                                â”‚  â”‚
â”‚  â”‚  (LALR(1) accepts more grammars than SLR(1))             â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦• à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸](../à§¦à§¬-à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦•-à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸/à§¦à§§-à¦¸à§‡à¦®à¦¾à¦¨à§à¦Ÿà¦¿à¦•-à¦à¦¨à¦¾à¦²à¦¾à¦‡à¦¸à¦¿à¦¸-à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿.md)
