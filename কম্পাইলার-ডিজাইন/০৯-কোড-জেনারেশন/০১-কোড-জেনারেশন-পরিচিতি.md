# ğŸ¯ à¦•à§‹à¦¡ à¦œà§‡à¦¨à¦¾à¦°à§‡à¦¶à¦¨ à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿

## à¦•à§‹à¦¡ à¦œà§‡à¦¨à¦¾à¦°à§‡à¦¶à¦¨ à¦•à§€?

**Code Generation** à¦¹à¦²à§‹ à¦•à¦®à§à¦ªà¦¾à¦‡à¦²à¦¾à¦°à§‡à¦° à¦¶à§‡à¦· à¦«à§‡à¦œ à¦¯à§‡à¦–à¦¾à¦¨à§‡ Intermediate Representation à¦¥à§‡à¦•à§‡ **Target Machine Code** à¦¤à§ˆà¦°à¦¿ à¦•à¦°à¦¾ à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                   Code Generation                               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Intermediate Code                                              â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”‚
â”‚  â”‚         CODE GENERATOR                  â”‚                    â”‚
â”‚  â”‚                                         â”‚                    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚                    â”‚
â”‚  â”‚  â”‚  Instruction Selection            â”‚  â”‚                    â”‚
â”‚  â”‚  â”‚  Register Allocation              â”‚  â”‚                    â”‚
â”‚  â”‚  â”‚  Instruction Ordering             â”‚  â”‚                    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚                    â”‚
â”‚  â”‚                                         â”‚                    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â”‚
â”‚       â”‚                                                         â”‚
â”‚       â–¼                                                         â”‚
â”‚  Target Machine Code (Assembly / Object Code)                   â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Code Generator Tasks

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Code Generator Tasks                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. Instruction Selection                                       â”‚
â”‚     â””â”€â”€ TAC-à¦•à§‡ machine instructions-à¦ map à¦•à¦°à¦¾                   â”‚
â”‚                                                                 â”‚
â”‚  2. Register Allocation                                         â”‚
â”‚     â””â”€â”€ Variables-à¦•à§‡ registers-à¦ assign à¦•à¦°à¦¾                     â”‚
â”‚                                                                 â”‚
â”‚  3. Instruction Ordering                                        â”‚
â”‚     â””â”€â”€ Pipeline-à¦à¦° à¦œà¦¨à§à¦¯ optimal ordering                       â”‚
â”‚                                                                 â”‚
â”‚  4. Memory Management                                           â”‚
â”‚     â””â”€â”€ Stack, heap allocation                                  â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ Target Machine Model

### Simple Machine Model:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Simple Target Machine                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Registers: R0, R1, R2, ..., Rn                                â”‚
â”‚                                                                 â”‚
â”‚  Instruction Format:                                            â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚   OpCode   â”‚   Dest     â”‚   Src1     â”‚   Src2     â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚                                                                 â”‚
â”‚  Addressing Modes:                                              â”‚
â”‚  â”œâ”€â”€ Register:    R1                                            â”‚
â”‚  â”œâ”€â”€ Immediate:   #100                                          â”‚
â”‚  â”œâ”€â”€ Direct:      M (memory address)                            â”‚
â”‚  â”œâ”€â”€ Indirect:    *R1                                           â”‚
â”‚  â””â”€â”€ Indexed:     c(R1) means M[c + contents(R1)]              â”‚
â”‚                                                                 â”‚
â”‚  Common Instructions:                                           â”‚
â”‚  â”œâ”€â”€ LD R, x      : R = x (load)                               â”‚
â”‚  â”œâ”€â”€ ST x, R      : x = R (store)                              â”‚
â”‚  â”œâ”€â”€ ADD R1, R2, R3 : R1 = R2 + R3                             â”‚
â”‚  â”œâ”€â”€ SUB R1, R2, R3 : R1 = R2 - R3                             â”‚
â”‚  â”œâ”€â”€ MUL R1, R2, R3 : R1 = R2 * R3                             â”‚
â”‚  â”œâ”€â”€ DIV R1, R2, R3 : R1 = R2 / R3                             â”‚
â”‚  â”œâ”€â”€ MOV R1, R2     : R1 = R2                                  â”‚
â”‚  â”œâ”€â”€ JMP L          : goto L                                   â”‚
â”‚  â”œâ”€â”€ JZ R, L        : if R == 0 goto L                         â”‚
â”‚  â””â”€â”€ JNZ R, L       : if R != 0 goto L                         â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“ Instruction Selection

### TAC to Assembly Mapping:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Instruction Selection                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  TAC                        Assembly                            â”‚
â”‚  â”€â”€â”€                        â”€â”€â”€â”€â”€â”€â”€â”€                            â”‚
â”‚  x = y + z                  LD  R1, y                          â”‚
â”‚                             LD  R2, z                          â”‚
â”‚                             ADD R3, R1, R2                     â”‚
â”‚                             ST  x, R3                          â”‚
â”‚                                                                 â”‚
â”‚  x = y                      LD  R1, y                          â”‚
â”‚                             ST  x, R1                          â”‚
â”‚                                                                 â”‚
â”‚  x = -y                     LD  R1, y                          â”‚
â”‚                             NEG R1, R1                         â”‚
â”‚                             ST  x, R1                          â”‚
â”‚                                                                 â”‚
â”‚  goto L                     JMP L                              â”‚
â”‚                                                                 â”‚
â”‚  if x < y goto L            LD  R1, x                          â”‚
â”‚                             LD  R2, y                          â”‚
â”‚                             CMP R1, R2                         â”‚
â”‚                             JLT L                              â”‚
â”‚                                                                 â”‚
â”‚  x = a[i]                   LD  R1, i                          â”‚
â”‚                             MUL R1, R1, #4  (element size)     â”‚
â”‚                             LD  R2, a(R1)                      â”‚
â”‚                             ST  x, R2                          â”‚
â”‚                                                                 â”‚
â”‚  a[i] = x                   LD  R1, i                          â”‚
â”‚                             MUL R1, R1, #4                     â”‚
â”‚                             LD  R2, x                          â”‚
â”‚                             ST  a(R1), R2                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ’» Code Generator Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Register Management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define NUM_REGISTERS 8
#define MAX_CODE 1000

typedef struct {
    char* name;        // Variable currently in register
    int isDirty;       // Modified but not written back
    int lastUsed;      // For LRU replacement
} Register;

Register registers[NUM_REGISTERS];
int currentTime = 0;

// Generated assembly code
char* generatedCode[MAX_CODE];
int codeCount = 0;

void initRegisters() {
    for(int i = 0; i < NUM_REGISTERS; i++) {
        registers[i].name = NULL;
        registers[i].isDirty = 0;
        registers[i].lastUsed = 0;
    }
}

// Find register containing variable
int findRegister(char* var) {
    for(int i = 0; i < NUM_REGISTERS; i++) {
        if(registers[i].name != NULL && 
           strcmp(registers[i].name, var) == 0) {
            return i;
        }
    }
    return -1;
}

// Find empty register
int findEmptyRegister() {
    for(int i = 0; i < NUM_REGISTERS; i++) {
        if(registers[i].name == NULL) {
            return i;
        }
    }
    return -1;
}

// Find LRU register (for spilling)
int findLRURegister() {
    int lru = 0;
    int minTime = registers[0].lastUsed;
    
    for(int i = 1; i < NUM_REGISTERS; i++) {
        if(registers[i].lastUsed < minTime) {
            minTime = registers[i].lastUsed;
            lru = i;
        }
    }
    return lru;
}

// Emit assembly instruction
void emit(const char* format, ...) {
    char buffer[256];
    va_list args;
    va_start(args, format);
    vsprintf(buffer, format, args);
    va_end(args);
    
    generatedCode[codeCount] = strdup(buffer);
    codeCount++;
    printf("    %s\n", buffer);
}

// Spill register to memory
void spillRegister(int reg) {
    if(registers[reg].isDirty && registers[reg].name != NULL) {
        emit("ST %s, R%d", registers[reg].name, reg);
    }
    if(registers[reg].name != NULL) {
        free(registers[reg].name);
    }
    registers[reg].name = NULL;
    registers[reg].isDirty = 0;
}

// Get register for variable (load if necessary)
int getReg(char* var) {
    currentTime++;
    
    // Check if already in register
    int reg = findRegister(var);
    if(reg != -1) {
        registers[reg].lastUsed = currentTime;
        return reg;
    }
    
    // Find empty register
    reg = findEmptyRegister();
    if(reg == -1) {
        // Spill LRU register
        reg = findLRURegister();
        spillRegister(reg);
    }
    
    // Load variable into register
    if(isdigit(var[0]) || var[0] == '-') {
        // Immediate value
        emit("LD R%d, #%s", reg, var);
    } else {
        // Variable from memory
        emit("LD R%d, %s", reg, var);
    }
    
    registers[reg].name = strdup(var);
    registers[reg].isDirty = 0;
    registers[reg].lastUsed = currentTime;
    
    return reg;
}

// Get register for result (don't load)
int getResultReg(char* var) {
    currentTime++;
    
    // Check if already in register
    int reg = findRegister(var);
    if(reg != -1) {
        registers[reg].lastUsed = currentTime;
        registers[reg].isDirty = 1;
        return reg;
    }
    
    // Find empty register
    reg = findEmptyRegister();
    if(reg == -1) {
        reg = findLRURegister();
        spillRegister(reg);
    }
    
    registers[reg].name = strdup(var);
    registers[reg].isDirty = 1;
    registers[reg].lastUsed = currentTime;
    
    return reg;
}

// Write all dirty registers back
void flushRegisters() {
    for(int i = 0; i < NUM_REGISTERS; i++) {
        if(registers[i].isDirty && registers[i].name != NULL) {
            // Don't spill temporaries
            if(registers[i].name[0] != 't') {
                emit("ST %s, R%d", registers[i].name, i);
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAC Structure
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef enum {
    TAC_ADD, TAC_SUB, TAC_MUL, TAC_DIV,
    TAC_COPY, TAC_GOTO, TAC_IF_LT, TAC_IF_GT,
    TAC_IF_EQ, TAC_IF_NE, TAC_LABEL, TAC_RETURN,
    TAC_ARRAY_LOAD, TAC_ARRAY_STORE
} TACOp;

typedef struct TAC {
    TACOp op;
    char* result;
    char* arg1;
    char* arg2;
    struct TAC* next;
} TAC;

TAC* tacHead = NULL;
TAC* tacTail = NULL;

TAC* createTAC(TACOp op, char* result, char* arg1, char* arg2) {
    TAC* t = malloc(sizeof(TAC));
    t->op = op;
    t->result = result ? strdup(result) : NULL;
    t->arg1 = arg1 ? strdup(arg1) : NULL;
    t->arg2 = arg2 ? strdup(arg2) : NULL;
    t->next = NULL;
    return t;
}

void addTAC(TAC* t) {
    if(tacTail == NULL) {
        tacHead = tacTail = t;
    } else {
        tacTail->next = t;
        tacTail = t;
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Code Generation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void generateCode(TAC* instr) {
    if(instr == NULL) return;
    
    int r1, r2, r3;
    
    switch(instr->op) {
        case TAC_ADD:
            printf("  // %s = %s + %s\n", instr->result, instr->arg1, instr->arg2);
            r1 = getReg(instr->arg1);
            r2 = getReg(instr->arg2);
            r3 = getResultReg(instr->result);
            emit("ADD R%d, R%d, R%d", r3, r1, r2);
            break;
            
        case TAC_SUB:
            printf("  // %s = %s - %s\n", instr->result, instr->arg1, instr->arg2);
            r1 = getReg(instr->arg1);
            r2 = getReg(instr->arg2);
            r3 = getResultReg(instr->result);
            emit("SUB R%d, R%d, R%d", r3, r1, r2);
            break;
            
        case TAC_MUL:
            printf("  // %s = %s * %s\n", instr->result, instr->arg1, instr->arg2);
            r1 = getReg(instr->arg1);
            r2 = getReg(instr->arg2);
            r3 = getResultReg(instr->result);
            emit("MUL R%d, R%d, R%d", r3, r1, r2);
            break;
            
        case TAC_DIV:
            printf("  // %s = %s / %s\n", instr->result, instr->arg1, instr->arg2);
            r1 = getReg(instr->arg1);
            r2 = getReg(instr->arg2);
            r3 = getResultReg(instr->result);
            emit("DIV R%d, R%d, R%d", r3, r1, r2);
            break;
            
        case TAC_COPY:
            printf("  // %s = %s\n", instr->result, instr->arg1);
            r1 = getReg(instr->arg1);
            r2 = getResultReg(instr->result);
            if(r1 != r2) {
                emit("MOV R%d, R%d", r2, r1);
            }
            break;
            
        case TAC_GOTO:
            printf("  // goto %s\n", instr->result);
            emit("JMP %s", instr->result);
            break;
            
        case TAC_IF_LT:
            printf("  // if %s < %s goto %s\n", instr->arg1, instr->arg2, instr->result);
            r1 = getReg(instr->arg1);
            r2 = getReg(instr->arg2);
            emit("CMP R%d, R%d", r1, r2);
            emit("JLT %s", instr->result);
            break;
            
        case TAC_IF_GT:
            printf("  // if %s > %s goto %s\n", instr->arg1, instr->arg2, instr->result);
            r1 = getReg(instr->arg1);
            r2 = getReg(instr->arg2);
            emit("CMP R%d, R%d", r1, r2);
            emit("JGT %s", instr->result);
            break;
            
        case TAC_LABEL:
            printf("%s:\n", instr->result);
            emit("%s:", instr->result);
            break;
            
        case TAC_RETURN:
            printf("  // return %s\n", instr->arg1 ? instr->arg1 : "");
            if(instr->arg1 != NULL) {
                r1 = getReg(instr->arg1);
                emit("MOV R0, R%d", r1);  // Return value in R0
            }
            emit("RET");
            break;
            
        case TAC_ARRAY_LOAD:
            printf("  // %s = %s[%s]\n", instr->result, instr->arg1, instr->arg2);
            r1 = getReg(instr->arg2);  // Index
            emit("MUL R%d, R%d, #4", r1, r1);  // Scale by 4
            r2 = getResultReg(instr->result);
            emit("LD R%d, %s(R%d)", r2, instr->arg1, r1);
            break;
            
        case TAC_ARRAY_STORE:
            printf("  // %s[%s] = %s\n", instr->result, instr->arg1, instr->arg2);
            r1 = getReg(instr->arg1);  // Index
            emit("MUL R%d, R%d, #4", r1, r1);
            r2 = getReg(instr->arg2);  // Value
            emit("ST %s(R%d), R%d", instr->result, r1, r2);
            break;
    }
}

void generateAllCode() {
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("         Generated Assembly Code\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    for(TAC* t = tacHead; t != NULL; t = t->next) {
        generateCode(t);
    }
    
    flushRegisters();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘           Code Generation Demo                        â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    /*
     * Source: x = a + b * c
     * 
     * TAC:
     * t1 = b * c
     * t2 = a + t1
     * x = t2
     */
    
    printf("\nSource: x = a + b * c\n");
    printf("\nThree-Address Code:\n");
    printf("  t1 = b * c\n");
    printf("  t2 = a + t1\n");
    printf("  x = t2\n");
    
    initRegisters();
    
    addTAC(createTAC(TAC_MUL, "t1", "b", "c"));
    addTAC(createTAC(TAC_ADD, "t2", "a", "t1"));
    addTAC(createTAC(TAC_COPY, "x", "t2", NULL));
    
    generateAllCode();
    
    // More complex example with control flow
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("    Example 2: If-Else Statement\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    printf("\nSource: if (a < b) x = a; else x = b;\n");
    
    // Reset
    tacHead = tacTail = NULL;
    initRegisters();
    codeCount = 0;
    
    addTAC(createTAC(TAC_IF_LT, "L1", "a", "b"));
    addTAC(createTAC(TAC_GOTO, "L2", NULL, NULL));
    addTAC(createTAC(TAC_LABEL, "L1", NULL, NULL));
    addTAC(createTAC(TAC_COPY, "x", "a", NULL));
    addTAC(createTAC(TAC_GOTO, "L3", NULL, NULL));
    addTAC(createTAC(TAC_LABEL, "L2", NULL, NULL));
    addTAC(createTAC(TAC_COPY, "x", "b", NULL));
    addTAC(createTAC(TAC_LABEL, "L3", NULL, NULL));
    
    generateAllCode();
    
    return 0;
}
```

## ğŸ“‹ Code Generation Summary

| Phase | Input | Output |
|-------|-------|--------|
| Instruction Selection | TAC | Assembly template |
| Register Allocation | Variables | Register assignments |
| Instruction Ordering | Instructions | Scheduled instructions |
| Final | All above | Target machine code |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦°à§‡à¦œà¦¿à¦¸à§à¦Ÿà¦¾à¦° à¦…à§à¦¯à¦¾à¦²à§‹à¦•à§‡à¦¶à¦¨](à§¦à§¨-à¦°à§‡à¦œà¦¿à¦¸à§à¦Ÿà¦¾à¦°-à¦…à§à¦¯à¦¾à¦²à§‹à¦•à§‡à¦¶à¦¨.md)
