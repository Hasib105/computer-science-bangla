# ğŸ“¦ à¦°à§‡à¦œà¦¿à¦¸à§à¦Ÿà¦¾à¦° à¦…à§à¦¯à¦¾à¦²à§‹à¦•à§‡à¦¶à¦¨

## à¦°à§‡à¦œà¦¿à¦¸à§à¦Ÿà¦¾à¦° à¦…à§à¦¯à¦¾à¦²à§‹à¦•à§‡à¦¶à¦¨ à¦•à§€?

**Register Allocation** à¦¹à¦²à§‹ à¦ªà§à¦°à§‹à¦—à§à¦°à¦¾à¦®à§‡à¦° variables-à¦•à§‡ limited à¦¸à¦‚à¦–à§à¦¯à¦• CPU registers-à¦ assign à¦•à¦°à¦¾à¦° à¦ªà§à¦°à¦•à§à¦°à¦¿à¦¯à¦¼à¦¾à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Register Allocation                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  à¦¸à¦®à¦¸à§à¦¯à¦¾:                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                        â”‚
â”‚  â”‚   Unlimited         â”‚      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                 â”‚
â”‚  â”‚   Variables         â”‚  â†’   â”‚   Limited     â”‚                 â”‚
â”‚  â”‚   (100+)            â”‚      â”‚   Registers   â”‚                 â”‚
â”‚  â”‚                     â”‚      â”‚   (8-32)      â”‚                 â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                 â”‚
â”‚                                                                 â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€  â”‚
â”‚                                                                 â”‚
â”‚  Register access: ~1 cycle                                      â”‚
â”‚  Memory access: ~100+ cycles                                    â”‚
â”‚                                                                 â”‚
â”‚  Good allocation = Faster program!                              â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Register Allocation Approaches

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Register Allocation Methods                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  1. Simple / Naive                                              â”‚
â”‚     â””â”€â”€ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ TAC-à¦ load/store                                 â”‚
â”‚                                                                 â”‚
â”‚  2. Local (Basic Block)                                         â”‚
â”‚     â””â”€â”€ à¦à¦•à¦Ÿà¦¿ basic block-à¦ registers reuse                      â”‚
â”‚                                                                 â”‚
â”‚  3. Global (Graph Coloring)                                     â”‚
â”‚     â””â”€â”€ Liveness analysis + Interference graph                  â”‚
â”‚                                                                 â”‚
â”‚  4. Linear Scan                                                 â”‚
â”‚     â””â”€â”€ Fast, near-optimal (JIT compilers)                     â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”´ Liveness Analysis

### à¦§à¦¾à¦°à¦£à¦¾:
à¦à¦•à¦Ÿà¦¿ variable "live" à¦¯à¦¦à¦¿ à¦¤à¦¾à¦° current value à¦ªà¦°à§‡ à¦¬à§à¦¯à¦¬à¦¹à¦¾à¦° à¦¹à¦¯à¦¼à¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Liveness Analysis                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Line  â”‚ Statement   â”‚ Live Variables (after statement)        â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
â”‚   1    â”‚ a = 1       â”‚ {a}                                      â”‚
â”‚   2    â”‚ b = 2       â”‚ {a, b}                                   â”‚
â”‚   3    â”‚ c = a + b   â”‚ {b, c}      (a dies after use)          â”‚
â”‚   4    â”‚ d = b * c   â”‚ {c, d}      (b dies)                    â”‚
â”‚   5    â”‚ e = c + d   â”‚ {e}         (c, d die)                  â”‚
â”‚   6    â”‚ return e    â”‚ {}          (e dies)                    â”‚
â”‚                                                                 â”‚
â”‚  Live Range:                                                    â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚
â”‚  a: [1, 3]                                                      â”‚
â”‚  b: [2, 4]                                                      â”‚
â”‚  c: [3, 5]                                                      â”‚
â”‚  d: [4, 5]                                                      â”‚
â”‚  e: [5, 6]                                                      â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Live Variable Equations:

```
For each statement s:
  USE[s] = variables used in s (before definition)
  DEF[s] = variables defined in s
  
  IN[s] = USE[s] âˆª (OUT[s] - DEF[s])
  OUT[s] = âˆª (IN[succ(s)])  for all successors of s
```

## ğŸ¨ Graph Coloring Register Allocation

### Interference Graph:

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Interference Graph                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  Two variables "interfere" if their live ranges overlap         â”‚
â”‚                                                                 â”‚
â”‚  From liveness:        Interference Graph:                      â”‚
â”‚  a: [1, 3]                                                      â”‚
â”‚  b: [2, 4]                   a â”€â”€â”€â”€â”€â”€â”€ b                        â”‚
â”‚  c: [3, 5]                    \       /                         â”‚
â”‚  d: [4, 5]                     \     /                          â”‚
â”‚  e: [5, 6]                      \   /                           â”‚
â”‚                                  \ /                            â”‚
â”‚  Overlaps:                        c                             â”‚
â”‚  a-b (both live at 2,3)          / \                            â”‚
â”‚  b-c (both live at 3,4)         /   \                           â”‚
â”‚  c-d (both live at 4,5)        d â”€â”€â”€ e                          â”‚
â”‚  d-e (both live at 5)                                           â”‚
â”‚                                                                 â”‚
â”‚  Coloring with 2 registers:                                     â”‚
â”‚  R0: a, c, e                                                    â”‚
â”‚  R1: b, d                                                       â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Graph Coloring Algorithm:

```
Algorithm: Chaitin's Graph Coloring

1. Build interference graph
2. Simplify:
   - Find node with degree < k (k = num registers)
   - Remove node from graph, push onto stack
   - Repeat until graph empty or all nodes have degree >= k

3. If stuck (all nodes >= k):
   - Select node to spill
   - Insert spill code
   - Rebuild graph

4. Select (color):
   - Pop nodes from stack
   - Assign color (register) different from neighbors
```

## ğŸ’» Register Allocator Implementation

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Data Structures
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

#define MAX_VARS 20
#define MAX_REGS 4
#define MAX_LINES 100

typedef struct {
    char name[20];
    int start;      // Live range start
    int end;        // Live range end
    int reg;        // Assigned register (-1 = spilled)
    int spilled;
} Variable;

typedef struct {
    int adj[MAX_VARS][MAX_VARS];  // Adjacency matrix
    int numVars;
} InterferenceGraph;

Variable vars[MAX_VARS];
int numVars = 0;
InterferenceGraph graph;

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Live Range Analysis
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int findVar(char* name) {
    for(int i = 0; i < numVars; i++) {
        if(strcmp(vars[i].name, name) == 0) {
            return i;
        }
    }
    return -1;
}

int addVar(char* name) {
    int idx = findVar(name);
    if(idx != -1) return idx;
    
    strcpy(vars[numVars].name, name);
    vars[numVars].start = -1;
    vars[numVars].end = -1;
    vars[numVars].reg = -1;
    vars[numVars].spilled = 0;
    return numVars++;
}

void updateLiveRange(char* name, int line) {
    int idx = addVar(name);
    if(vars[idx].start == -1) {
        vars[idx].start = line;
    }
    vars[idx].end = line;
}

void analyzeLiveness(char* code[], int numLines) {
    printf("\n[Liveness Analysis]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    for(int i = 0; i < numLines; i++) {
        // Parse line: result = arg1 op arg2
        char result[20], arg1[20], op[10], arg2[20];
        int parts = sscanf(code[i], "%s = %s %s %s", result, arg1, op, arg2);
        
        // Update live ranges
        if(parts >= 2) {
            updateLiveRange(result, i);
            if(!isdigit(arg1[0])) {
                updateLiveRange(arg1, i);
            }
        }
        if(parts >= 4 && !isdigit(arg2[0])) {
            updateLiveRange(arg2, i);
        }
    }
    
    // Print live ranges
    for(int i = 0; i < numVars; i++) {
        printf("  %s: [%d, %d]\n", vars[i].name, vars[i].start, vars[i].end);
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Interference Graph
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void buildInterferenceGraph() {
    printf("\n[Building Interference Graph]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    // Initialize
    memset(graph.adj, 0, sizeof(graph.adj));
    graph.numVars = numVars;
    
    // Two variables interfere if their live ranges overlap
    for(int i = 0; i < numVars; i++) {
        for(int j = i + 1; j < numVars; j++) {
            // Check overlap: [a.start, a.end] âˆ© [b.start, b.end]
            int start = vars[i].start > vars[j].start ? 
                        vars[i].start : vars[j].start;
            int end = vars[i].end < vars[j].end ? 
                      vars[i].end : vars[j].end;
            
            if(start <= end) {
                graph.adj[i][j] = 1;
                graph.adj[j][i] = 1;
                printf("  %s interferes with %s\n", 
                       vars[i].name, vars[j].name);
            }
        }
    }
}

int getDegree(int v, int* removed) {
    int degree = 0;
    for(int i = 0; i < numVars; i++) {
        if(!removed[i] && graph.adj[v][i]) {
            degree++;
        }
    }
    return degree;
}

void printInterferenceGraph() {
    printf("\n  Adjacency Matrix:\n    ");
    for(int i = 0; i < numVars; i++) {
        printf("%s ", vars[i].name);
    }
    printf("\n");
    
    for(int i = 0; i < numVars; i++) {
        printf("  %s ", vars[i].name);
        for(int j = 0; j < numVars; j++) {
            printf("%d ", graph.adj[i][j]);
        }
        printf("\n");
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Graph Coloring
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

void colorGraph(int numRegs) {
    printf("\n[Graph Coloring with %d registers]\n", numRegs);
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    int stack[MAX_VARS];
    int stackTop = -1;
    int removed[MAX_VARS] = {0};
    
    // Simplify phase
    printf("\n  Simplify Phase:\n");
    int progress = 1;
    while(progress) {
        progress = 0;
        
        for(int i = 0; i < numVars; i++) {
            if(removed[i]) continue;
            
            int degree = getDegree(i, removed);
            if(degree < numRegs) {
                printf("    Push %s (degree %d)\n", vars[i].name, degree);
                stack[++stackTop] = i;
                removed[i] = 1;
                progress = 1;
            }
        }
    }
    
    // Check for spills
    for(int i = 0; i < numVars; i++) {
        if(!removed[i]) {
            printf("    SPILL %s (degree >= %d)\n", vars[i].name, numRegs);
            vars[i].spilled = 1;
            vars[i].reg = -1;
            stack[++stackTop] = i;
            removed[i] = 1;
        }
    }
    
    // Select phase (assign colors)
    printf("\n  Select Phase:\n");
    while(stackTop >= 0) {
        int v = stack[stackTop--];
        
        if(vars[v].spilled) {
            printf("    %s: SPILLED (memory)\n", vars[v].name);
            continue;
        }
        
        // Find available color
        int usedColors[MAX_REGS] = {0};
        for(int i = 0; i < numVars; i++) {
            if(graph.adj[v][i] && vars[i].reg != -1) {
                usedColors[vars[i].reg] = 1;
            }
        }
        
        // Assign first available color
        for(int c = 0; c < numRegs; c++) {
            if(!usedColors[c]) {
                vars[v].reg = c;
                printf("    %s: R%d\n", vars[v].name, c);
                break;
            }
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Linear Scan Allocation
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

typedef struct {
    int varIdx;
    int reg;
} ActiveInterval;

ActiveInterval active[MAX_VARS];
int numActive = 0;

void expireOld(int point) {
    int j = 0;
    for(int i = 0; i < numActive; i++) {
        if(vars[active[i].varIdx].end >= point) {
            active[j++] = active[i];
        }
    }
    numActive = j;
}

void linearScanAlloc(int numRegs) {
    printf("\n[Linear Scan Allocation]\n");
    printf("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
    
    // Sort variables by start point
    // (Simple bubble sort for demo)
    for(int i = 0; i < numVars - 1; i++) {
        for(int j = 0; j < numVars - i - 1; j++) {
            if(vars[j].start > vars[j+1].start) {
                Variable temp = vars[j];
                vars[j] = vars[j+1];
                vars[j+1] = temp;
            }
        }
    }
    
    int freeRegs[MAX_REGS];
    int numFree = numRegs;
    for(int i = 0; i < numRegs; i++) freeRegs[i] = i;
    
    numActive = 0;
    
    for(int i = 0; i < numVars; i++) {
        // Expire old intervals
        int point = vars[i].start;
        for(int j = 0; j < numActive; ) {
            if(vars[active[j].varIdx].end < point) {
                // Free this register
                freeRegs[numFree++] = active[j].reg;
                printf("  Freed R%d at point %d (from %s)\n", 
                       active[j].reg, point, vars[active[j].varIdx].name);
                
                // Remove from active
                active[j] = active[--numActive];
            } else {
                j++;
            }
        }
        
        if(numFree > 0) {
            // Allocate register
            int reg = freeRegs[--numFree];
            vars[i].reg = reg;
            vars[i].spilled = 0;
            
            active[numActive].varIdx = i;
            active[numActive].reg = reg;
            numActive++;
            
            printf("  %s: R%d (range [%d, %d])\n", 
                   vars[i].name, reg, vars[i].start, vars[i].end);
        } else {
            // Spill
            vars[i].reg = -1;
            vars[i].spilled = 1;
            printf("  %s: SPILLED\n", vars[i].name);
        }
    }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Demo
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

int main() {
    printf("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\n");
    printf("â•‘          Register Allocation Demo                     â•‘\n");
    printf("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    /*
     * Sample code:
     * 0: a = 1
     * 1: b = 2
     * 2: c = a + b
     * 3: d = b * c
     * 4: e = c + d
     * 5: return e
     */
    
    char* code[] = {
        "a = 1",
        "b = 2",
        "c = a + b",
        "d = b * c",
        "e = c + d",
        "f = e"
    };
    int numLines = 6;
    
    printf("\nSample Code:\n");
    for(int i = 0; i < numLines; i++) {
        printf("  %d: %s\n", i, code[i]);
    }
    
    // Method 1: Graph Coloring
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("            Method 1: Graph Coloring\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    analyzeLiveness(code, numLines);
    buildInterferenceGraph();
    printInterferenceGraph();
    colorGraph(3);  // 3 registers
    
    printf("\n  Final Allocation:\n");
    for(int i = 0; i < numVars; i++) {
        if(vars[i].spilled) {
            printf("    %s: MEMORY\n", vars[i].name);
        } else {
            printf("    %s: R%d\n", vars[i].name, vars[i].reg);
        }
    }
    
    // Reset for Method 2
    for(int i = 0; i < numVars; i++) {
        vars[i].reg = -1;
        vars[i].spilled = 0;
    }
    
    // Method 2: Linear Scan
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("            Method 2: Linear Scan\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    
    linearScanAlloc(3);
    
    printf("\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n");
    printf("                  Summary\n");
    printf("â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n\n");
    
    printf("  Graph Coloring: Optimal but O(nÂ²) or worse\n");
    printf("  Linear Scan:    Near-optimal, O(n log n)\n");
    printf("\n  Use Linear Scan for JIT compilers (speed matters)\n");
    printf("  Use Graph Coloring for AOT compilers (quality matters)\n");
    
    return 0;
}
```

## ğŸ“‹ Summary

| Method | Complexity | Quality | Use Case |
|--------|------------|---------|----------|
| Graph Coloring | O(nÂ²) | Optimal | AOT compilers |
| Linear Scan | O(n log n) | Near-optimal | JIT compilers |
| Simple | O(n) | Poor | Debug builds |

---
**à¦ªà¦°à¦¬à¦°à§à¦¤à§€ à¦…à¦§à§à¦¯à¦¾à¦¯à¦¼**: [à¦°à¦¾à¦¨à¦Ÿà¦¾à¦‡à¦® à¦à¦¨à¦­à¦¾à¦¯à¦¼à¦°à¦¨à¦®à§‡à¦¨à§à¦Ÿ](../à§§à§¦-à¦°à¦¾à¦¨à¦Ÿà¦¾à¦‡à¦®-à¦à¦¨à¦­à¦¾à¦¯à¦¼à¦°à¦¨à¦®à§‡à¦¨à§à¦Ÿ/à§¦à§§-à¦°à¦¾à¦¨à¦Ÿà¦¾à¦‡à¦®-à¦ªà¦°à¦¿à¦šà¦¿à¦¤à¦¿.md)
