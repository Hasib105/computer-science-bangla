# Merkle Trees

## ğŸ¯ Merkle Tree à¦•à¦¿?

**Merkle Tree** (Hash Tree) à¦¹à¦²à§‹ à¦à¦®à¦¨ à¦à¦•à¦Ÿà¦¿ tree structure à¦¯à§‡à¦–à¦¾à¦¨à§‡ à¦ªà§à¦°à¦¤à¦¿à¦Ÿà¦¿ leaf node data-à¦° hash à¦à¦¬à¦‚ non-leaf nodes à¦¤à¦¾à¦¦à§‡à¦° children-à¦à¦° combined hashà¥¤

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Merkle Tree                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚                        Root Hash                                 â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                              â”‚
â”‚                    â”‚  H(H12+H34) â”‚                              â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜                              â”‚
â”‚                           â”‚                                      â”‚
â”‚              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                        â”‚
â”‚              â”‚                         â”‚                         â”‚
â”‚        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”            â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                   â”‚
â”‚        â”‚   H12     â”‚            â”‚   H34     â”‚                   â”‚
â”‚        â”‚ H(H1+H2)  â”‚            â”‚ H(H3+H4)  â”‚                   â”‚
â”‚        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜            â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜                   â”‚
â”‚              â”‚                        â”‚                          â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”                   â”‚
â”‚       â”‚             â”‚         â”‚             â”‚                    â”‚
â”‚   â”Œâ”€â”€â”€â”´â”€â”€â”€â”    â”Œâ”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”    â”Œâ”€â”€â”€â”´â”€â”€â”€â”               â”‚
â”‚   â”‚  H1   â”‚    â”‚  H2   â”‚ â”‚  H3   â”‚    â”‚  H4   â”‚               â”‚
â”‚   â”‚H(D1)  â”‚    â”‚H(D2)  â”‚ â”‚H(D3)  â”‚    â”‚H(D4)  â”‚               â”‚
â”‚   â””â”€â”€â”€â”¬â”€â”€â”€â”˜    â””â”€â”€â”€â”¬â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”˜    â””â”€â”€â”€â”¬â”€â”€â”€â”˜               â”‚
â”‚       â”‚            â”‚         â”‚            â”‚                     â”‚
â”‚   â”Œâ”€â”€â”€â”´â”€â”€â”€â”    â”Œâ”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”    â”Œâ”€â”€â”€â”´â”€â”€â”€â”               â”‚
â”‚   â”‚ Data1 â”‚    â”‚ Data2 â”‚ â”‚ Data3 â”‚    â”‚ Data4 â”‚               â”‚
â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ“Š Key Properties

```
1. Root Hash = Fingerprint of entire dataset
   - Any data change â†’ Root hash changes
   
2. Efficient Verification
   - Verify any piece without downloading all data
   
3. Efficient Sync
   - Find differences by comparing hashes
```

## ğŸ”„ Verification Example

```
Verify Data3 without downloading all data:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  Merkle Proof for Data3                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                  â”‚
â”‚  To verify Data3, you need:                                     â”‚
â”‚  1. Data3 itself                                                â”‚
â”‚  2. H4 (sibling)                                                â”‚
â”‚  3. H12 (uncle)                                                 â”‚
â”‚  4. Root Hash (known/trusted)                                   â”‚
â”‚                                                                  â”‚
â”‚                     Root Hash â†â”€â”€â”                              â”‚
â”‚                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ 4. Compare                   â”‚
â”‚                    â”‚           â”‚ â”‚                              â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜ â”‚                              â”‚
â”‚                          â”‚       â”‚                              â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚
â”‚           â”‚                             â”‚                       â”‚
â”‚     â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”               â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚     â”‚    H12    â”‚ â†â”€ 3. Given   â”‚  Calculate    â”‚              â”‚
â”‚     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚  H(H3 + H4)   â”‚              â”‚
â”‚                                 â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                                         â”‚                       â”‚
â”‚                              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚                              â”‚                     â”‚            â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”      â”‚
â”‚                        â”‚Calculate  â”‚        â”‚    H4     â”‚      â”‚
â”‚                        â”‚ H(Data3)  â”‚        â”‚ â† 2. Givenâ”‚      â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚                              â”‚                                  â”‚
â”‚                        â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                           â”‚
â”‚                        â”‚   Data3   â”‚ â† 1. Your data            â”‚
â”‚                        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                           â”‚
â”‚                                                                  â”‚
â”‚  Proof size: O(log n) instead of O(n)                          â”‚
â”‚                                                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ”§ Data Synchronization

```
Anti-Entropy with Merkle Trees:

Node A                          Node B
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Root: abc123   â”‚              â”‚ Root: abc123   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                               â”‚
         â”‚â†â”€â”€ Compare Roots â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’â”‚
         â”‚      Same! Synced             â”‚
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

If different:
Node A                          Node B
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Root: abc123   â”‚              â”‚ Root: xyz789   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜              â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                               â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚         â”‚                    â”‚         â”‚
  H12       H34                  H12       H34'
  same      different!           same      (different)
            â”‚                              â”‚
       â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
       â”‚         â”‚                    â”‚         â”‚
      H3        H4                   H3'       H4
      diff!     same                 (diff!)   same

Only sync Data3! (Not entire dataset)
```

## ğŸ’¡ Use Cases

```
1. Git
   - Commits are merkle tree nodes
   - Efficient diff and merge

2. Blockchain (Bitcoin, Ethereum)
   - Transaction verification
   - Light clients

3. Cassandra / DynamoDB
   - Anti-entropy repair
   - Replica synchronization

4. IPFS
   - Content addressing
   - Deduplication

5. Certificate Transparency
   - Append-only logs
```

## ğŸ”§ Implementation

```python
import hashlib

class MerkleTree:
    def __init__(self, data_blocks):
        self.leaves = [self._hash(d) for d in data_blocks]
        self.root = self._build_tree(self.leaves)
    
    def _hash(self, data):
        if isinstance(data, str):
            data = data.encode()
        return hashlib.sha256(data).hexdigest()
    
    def _build_tree(self, nodes):
        if len(nodes) == 1:
            return nodes[0]
        
        if len(nodes) % 2 == 1:
            nodes.append(nodes[-1])  # Duplicate last
        
        parent_level = []
        for i in range(0, len(nodes), 2):
            combined = nodes[i] + nodes[i+1]
            parent_level.append(self._hash(combined))
        
        return self._build_tree(parent_level)
    
    def get_root(self):
        return self.root

# Usage
data = ["block1", "block2", "block3", "block4"]
tree = MerkleTree(data)
print(f"Root: {tree.get_root()}")
```

## âœ… Benefits

```
âœ“ Efficient verification: O(log n)
âœ“ Tamper detection
âœ“ Efficient sync (only changed parts)
âœ“ Space efficient proofs
```

---

ğŸ‰ à¦…à§à¦¯à¦¾à¦¡à¦­à¦¾à¦¨à§à¦¸à¦¡ à¦•à¦¨à¦¸à§‡à¦ªà§à¦Ÿ à¦¸à§‡à¦•à¦¶à¦¨ à¦¸à¦®à§à¦ªà§‚à¦°à§à¦£!

[à¦®à¦¨à¦¿à¦Ÿà¦°à¦¿à¦‚ à¦“ à¦…à¦¬à¦œà¦¾à¦°à§à¦­à§‡à¦¬à¦¿à¦²à¦¿à¦Ÿà¦¿ â†’](../13-monitoring/README.md)
