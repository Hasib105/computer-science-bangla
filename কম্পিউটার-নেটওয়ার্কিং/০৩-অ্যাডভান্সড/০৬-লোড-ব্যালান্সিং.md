# লোড ব্যালান্সিং (Load Balancing)

## 📖 Load Balancing কী?

**Load Balancing** হলো incoming network traffic কে **multiple servers** এর মধ্যে ভাগ করে দেওয়া, যেন কোনো একটি server অতিরিক্ত চাপে না পড়ে।

```
Without Load Balancer:                With Load Balancer:

     Users                                  Users
       │                              ┌───────┼───────┐
       │                              ↓       ↓       ↓
       ▼                           ┌─────────────────────┐
    ┌──────┐                       │   Load Balancer     │
    │Server│ ← Overloaded!         └──────────┬──────────┘
    └──────┘                            ┌─────┼─────┐
                                        ↓     ↓     ↓
                                     ┌────┐┌────┐┌────┐
                                     │ S1 ││ S2 ││ S3 │
                                     └────┘└────┘└────┘
                                     Distributed load!
```

---

## 🤔 Load Balancing কেন দরকার?

```
┌─────────────────────────────────────────────────────────┐
│              Load Balancing Benefits                     │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  ⚡ High Availability (HA)                              │
│     - একটি server down হলেও service চলবে               │
│                                                          │
│  📈 Scalability                                         │
│     - Traffic বাড়লে server add করা যায়                 │
│                                                          │
│  🚀 Performance                                         │
│     - Response time কমে যায়                            │
│                                                          │
│  🔧 Maintenance                                         │
│     - এক server update করতে অন্যগুলো চালু থাকে          │
│                                                          │
│  💰 Cost Efficiency                                     │
│     - একটি বড় server এর বদলে অনেক ছোট server           │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

---

## 📊 Load Balancer এর প্রকারভেদ

### Layer 4 vs Layer 7

```
OSI Model:

Layer 7 - Application  ←── L7 Load Balancer (HTTP/HTTPS)
Layer 6 - Presentation
Layer 5 - Session
Layer 4 - Transport    ←── L4 Load Balancer (TCP/UDP)
Layer 3 - Network
Layer 2 - Data Link
Layer 1 - Physical
```

### Layer 4 Load Balancer

```
┌─────────────────────────────────────────────────────────┐
│              Layer 4 (Transport Layer)                   │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  দেখে:                                                   │
│  • Source/Destination IP                                │
│  • Source/Destination Port                              │
│  • TCP/UDP protocol                                     │
│                                                          │
│  দেখে না:                                               │
│  • HTTP headers                                         │
│  • URL path                                             │
│  • Cookies                                              │
│                                                          │
│  সুবিধা:           অসুবিধা:                             │
│  • Very fast       • Content বুঝে না                    │
│  • Simple          • Limited routing options            │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### Layer 7 Load Balancer

```
┌─────────────────────────────────────────────────────────┐
│            Layer 7 (Application Layer)                   │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  দেখে (L4 এর সব + extra):                               │
│  • HTTP/HTTPS content                                   │
│  • URL path (/api, /images, /static)                    │
│  • Headers (Host, User-Agent)                           │
│  • Cookies (session info)                               │
│  • Request body                                         │
│                                                          │
│  Intelligent Routing Examples:                          │
│  /api/*     → API Servers                               │
│  /images/*  → CDN                                       │
│  /admin/*   → Admin Servers                             │
│                                                          │
│  সুবিধা:               অসুবিধা:                         │
│  • Smart routing       • Slower (inspect content)       │
│  • SSL termination     • More complex                   │
│  • Content switching                                    │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### L4 vs L7 তুলনা

```
                L4 LB                    L7 LB
            ┌─────────┐              ┌─────────┐
            │   LB    │              │   LB    │
            └────┬────┘              └────┬────┘
                 │                        │
          Sees:  │                 Sees:  │
          IP:Port│                 GET /api/users
                 │                 Host: api.example.com
                 │                 Cookie: session=abc
                 ↓                        ↓
         ┌───────┼───────┐       Path-based routing:
         ↓       ↓       ↓       /api → Server 1
      Server  Server  Server     /web → Server 2
        1       2       3        /cdn → CDN
```

---

## ⚖️ Load Balancing Algorithms

### ১. Round Robin

```
সবচেয়ে simple - ঘুরে ঘুরে প্রত্যেককে

Request 1 → Server A
Request 2 → Server B
Request 3 → Server C
Request 4 → Server A  (repeat)
Request 5 → Server B
...

    A → B → C → A → B → C → ...
```

### ২. Weighted Round Robin

```
Server capacity অনুযায়ী weight

Server A (weight=3): পাবে 3 requests
Server B (weight=2): পাবে 2 requests
Server C (weight=1): পাবে 1 request

Pattern: A, A, A, B, B, C, A, A, A, B, B, C...

┌────────────┐
│ Server A   │ ████████████ (50%)
│ Weight: 3  │
├────────────┤
│ Server B   │ ████████ (33%)
│ Weight: 2  │
├────────────┤
│ Server C   │ ████ (17%)
│ Weight: 1  │
└────────────┘
```

### ৩. Least Connections

```
যে server এ সবচেয়ে কম active connections, তাকে দাও

Current state:
Server A: 15 connections
Server B: 8 connections  ← New request যাবে এখানে!
Server C: 12 connections

Long-lived connections এ ভালো কাজ করে
(WebSocket, database connections)
```

### ৪. IP Hash

```
Client IP hash করে consistent server select

Client IP: 192.168.1.100
Hash: hash(192.168.1.100) = 7842
Server: 7842 % 3 = Server B

Same client always goes to same server!
(Session persistence এ কাজে লাগে)

┌─────────────────────────────────────┐
│ IP: 192.168.1.100 → Always Server B │
│ IP: 192.168.1.101 → Always Server A │
│ IP: 192.168.1.102 → Always Server C │
└─────────────────────────────────────┘
```

### ৫. Least Response Time

```
যে server সবচেয়ে দ্রুত respond করে, তাকে দাও

Server A: 50ms avg response
Server B: 30ms avg response  ← নতুন request এখানে!
Server C: 45ms avg response

Performance optimize করে
```

### Algorithm তুলনা

| Algorithm | Use Case | Session? |
|-----------|----------|----------|
| Round Robin | Equal servers | No |
| Weighted RR | Different capacity | No |
| Least Connections | Long connections | No |
| IP Hash | Session sticky | Yes |
| Least Response | Performance critical | No |

---

## ❤️ Health Checks

Load balancer কীভাবে জানে server সচল আছে কিনা?

```
Health Check Process:

Load Balancer             Server
     │                       │
     │──── HTTP GET /health ─→│
     │                       │
     │←── 200 OK ────────────│  ✓ Healthy
     │                       │
     │──── HTTP GET /health ─→│
     │                       │
     │←── 500 Error ─────────│  ✗ Unhealthy
     │                       │     (Remove from pool)
```

### Health Check Types

```
┌─────────────────────────────────────────────────────────┐
│                Health Check Methods                      │
├─────────────────────────────────────────────────────────┤
│                                                          │
│  TCP Check:                                             │
│  - Port open কিনা check করে                            │
│  - Simple, fast                                         │
│                                                          │
│  HTTP Check:                                            │
│  - HTTP request পাঠায়                                  │
│  - Response code check (200 OK expected)                │
│  - /health বা /status endpoint                          │
│                                                          │
│  Custom Script:                                         │
│  - Database connection verify                           │
│  - Disk space check                                     │
│  - Custom logic                                         │
│                                                          │
└─────────────────────────────────────────────────────────┘
```

### Healthy vs Unhealthy

```
Server Pool:

┌────────┐ ✓ Healthy - receives traffic
│Server 1│────────────────────→ In Pool
└────────┘

┌────────┐ ✓ Healthy - receives traffic
│Server 2│────────────────────→ In Pool
└────────┘

┌────────┐ ✗ Failed 3 checks
│Server 3│────────────────────→ Removed
└────────┘                      (No traffic)

After recovery:
┌────────┐ ✓ Passed checks again
│Server 3│────────────────────→ Back in Pool
└────────┘
```

---

## 🔄 Session Persistence (Sticky Sessions)

কিছু application এ same user same server এ যেতে হয়।

```
Without Sticky Sessions:
User → Server A (login, session created)
User → Server B (no session! redirected to login)
User → Server C (no session! redirected to login)
Frustrating!


With Sticky Sessions:
User → Server A (login, session created)
User → Server A (same server, session exists)
User → Server A (same server, session exists)
Works!
```

### Sticky Session Methods

```
1. Cookie-based:
   LB inserts cookie: SERVERID=server-a
   Browser sends cookie on every request
   LB reads cookie, routes to same server

2. IP-based:
   Same source IP → Same server
   Problem: NAT users all go to same server

3. Application-based:
   App manages session ID
   LB reads session ID, routes accordingly
```

---

## 🔐 SSL/TLS Termination

```
SSL Termination at Load Balancer:

Client                Load Balancer              Servers
  │                        │                        │
  │←──── HTTPS (443) ─────→│←───── HTTP (80) ──────→│
  │     Encrypted          │      Unencrypted       │
  │                        │                        │

সুবিধা:
✓ Servers CPU save হয় (no SSL processing)
✓ এক জায়গায় certificate manage
✓ LB content inspect করতে পারে

⚠️ LB থেকে server পর্যন্ত unencrypted
   Internal network secure হতে হবে
```

### End-to-End Encryption

```
SSL Passthrough:

Client                Load Balancer              Servers
  │                        │                        │
  │←──── HTTPS ───────────→│←──── HTTPS ──────────→│
  │     Encrypted          │      Encrypted        │
  │                        │                        │

LB can't inspect content, but full encryption
```

---

## 🏗️ Load Balancer Architecture

### Active-Passive (HA)

```
┌─────────────────────────────────────────────┐
│                                             │
│    ┌──────────┐         ┌──────────┐       │
│    │  Active  │ ←─────→ │ Passive  │       │
│    │    LB    │ Heartbeat│   LB     │       │
│    └────┬─────┘         └─────┬────┘       │
│         │                     │ (standby)  │
│         ↓                     ↓            │
│      Traffic              No traffic       │
│      flows               until failover    │
│                                             │
└─────────────────────────────────────────────┘

If Active fails:
Passive becomes Active (VIP moves)
```

### Active-Active

```
┌─────────────────────────────────────────────┐
│                                             │
│    ┌──────────┐         ┌──────────┐       │
│    │    LB    │         │    LB    │       │
│    │    1     │         │    2     │       │
│    └────┬─────┘         └────┬─────┘       │
│         │                    │             │
│         ↓                    ↓             │
│      Traffic             Traffic           │
│      50%                 50%               │
│                                             │
└─────────────────────────────────────────────┘

Both share load
DNS or GSLB distributes to both
```

---

## 🌐 Popular Load Balancers

### Software Load Balancers

```
┌─────────────────────────────────────────────────────────┐
│              Software Load Balancers                     │
├──────────────┬──────────────────────────────────────────┤
│ NGINX        │ Very popular, L4 & L7, free/paid        │
│ HAProxy      │ High performance, L4 & L7, free         │
│ Traefik      │ Modern, container-friendly              │
│ Envoy        │ Cloud-native, service mesh              │
└──────────────┴──────────────────────────────────────────┘
```

### Cloud Load Balancers

```
┌─────────────────────────────────────────────────────────┐
│                Cloud Load Balancers                      │
├──────────────┬──────────────────────────────────────────┤
│ AWS          │ ALB (L7), NLB (L4), CLB (legacy)        │
│ Azure        │ Azure Load Balancer, Application GW     │
│ GCP          │ Cloud Load Balancing                    │
│ Cloudflare   │ Cloudflare Load Balancing               │
└──────────────┴──────────────────────────────────────────┘
```

### Hardware Load Balancers

```
F5 BIG-IP, Citrix ADC, A10 Networks
(Enterprise grade, expensive, very high performance)
```

---

## 💻 NGINX Load Balancer Config Example

```nginx
# /etc/nginx/nginx.conf

upstream backend_servers {
    # Round Robin (default)
    server 192.168.1.10:8080 weight=3;
    server 192.168.1.11:8080 weight=2;
    server 192.168.1.12:8080 weight=1;
    
    # Health check
    # server 192.168.1.10:8080 max_fails=3 fail_timeout=30s;
}

server {
    listen 80;
    server_name example.com;
    
    location / {
        proxy_pass http://backend_servers;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    # Health check endpoint
    location /health {
        return 200 'OK';
    }
}
```

---

## ✏️ অনুশীলনী

### ১. সঠিক Algorithm বাছুন
```
এই scenarios এ কোন algorithm ভালো?

a) সব server সমান capacity
b) Login session maintain করতে হবে
c) কিছু server বেশি powerful
d) Real-time response critical
```

### ২. True/False
```
a) L4 LB HTTP headers দেখতে পারে
b) Health check failed হলে server pool থেকে remove হয়
c) Sticky session মানে random server selection
d) SSL termination এ LB তে certificate থাকে
```

### ৩. Design করুন
```
একটি e-commerce site এর জন্য:
- 3টি web server
- 2টি API server  
- 1টি admin server

Load balancer architecture আঁকুন।
কোন algorithm ব্যবহার করবেন?
```

---

## 🎓 মনে রাখুন

```
Load Balancing =
  High Availability
  + Scalability
  + Performance

L4 = Fast, simple (TCP/UDP level)
L7 = Smart, content-aware (HTTP level)

Always configure health checks!
```

---

**🔙 [পূর্ববর্তী: Wireless Security](./??-?????????.md)** | **🔜 [পরবর্তী: QoS](./??-??????.md)**


